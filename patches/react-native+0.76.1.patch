diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp b/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp
index 122956d..95ca523 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp
@@ -136,8 +136,7 @@ void RawPropsParser::preparse(const RawProps& rawProps) const noexcept {
         rawProps.keyIndexToValueIndex_[keyIndex] = valueIndex;
 
         auto value = object.getProperty(runtime, nameValue);
-        rawProps.values_.push_back(
-            RawValue(jsi::dynamicFromValue(runtime, value)));
+        rawProps.values_.push_back(RawValue(runtime, value));
         valueIndex++;
       }
 
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h b/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h
index ef13688..d1cc5e5 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h
@@ -8,6 +8,7 @@
 #pragma once
 
 #include <unordered_map>
+#include <variant>
 
 #include <folly/dynamic.h>
 #include <jsi/JSIDynamic.h>
@@ -54,119 +55,224 @@ class RawValue {
   /*
    * Constructors.
    */
-  RawValue() noexcept : dynamic_(nullptr) {}
+  RawValue() noexcept : value_(folly::dynamic(nullptr)) {}
 
-  RawValue(RawValue&& other) noexcept : dynamic_(std::move(other.dynamic_)) {}
+  RawValue(RawValue&& other) noexcept : value_(std::move(other.value_)) {}
 
   RawValue& operator=(RawValue&& other) noexcept {
     if (this != &other) {
-      dynamic_ = std::move(other.dynamic_);
+      value_ = std::move(other.value_);
     }
     return *this;
   }
 
-  explicit RawValue(const folly::dynamic& dynamic) noexcept
-      : dynamic_(dynamic) {}
+  explicit RawValue(jsi::Runtime& runtime, const jsi::Value& value) noexcept
+      : value_(std::make_pair(&runtime, jsi::Value(runtime, value))) {}
+
+  explicit RawValue(jsi::Runtime& runtime, jsi::Value&& value) noexcept
+      : value_(std::make_pair(&runtime, std::move(value))) {}
+
+  explicit RawValue(const folly::dynamic& dynamic) noexcept : value_(dynamic) {}
 
   explicit RawValue(folly::dynamic&& dynamic) noexcept
-      : dynamic_(std::move(dynamic)) {}
+      : value_(std::move(dynamic)) {}
 
  private:
   friend class RawProps;
   friend class RawPropsParser;
   friend class UIManagerBinding;
 
-  /*
-   * Copy constructor and copy assignment operator would be private and only for
-   * internal use, but it's needed for user-code that does `auto val =
-   * (butter::map<std::string, RawValue>)rawVal;`
-   */
-  RawValue(const RawValue& other) noexcept : dynamic_(other.dynamic_) {}
+  RawValue(const RawValue& other) noexcept {
+    if (std::holds_alternative<folly::dynamic>(other.value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(other.value_);
+      value_ = dynamic;
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(other.value_);
+      value_ = std::make_pair(runtime, jsi::Value(*runtime, value));
+    }
+  }
 
   RawValue& operator=(const RawValue& other) noexcept {
     if (this != &other) {
-      dynamic_ = other.dynamic_;
+      if (std::holds_alternative<folly::dynamic>(other.value_)) {
+        folly::dynamic dynamic = std::get<folly::dynamic>(other.value_);
+        value_ = dynamic;
+      } else {
+        const auto& [runtime, value] = std::get<JsiValuePair>(other.value_);
+        value_ = std::make_pair(runtime, jsi::Value(*runtime, value));
+      }
     }
     return *this;
   }
 
  public:
+  using JsiValuePair = std::pair<jsi::Runtime*, jsi::Value>;
+
   /*
    * Casts the value to a specified type.
    */
   template <typename T>
   explicit operator T() const {
-    return castValue(dynamic_, (T*)nullptr);
+    if (std::holds_alternative<folly::dynamic>(value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(value_);
+      return castValue(dynamic, (T*)nullptr);
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(value_);
+      return castValue(runtime, value, (T*)nullptr);
+    }
   }
 
   inline explicit operator folly::dynamic() const noexcept {
-    return dynamic_;
+    return std::get<folly::dynamic>(value_);
   }
 
   /*
    * Checks if the stored value has specified type.
    */
   template <typename T>
-  bool hasType() const noexcept {
-    return checkValueType(dynamic_, (T*)nullptr);
+  bool hasType() const {
+    if (std::holds_alternative<folly::dynamic>(value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(value_);
+      return checkValueType(dynamic, (T*)nullptr);
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(value_);
+      return checkValueType(runtime, value, (T*)nullptr);
+    }
   }
 
   /*
    * Checks if the stored value is *not* `null`.
    */
-  bool hasValue() const noexcept {
-    return !dynamic_.isNull();
+  bool hasValue() const {
+    if (std::holds_alternative<folly::dynamic>(value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(value_);
+      return !dynamic.isNull();
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(value_);
+      return !value.isNull() && !value.isUndefined();
+    }
+  }
+
+  /**
+   * In case this RawValue was constructed from a jsi::Value
+   * this method will return the jsi::Runtime and jsi::Value pair.
+   */
+  const JsiValuePair& experimental_getJsiValuePair() const {
+    return std::get<JsiValuePair>(value_);
   }
 
  private:
-  folly::dynamic dynamic_;
+  using ValueVariant = std::variant<folly::dynamic, JsiValuePair>;
+  ValueVariant value_;
 
   static bool checkValueType(
-      const folly::dynamic& dynamic,
-      RawValue* type) noexcept {
+      const folly::dynamic& /*dynamic*/,
+      RawValue* /*type*/) noexcept {
+    return true;
+  }
+
+  static bool checkValueType(
+      jsi::Runtime* /*runtime*/,
+      const jsi::Value& /*value*/,
+      RawValue* /*type*/) noexcept {
     return true;
   }
 
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      bool* type) noexcept {
+      bool* /*type*/) noexcept {
     return dynamic.isBool();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      bool* /*type*/) noexcept {
+    return value.isBool();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      int* type) noexcept {
+      int* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      int* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      int64_t* type) noexcept {
+      int64_t* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      int64_t* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      float* type) noexcept {
+      float* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      float* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      double* type) noexcept {
+      double* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      double* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      std::string* type) noexcept {
+      std::string* /*type*/) noexcept {
     return dynamic.isString();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::string* /*type*/) noexcept {
+    return value.isString();
+  }
+
+  static bool checkValueType(
+      const folly::dynamic& dynamic,
+      JsiValuePair* /*type*/) noexcept {
+    return false;
+  }
+
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      JsiValuePair* /*type*/) noexcept {
+    return true;
+  }
+
   template <typename T>
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      std::vector<T>* type) noexcept {
+      std::vector<T>* /*type*/) noexcept {
     if (!dynamic.isArray()) {
       return false;
     }
@@ -183,10 +289,40 @@ class RawValue {
     return true;
   }
 
+  template <typename T>
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::vector<T>* /*type*/) noexcept {
+    if (!value.isObject()) {
+      return false;
+    }
+
+    jsi::Object asObject = value.getObject(*runtime);
+
+    if (!asObject.isArray(*runtime)) {
+      return false;
+    }
+
+    jsi::Array array = asObject.getArray(*runtime);
+    size_t size = array.size(*runtime);
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value itemValue = array.getValueAtIndex(*runtime, i);
+      if (!checkValueType(runtime, itemValue, (T*)nullptr)) {
+        return false;
+      }
+
+      // Note: We test only one element.
+      break;
+    }
+
+    return true;
+  }
+
   template <typename T>
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      std::unordered_map<std::string, T>* type) noexcept {
+      std::unordered_map<std::string, T>* /*type*/) noexcept {
     if (!dynamic.isObject()) {
       return false;
     }
@@ -204,43 +340,129 @@ class RawValue {
     return true;
   }
 
+  template <typename T>
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::unordered_map<std::string, T>* /*type*/) noexcept {
+    if (!value.isObject()) {
+      return false;
+    }
+
+    jsi::Object asObject = value.getObject(*runtime);
+
+    auto propertyNames = asObject.getPropertyNames(*runtime);
+    size_t size = propertyNames.size(*runtime);
+    for (size_t i = 0; i < size; i++) {
+      jsi::String propertyName =
+          propertyNames.getValueAtIndex(*runtime, i).getString(*runtime);
+      jsi::Value propertyValue = asObject.getProperty(*runtime, propertyName);
+      if (!checkValueType(runtime, propertyValue, (T*)nullptr)) {
+        return false;
+      }
+
+      // Note: We test only one element.
+      break;
+    }
+
+    return true;
+  }
+
   // Casts
   static RawValue castValue(
       const folly::dynamic& dynamic,
-      RawValue* type) noexcept {
+      RawValue* /*type*/) noexcept {
     return RawValue(dynamic);
   }
 
-  static bool castValue(const folly::dynamic& dynamic, bool* type) {
+  static RawValue castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      RawValue* /*type*/) noexcept {
+    return RawValue(*runtime, value);
+  }
+
+  static bool castValue(const folly::dynamic& dynamic, bool* /*type*/) {
     return dynamic.getBool();
   }
 
-  static int castValue(const folly::dynamic& dynamic, int* type) {
+  static bool
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, bool* /*type*/) {
+    return value.asBool();
+  }
+
+  static int castValue(const folly::dynamic& dynamic, int* /*type*/) {
     return static_cast<int>(dynamic.asInt());
   }
 
-  static int64_t castValue(const folly::dynamic& dynamic, int64_t* type) {
+  static int
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, int* /*type*/) {
+    double number = value.asNumber();
+    return static_cast<int>(number);
+  }
+
+  static int64_t castValue(const folly::dynamic& dynamic, int64_t* /*type*/) {
     return dynamic.asInt();
   }
 
-  static float castValue(const folly::dynamic& dynamic, float* type) {
+  static int64_t
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, int64_t* /*type*/) {
+    double number = value.asNumber();
+    return static_cast<int64_t>(number);
+  }
+
+  static float castValue(const folly::dynamic& dynamic, float* /*type*/) {
     return static_cast<float>(dynamic.asDouble());
   }
 
-  static double castValue(const folly::dynamic& dynamic, double* type) {
+  static float
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, float* /*type*/) {
+    double number = value.asNumber();
+    return static_cast<float>(number);
+  }
+
+  static double castValue(const folly::dynamic& dynamic, double* /*type*/) {
     return dynamic.asDouble();
   }
 
+  static double
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, double* /*type*/) {
+    return value.asNumber();
+  }
+
   static std::string castValue(
       const folly::dynamic& dynamic,
-      std::string* type) {
+      std::string* /*type*/) {
     return dynamic.getString();
   }
 
+  static std::string castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::string* /*type*/) {
+    jsi::String stringValue = value.asString(*runtime);
+    return stringValue.utf8(*runtime);
+  }
+
+  static JsiValuePair castValue(
+      const folly::dynamic& dynamic,
+      JsiValuePair* /*type*/) {
+    react_native_assert(false);
+    return {};
+  }
+
+  static JsiValuePair castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      JsiValuePair* /*type*/) {
+    jsi::Value valueCopy = jsi::Value(*runtime, value);
+    return std::make_pair(runtime, std::move(valueCopy));
+  }
+
   template <typename T>
   static std::vector<T> castValue(
       const folly::dynamic& dynamic,
-      std::vector<T>* type) {
+      std::vector<T>* /*type*/) {
     react_native_assert(dynamic.isArray());
     auto result = std::vector<T>{};
     result.reserve(dynamic.size());
@@ -250,10 +472,30 @@ class RawValue {
     return result;
   }
 
+  template <typename T>
+  static std::vector<T> castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::vector<T>* /*type*/) {
+    react_native_assert(value.isObject());
+    jsi::Object object = value.getObject(*runtime);
+    react_native_assert(object.isArray(*runtime));
+    jsi::Array array = object.getArray(*runtime);
+    size_t size = array.size(*runtime);
+    std::vector<T> result;
+    result.reserve(size);
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value itemValue = array.getValueAtIndex(*runtime, i);
+      T item = castValue(runtime, itemValue, (T*)nullptr);
+      result.push_back(std::move(item));
+    }
+    return result;
+  }
+
   template <typename T>
   static std::vector<std::vector<T>> castValue(
       const folly::dynamic& dynamic,
-      std::vector<std::vector<T>>* type) {
+      std::vector<std::vector<T>>* /*type*/) {
     react_native_assert(dynamic.isArray());
     auto result = std::vector<std::vector<T>>{};
     result.reserve(dynamic.size());
@@ -263,10 +505,31 @@ class RawValue {
     return result;
   }
 
+  template <typename T>
+  static std::vector<std::vector<T>> castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::vector<std::vector<T>>* /*type*/) {
+    react_native_assert(value.isObject());
+    jsi::Object object = value.getObject(*runtime);
+    react_native_assert(object.isArray(*runtime));
+    jsi::Array array = object.getArray(*runtime);
+    size_t size = array.size(*runtime);
+    std::vector<std::vector<T>> result;
+    result.reserve(size);
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value itemValue = array.getValueAtIndex(*runtime, i);
+      std::vector<T> item =
+          castValue(itemValue, runtime, (std::vector<T>*)nullptr);
+      result.push_back(std::move(item));
+    }
+    return result;
+  }
+
   template <typename T>
   static std::unordered_map<std::string, T> castValue(
       const folly::dynamic& dynamic,
-      std::unordered_map<std::string, T>* type) {
+      std::unordered_map<std::string, T>* /*type*/) {
     react_native_assert(dynamic.isObject());
     auto result = std::unordered_map<std::string, T>{};
     for (const auto& item : dynamic.items()) {
@@ -275,6 +538,33 @@ class RawValue {
     }
     return result;
   }
+
+  template <typename T>
+  static std::unordered_map<std::string, T> castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::unordered_map<std::string, T>* /*type*/) {
+    react_native_assert(value.isObject());
+    jsi::Object object = value.getObject(*runtime);
+    jsi::Array propertyNames = object.getPropertyNames(*runtime);
+    size_t size = propertyNames.size(*runtime);
+    std::unordered_map<std::string, T> result;
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value propertyNameValue = propertyNames.getValueAtIndex(*runtime, i);
+      jsi::String propertyName = propertyNameValue.getString(*runtime);
+      jsi::Value propertyValue = object.getProperty(*runtime, propertyName);
+      if (propertyValue.isUndefined()) {
+        // Skip undefined values to mimic JSIDynamic::dynamicFromValue behavior.
+        // Null values are allowed in the map.
+        continue;
+      }
+
+      std::string propertyNameString = propertyName.utf8(*runtime);
+      T property = castValue(runtime, propertyValue, (T*)nullptr);
+      result.emplace(propertyNameString, std::move(property));
+    }
+    return result;
+  }
 };
 
 } // namespace facebook::react
