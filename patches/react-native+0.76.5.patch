diff --git a/node_modules/react-native/ReactAndroid/build.gradle.kts b/node_modules/react-native/ReactAndroid/build.gradle.kts
index 52acc4c..8ab4cd0 100644
--- a/node_modules/react-native/ReactAndroid/build.gradle.kts
+++ b/node_modules/react-native/ReactAndroid/build.gradle.kts
@@ -96,7 +96,7 @@ val preparePrefab by
                       // jsiinpsector
                       Pair("../ReactCommon/jsinspector-modern/", "jsinspector-modern/"),
                       // mapbufferjni
-                      Pair("src/main/jni/react/mapbuffer", "react/mapbuffer/"),
+                      Pair("src/main/jni/react/mapbuffer", ""),
                       // turbomodulejsijni
                       Pair("src/main/jni/react/turbomodule", ""),
                       // react_codegen_rncore
diff --git a/node_modules/react-native/ReactAndroid/src/main/jni/react/fabric/StateWrapperImpl.cpp b/node_modules/react-native/ReactAndroid/src/main/jni/react/fabric/StateWrapperImpl.cpp
index 6ea03ff..0351565 100644
--- a/node_modules/react-native/ReactAndroid/src/main/jni/react/fabric/StateWrapperImpl.cpp
+++ b/node_modules/react-native/ReactAndroid/src/main/jni/react/fabric/StateWrapperImpl.cpp
@@ -88,6 +88,14 @@ void StateWrapperImpl::setState(std::shared_ptr<const State> state) {
   }
 }
 
+const State& StateWrapperImpl::getState() const {
+    if (ReactNativeFeatureFlags::fixMissedFabricStateUpdatesOnAndroid()) {
+      return *state_;
+    } else {
+      return *weakState_.lock();
+    }
+}
+
 void StateWrapperImpl::registerNatives() {
   registerHybrid({
       makeNativeMethod("initHybrid", StateWrapperImpl::initHybrid),
diff --git a/node_modules/react-native/ReactAndroid/src/main/jni/react/fabric/StateWrapperImpl.h b/node_modules/react-native/ReactAndroid/src/main/jni/react/fabric/StateWrapperImpl.h
index 542f78c..c0eec6a 100644
--- a/node_modules/react-native/ReactAndroid/src/main/jni/react/fabric/StateWrapperImpl.h
+++ b/node_modules/react-native/ReactAndroid/src/main/jni/react/fabric/StateWrapperImpl.h
@@ -29,6 +29,7 @@ class StateWrapperImpl : public jni::HybridClass<StateWrapperImpl> {
   jni::local_ref<ReadableNativeMap::jhybridobject> getStateDataImpl();
   void updateStateImpl(NativeMap* map);
   void setState(std::shared_ptr<const State> state);
+  const State& getState() const;
 
  private:
   jni::alias_ref<StateWrapperImpl::jhybriddata> jhybridobject_;
diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/JSIDynamic.cpp b/node_modules/react-native/ReactCommon/jsi/jsi/JSIDynamic.cpp
index 5a2d38d..637c425 100644
--- a/node_modules/react-native/ReactCommon/jsi/jsi/JSIDynamic.cpp
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/JSIDynamic.cpp
@@ -192,8 +192,17 @@ folly::dynamic dynamicFromValue(
         // The JSC conversion uses JSON.stringify, which substitutes
         // null for a function, so we do the same here.  Just dropping
         // the pair might also work, but would require more testing.
-        if (prop.isObject() && prop.getObject(runtime).isFunction(runtime)) {
-          prop = Value::null();
+        if (prop.isObject()) {
+            Object obj = prop.getObject(runtime);
+            if (obj.isFunction(runtime)) {
+                prop = Value::null();
+            }
+//            if (obj.hasNativeState(runtime)) {
+//                // Quick workaround for nitro for now, this will be handled more accurately
+//                // using the filter function once this pr has landed:
+//                //  https://github.com/facebook/react-native/pull/48202
+//                continue;
+//            }
         }
         props.emplace_back(std::move(nameStr), std::move(prop));
         top.dyn->insert(props.back().first, nullptr);
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/unimplementedview/UnimplementedViewComponentDescriptor.cpp b/node_modules/react-native/ReactCommon/react/renderer/components/unimplementedview/UnimplementedViewComponentDescriptor.cpp
index 7b42990..7ab61cc 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/unimplementedview/UnimplementedViewComponentDescriptor.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/unimplementedview/UnimplementedViewComponentDescriptor.cpp
@@ -29,7 +29,7 @@ Props::Shared UnimplementedViewComponentDescriptor::cloneProps(
   // We have to clone `Props` object one more time to make sure that we have
   // an unshared (and non-`const`) copy of it which we can mutate.
   RawProps emptyRawProps{};
-  emptyRawProps.parse(rawPropsParser_);
+  emptyRawProps.parse(*rawPropsParser_);
   auto unimplementedViewProps = std::make_shared<UnimplementedViewProps>(
       context,
       static_cast<const UnimplementedViewProps&>(*clonedProps),
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/BaseViewProps.cpp b/node_modules/react-native/ReactCommon/react/renderer/components/view/BaseViewProps.cpp
index 4047aeb..ee624ff 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/BaseViewProps.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/BaseViewProps.cpp
@@ -53,8 +53,9 @@ std::array<float, 3> getTranslateForTransformOrigin(
 BaseViewProps::BaseViewProps(
     const PropsParserContext& context,
     const BaseViewProps& sourceProps,
-    const RawProps& rawProps)
-    : YogaStylableProps(context, sourceProps, rawProps),
+    const RawProps& rawProps,
+    const std::function<bool(const std::string&)>& filterObjectKeys)
+      : YogaStylableProps(context, sourceProps, rawProps, filterObjectKeys),
       AccessibilityProps(context, sourceProps, rawProps),
       opacity(
           CoreFeatures::enablePropIteratorSetter ? sourceProps.opacity
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/BaseViewProps.h b/node_modules/react-native/ReactCommon/react/renderer/components/view/BaseViewProps.h
index edc0155..9adc4fb 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/BaseViewProps.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/BaseViewProps.h
@@ -31,7 +31,9 @@ class BaseViewProps : public YogaStylableProps, public AccessibilityProps {
   BaseViewProps(
       const PropsParserContext& context,
       const BaseViewProps& sourceProps,
-      const RawProps& rawProps);
+      const RawProps& rawProps,
+      const std::function<bool(const std::string&)>& filterObjectKeys =
+        nullptr);
 
   void setProp(
       const PropsParserContext& context,
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp b/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp
index 508e3ae..314f3c4 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.cpp
@@ -19,9 +19,10 @@ namespace facebook::react {
 YogaStylableProps::YogaStylableProps(
     const PropsParserContext& context,
     const YogaStylableProps& sourceProps,
-    const RawProps& rawProps)
+    const RawProps& rawProps,
+    const std::function<bool(const std::string&)>& filterObjectKeys)
     : Props() {
-  initialize(context, sourceProps, rawProps);
+    initialize(context, sourceProps, rawProps, filterObjectKeys);
 
   yogaStyle.setDirection(convertRawProp(
       context,
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.h b/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.h
index ef120f4..2e6defe 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaStylableProps.h
@@ -21,7 +21,9 @@ class YogaStylableProps : public Props {
   YogaStylableProps(
       const PropsParserContext& context,
       const YogaStylableProps& sourceProps,
-      const RawProps& rawProps);
+      const RawProps& rawProps,
+      const std::function<bool(const std::string&)>& filterObjectKeys =
+        nullptr);
 
   void setProp(
       const PropsParserContext& context,
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/platform/android/react/renderer/components/view/HostPlatformViewProps.cpp b/node_modules/react-native/ReactCommon/react/renderer/components/view/platform/android/react/renderer/components/view/HostPlatformViewProps.cpp
index 021268b..6dc5f16 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/platform/android/react/renderer/components/view/HostPlatformViewProps.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/platform/android/react/renderer/components/view/HostPlatformViewProps.cpp
@@ -20,8 +20,9 @@ namespace facebook::react {
 HostPlatformViewProps::HostPlatformViewProps(
     const PropsParserContext& context,
     const HostPlatformViewProps& sourceProps,
-    const RawProps& rawProps)
-    : BaseViewProps(context, sourceProps, rawProps),
+    const RawProps& rawProps,
+    const std::function<bool(const std::string&)>& filterObjectKeys)
+        : BaseViewProps(context, sourceProps, rawProps, filterObjectKeys),
       elevation(
           CoreFeatures::enablePropIteratorSetter ? sourceProps.elevation
                                                  : convertRawProp(
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/platform/android/react/renderer/components/view/HostPlatformViewProps.h b/node_modules/react-native/ReactCommon/react/renderer/components/view/platform/android/react/renderer/components/view/HostPlatformViewProps.h
index 89325ab..b8b2f66 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/platform/android/react/renderer/components/view/HostPlatformViewProps.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/platform/android/react/renderer/components/view/HostPlatformViewProps.h
@@ -26,7 +26,8 @@ class HostPlatformViewProps : public BaseViewProps {
   HostPlatformViewProps(
       const PropsParserContext& context,
       const HostPlatformViewProps& sourceProps,
-      const RawProps& rawProps);
+      const RawProps& rawProps,
+      const std::function<bool(const std::string&)>& filterObjectKeys = nullptr);
 
   void setProp(
       const PropsParserContext& context,
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.cpp b/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.cpp
index ca23205..c5beaac 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.cpp
@@ -10,11 +10,21 @@
 
 namespace facebook::react {
 
+    ComponentDescriptor::ComponentDescriptor(const ComponentDescriptorParameters& parameters)
+            : eventDispatcher_(parameters.eventDispatcher),
+              contextContainer_(parameters.contextContainer),
+              flavor_(parameters.flavor) {
+                rawPropsParser_ = std::make_unique<RawPropsParser>();
+              }
+
 ComponentDescriptor::ComponentDescriptor(
-    const ComponentDescriptorParameters& parameters)
-    : eventDispatcher_(parameters.eventDispatcher),
-      contextContainer_(parameters.contextContainer),
-      flavor_(parameters.flavor) {}
+    const ComponentDescriptorParameters& parameters,
+    std::unique_ptr<RawPropsParser>&& rawPropsParser)
+    : ComponentDescriptor(parameters) {
+      react_native_assert(rawPropsParser != nullptr && "RawPropsParser is nullptr!");
+      
+        rawPropsParser_ = std::move(rawPropsParser);
+    }
 
 const std::shared_ptr<const ContextContainer>&
 ComponentDescriptor::getContextContainer() const {
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.h b/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.h
index 07c5c6c..22295fc 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.h
@@ -46,7 +46,11 @@ class ComponentDescriptor {
    */
   using Flavor = std::shared_ptr<const void>;
 
-  ComponentDescriptor(const ComponentDescriptorParameters& parameters);
+  explicit ComponentDescriptor(const ComponentDescriptorParameters& parameters);
+
+  ComponentDescriptor(
+          const ComponentDescriptorParameters& parameters,
+          std::unique_ptr<RawPropsParser>&& rawPropsParser);
 
   virtual ~ComponentDescriptor() = default;
 
@@ -133,8 +137,8 @@ class ComponentDescriptor {
 
   EventDispatcher::Weak eventDispatcher_;
   std::shared_ptr<const ContextContainer> contextContainer_;
-  RawPropsParser rawPropsParser_{};
   Flavor flavor_;
+  std::unique_ptr<RawPropsParser> rawPropsParser_{};
 
   /*
    * Called immediately after `ShadowNode` is created, cloned or state is
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/ConcreteComponentDescriptor.h b/node_modules/react-native/ReactCommon/react/renderer/core/ConcreteComponentDescriptor.h
index 5405660..b2930ee 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/ConcreteComponentDescriptor.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/ConcreteComponentDescriptor.h
@@ -11,6 +11,7 @@
 #include <vector>
 
 #include <react/debug/react_native_assert.h>
+#include <react/featureflags/ReactNativeFeatureFlags.h>
 #include <react/renderer/core/ComponentDescriptor.h>
 #include <react/renderer/core/EventDispatcher.h>
 #include <react/renderer/core/Props.h>
@@ -46,9 +47,17 @@ class ConcreteComponentDescriptor : public ComponentDescriptor {
   using ConcreteState = typename ShadowNodeT::ConcreteState;
   using ConcreteStateData = typename ShadowNodeT::ConcreteState::Data;
 
-  ConcreteComponentDescriptor(const ComponentDescriptorParameters& parameters)
+  explicit ConcreteComponentDescriptor(
+      const ComponentDescriptorParameters& parameters)
       : ComponentDescriptor(parameters) {
-    rawPropsParser_.prepare<ConcreteProps>();
+    rawPropsParser_->prepare<ConcreteProps>();
+  }
+
+  ConcreteComponentDescriptor(
+      const ComponentDescriptorParameters& parameters,
+      std::unique_ptr<RawPropsParser>&& rawPropsParser)
+      : ComponentDescriptor(parameters, std::move(rawPropsParser)) {
+    rawPropsParser_->prepare<ConcreteProps>();
   }
 
   ComponentHandle getComponentHandle() const override {
@@ -110,7 +119,7 @@ class ConcreteComponentDescriptor : public ComponentDescriptor {
       ShadowNodeT::filterRawProps(rawProps);
     }
 
-    rawProps.parse(rawPropsParser_);
+    rawProps.parse(*rawPropsParser_);
 
     // Use the new-style iterator
     // Note that we just check if `Props` has this flag set, no matter
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/Props.cpp b/node_modules/react-native/ReactCommon/react/renderer/core/Props.cpp
index df133e8..05cc3c0 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/Props.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/Props.cpp
@@ -16,19 +16,21 @@ namespace facebook::react {
 Props::Props(
     const PropsParserContext& context,
     const Props& sourceProps,
-    const RawProps& rawProps) {
-  initialize(context, sourceProps, rawProps);
+    const RawProps& rawProps,
+    const std::function<bool(const std::string&)>& filterObjectKeys) {
+  initialize(context, sourceProps, rawProps, filterObjectKeys);
 }
 
 void Props::initialize(
     const PropsParserContext& context,
     const Props& sourceProps,
-    const RawProps& rawProps) {
+    const RawProps& rawProps,
+    const std::function<bool(const std::string&)>& filterObjectKeys) {
   nativeId = CoreFeatures::enablePropIteratorSetter
       ? sourceProps.nativeId
       : convertRawProp(context, rawProps, "nativeID", sourceProps.nativeId, {});
 #ifdef ANDROID
-  this->rawProps = (folly::dynamic)rawProps;
+  this->rawProps = rawProps.toDynamic(filterObjectKeys);
 #endif
 }
 
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/Props.h b/node_modules/react-native/ReactCommon/react/renderer/core/Props.h
index 144cc8a..d8c1b45 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/Props.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/Props.h
@@ -33,7 +33,8 @@ class Props : public virtual Sealable, public virtual DebugStringConvertible {
   Props(
       const PropsParserContext& context,
       const Props& sourceProps,
-      const RawProps& rawProps);
+      const RawProps& rawProps,
+      const std::function<bool(const std::string&)>& filterObjectKeys = nullptr);
   virtual ~Props() = default;
 
   Props(const Props& other) = delete;
@@ -71,7 +72,8 @@ class Props : public virtual Sealable, public virtual DebugStringConvertible {
   void initialize(
       const PropsParserContext& context,
       const Props& sourceProps,
-      const RawProps& rawProps);
+      const RawProps& rawProps,
+      const std::function<bool(const std::string&)>& filterObjectKeys = nullptr);
 };
 
 } // namespace facebook::react
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/RawProps.cpp b/node_modules/react-native/ReactCommon/react/renderer/core/RawProps.cpp
index 06226c5..0b983f7 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/RawProps.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/RawProps.cpp
@@ -167,18 +167,38 @@ void RawProps::parse(const RawPropsParser& parser) noexcept {
   parser.preparse(*this);
 }
 
+RawProps::operator folly::dynamic() const {
+    return toDynamic();
+}
+
 /*
  * Deprecated. Do not use.
  * The support for explicit conversion to `folly::dynamic` is deprecated and
  * will be removed as soon Android implementation does not need it.
  */
-RawProps::operator folly::dynamic() const noexcept {
+folly::dynamic RawProps::toDynamic(
+        const std::function<bool(const std::string&)>& filterObjectKeys) const {
   switch (mode_) {
     case Mode::Empty:
       return folly::dynamic::object();
-    case Mode::JSI:
-      return jsi::dynamicFromValue(
-          *runtime_, value_, ignoreYogaStyleProps_ ? isYogaStyleProp : nullptr);
+      case Mode::JSI: {
+          if (ignoreYogaStyleProps_ || filterObjectKeys != nullptr) {
+              // We need to filter props
+              return jsi::dynamicFromValue(
+                      *runtime_, value_, [&](const std::string& key) {
+                          if (ignoreYogaStyleProps_ && isYogaStyleProp(key)) {
+                              return true;
+                          }
+                          if (filterObjectKeys) {
+                              return filterObjectKeys(key);
+                          }
+                          return false;
+                      });
+          } else {
+              // We don't need to filter, just include all props by default
+              return jsi::dynamicFromValue(*runtime_, value_, nullptr);
+          }
+      }
     case Mode::Dynamic:
       return dynamic_;
   }
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/RawProps.h b/node_modules/react-native/ReactCommon/react/renderer/core/RawProps.h
index b7716be..537a0c6 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/RawProps.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/RawProps.h
@@ -71,7 +71,16 @@ class RawProps final {
    * The support for explicit conversion to `folly::dynamic` is deprecated and
    * will be removed as soon Android implementation does not need it.
    */
-  explicit operator folly::dynamic() const noexcept;
+  explicit operator folly::dynamic() const;
+
+  /*
+   * Deprecated. Do not use.
+   * The support for explicit conversion to `folly::dynamic` is deprecated and
+   * will be removed as soon Android implementation does not need it.
+   */
+    folly::dynamic toDynamic(
+            const std::function<bool(const std::string&)>& filterObjectKeys =
+            nullptr) const;
 
   /*
    * Once called, Yoga style props will be filtered out during conversion to
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp b/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp
index 122956d..9b09bf7 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp
@@ -8,6 +8,7 @@
 #include "RawPropsParser.h"
 
 #include <react/debug/react_native_assert.h>
+#include <react/featureflags/ReactNativeFeatureFlags.h>
 #include <react/renderer/core/RawProps.h>
 
 #include <glog/logging.h>
@@ -136,8 +137,13 @@ void RawPropsParser::preparse(const RawProps& rawProps) const noexcept {
         rawProps.keyIndexToValueIndex_[keyIndex] = valueIndex;
 
         auto value = object.getProperty(runtime, nameValue);
-        rawProps.values_.push_back(
-            RawValue(jsi::dynamicFromValue(runtime, value)));
+        RawValue rawValue;
+        if (useRawJsiProps_) {
+          rawValue = RawValue(runtime, std::move(value));
+        } else {
+          rawValue = RawValue(jsi::dynamicFromValue(runtime, value));
+        }
+        rawProps.values_.push_back(std::move(rawValue));
         valueIndex++;
       }
 
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.h b/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.h
index 6016c39..8e8b5fd 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.h
@@ -21,13 +21,14 @@ namespace facebook::react {
  * Specialized (to a particular type of Props) parser that provides the most
  * efficient access to `RawProps` content.
  */
-class RawPropsParser final {
+class RawPropsParser {
  public:
   /*
    * Default constructor.
    * To be used by `ConcreteComponentDescriptor` only.
    */
-  RawPropsParser() = default;
+  RawPropsParser(bool useRawJsiProps = false)
+      : useRawJsiProps_(useRawJsiProps) {};
 
   /*
    * To be used by `ConcreteComponentDescriptor` only.
@@ -56,6 +57,7 @@ class RawPropsParser final {
   template <class ShadowNodeT>
   friend class ConcreteComponentDescriptor;
   friend class RawProps;
+  bool useRawJsiProps_;
 
   /*
    * To be used by `RawProps` only.
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h b/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h
index ef13688..d0101c0 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h
@@ -8,6 +8,7 @@
 #pragma once
 
 #include <unordered_map>
+#include <variant>
 
 #include <folly/dynamic.h>
 #include <jsi/JSIDynamic.h>
@@ -54,38 +55,52 @@ class RawValue {
   /*
    * Constructors.
    */
-  RawValue() noexcept : dynamic_(nullptr) {}
+  RawValue() noexcept : value_(folly::dynamic(nullptr)) {}
 
-  RawValue(RawValue&& other) noexcept : dynamic_(std::move(other.dynamic_)) {}
+  RawValue(RawValue&& other) noexcept : value_(std::move(other.value_)) {}
 
   RawValue& operator=(RawValue&& other) noexcept {
     if (this != &other) {
-      dynamic_ = std::move(other.dynamic_);
+      value_ = std::move(other.value_);
     }
     return *this;
   }
 
-  explicit RawValue(const folly::dynamic& dynamic) noexcept
-      : dynamic_(dynamic) {}
+  explicit RawValue(jsi::Runtime& runtime, const jsi::Value& value) noexcept
+      : value_(std::make_pair(&runtime, jsi::Value(runtime, value))) {}
+
+  explicit RawValue(jsi::Runtime& runtime, jsi::Value&& value) noexcept
+      : value_(std::make_pair(&runtime, std::move(value))) {}
+
+  explicit RawValue(const folly::dynamic& dynamic) noexcept : value_(dynamic) {}
 
   explicit RawValue(folly::dynamic&& dynamic) noexcept
-      : dynamic_(std::move(dynamic)) {}
+      : value_(std::move(dynamic)) {}
 
  private:
   friend class RawProps;
   friend class RawPropsParser;
   friend class UIManagerBinding;
 
-  /*
-   * Copy constructor and copy assignment operator would be private and only for
-   * internal use, but it's needed for user-code that does `auto val =
-   * (butter::map<std::string, RawValue>)rawVal;`
-   */
-  RawValue(const RawValue& other) noexcept : dynamic_(other.dynamic_) {}
+  RawValue(const RawValue& other) noexcept {
+    if (std::holds_alternative<folly::dynamic>(other.value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(other.value_);
+      value_ = dynamic;
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(other.value_);
+      value_ = std::make_pair(runtime, jsi::Value(*runtime, value));
+    }
+  }
 
   RawValue& operator=(const RawValue& other) noexcept {
     if (this != &other) {
-      dynamic_ = other.dynamic_;
+      if (std::holds_alternative<folly::dynamic>(other.value_)) {
+        folly::dynamic dynamic = std::get<folly::dynamic>(other.value_);
+        value_ = dynamic;
+      } else {
+        const auto& [runtime, value] = std::get<JsiValuePair>(other.value_);
+        value_ = std::make_pair(runtime, jsi::Value(*runtime, value));
+      }
     }
     return *this;
   }
@@ -96,77 +111,161 @@ class RawValue {
    */
   template <typename T>
   explicit operator T() const {
-    return castValue(dynamic_, (T*)nullptr);
+    if (std::holds_alternative<folly::dynamic>(value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(value_);
+      return castValue(dynamic, (T*)nullptr);
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(value_);
+      return castValue(runtime, value, (T*)nullptr);
+    }
   }
 
   inline explicit operator folly::dynamic() const noexcept {
-    return dynamic_;
+    return std::get<folly::dynamic>(value_);
   }
 
   /*
    * Checks if the stored value has specified type.
    */
   template <typename T>
-  bool hasType() const noexcept {
-    return checkValueType(dynamic_, (T*)nullptr);
+  bool hasType() const {
+    if (std::holds_alternative<folly::dynamic>(value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(value_);
+      return checkValueType(dynamic, (T*)nullptr);
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(value_);
+      return checkValueType(runtime, value, (T*)nullptr);
+    }
   }
 
   /*
    * Checks if the stored value is *not* `null`.
    */
-  bool hasValue() const noexcept {
-    return !dynamic_.isNull();
+  bool hasValue() const {
+    if (std::holds_alternative<folly::dynamic>(value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(value_);
+      return !dynamic.isNull();
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(value_);
+      return !value.isNull() && !value.isUndefined();
+    }
   }
 
  private:
-  folly::dynamic dynamic_;
+  using JsiValuePair = std::pair<jsi::Runtime*, jsi::Value>;
+  using ValueVariant = std::variant<folly::dynamic, JsiValuePair>;
+  ValueVariant value_;
+
+  using JsiValueReturnType = std::pair<jsi::Runtime*, const jsi::Value&>;
 
   static bool checkValueType(
-      const folly::dynamic& dynamic,
-      RawValue* type) noexcept {
+      const folly::dynamic& /*dynamic*/,
+      RawValue* /*type*/) noexcept {
+    return true;
+  }
+
+  static bool checkValueType(
+      jsi::Runtime* /*runtime*/,
+      const jsi::Value& /*value*/,
+      RawValue* /*type*/) noexcept {
     return true;
   }
 
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      bool* type) noexcept {
+      bool* /*type*/) noexcept {
     return dynamic.isBool();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      bool* /*type*/) noexcept {
+    return value.isBool();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      int* type) noexcept {
+      int* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      int* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      int64_t* type) noexcept {
+      int64_t* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      int64_t* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      float* type) noexcept {
+      float* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      float* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      double* type) noexcept {
+      double* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      double* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      std::string* type) noexcept {
+      std::string* /*type*/) noexcept {
     return dynamic.isString();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::string* /*type*/) noexcept {
+    return value.isString();
+  }
+
+  static bool checkValueType(
+      const folly::dynamic& dynamic,
+      JsiValueReturnType* /*type*/) noexcept {
+    return false;
+  }
+
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      JsiValueReturnType* /*type*/) noexcept {
+    return true;
+  }
+
   template <typename T>
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      std::vector<T>* type) noexcept {
+      std::vector<T>* /*type*/) noexcept {
     if (!dynamic.isArray()) {
       return false;
     }
@@ -183,10 +282,40 @@ class RawValue {
     return true;
   }
 
+  template <typename T>
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::vector<T>* /*type*/) noexcept {
+    if (!value.isObject()) {
+      return false;
+    }
+
+    jsi::Object asObject = value.getObject(*runtime);
+
+    if (!asObject.isArray(*runtime)) {
+      return false;
+    }
+
+    jsi::Array array = asObject.getArray(*runtime);
+    size_t size = array.size(*runtime);
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value itemValue = array.getValueAtIndex(*runtime, i);
+      if (!checkValueType(runtime, itemValue, (T*)nullptr)) {
+        return false;
+      }
+
+      // Note: We test only one element.
+      break;
+    }
+
+    return true;
+  }
+
   template <typename T>
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      std::unordered_map<std::string, T>* type) noexcept {
+      std::unordered_map<std::string, T>* /*type*/) noexcept {
     if (!dynamic.isObject()) {
       return false;
     }
@@ -204,43 +333,129 @@ class RawValue {
     return true;
   }
 
+  template <typename T>
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::unordered_map<std::string, T>* /*type*/) noexcept {
+    if (!value.isObject()) {
+      return false;
+    }
+
+    jsi::Object asObject = value.getObject(*runtime);
+
+    auto propertyNames = asObject.getPropertyNames(*runtime);
+    size_t size = propertyNames.size(*runtime);
+    for (size_t i = 0; i < size; i++) {
+      jsi::String propertyName =
+          propertyNames.getValueAtIndex(*runtime, i).getString(*runtime);
+      jsi::Value propertyValue = asObject.getProperty(*runtime, propertyName);
+      if (!checkValueType(runtime, propertyValue, (T*)nullptr)) {
+        return false;
+      }
+
+      // Note: We test only one element.
+      break;
+    }
+
+    return true;
+  }
+
   // Casts
   static RawValue castValue(
       const folly::dynamic& dynamic,
-      RawValue* type) noexcept {
+      RawValue* /*type*/) noexcept {
     return RawValue(dynamic);
   }
 
-  static bool castValue(const folly::dynamic& dynamic, bool* type) {
+  static RawValue castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      RawValue* /*type*/) noexcept {
+    return RawValue(*runtime, value);
+  }
+
+  static bool castValue(const folly::dynamic& dynamic, bool* /*type*/) {
     return dynamic.getBool();
   }
 
-  static int castValue(const folly::dynamic& dynamic, int* type) {
+  static bool
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, bool* /*type*/) {
+    return value.asBool();
+  }
+
+  static int castValue(const folly::dynamic& dynamic, int* /*type*/) {
     return static_cast<int>(dynamic.asInt());
   }
 
-  static int64_t castValue(const folly::dynamic& dynamic, int64_t* type) {
+  static int
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, int* /*type*/) {
+    double number = value.asNumber();
+    return static_cast<int>(number);
+  }
+
+  static int64_t castValue(const folly::dynamic& dynamic, int64_t* /*type*/) {
     return dynamic.asInt();
   }
 
-  static float castValue(const folly::dynamic& dynamic, float* type) {
+  static int64_t
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, int64_t* /*type*/) {
+    double number = value.asNumber();
+    return static_cast<int64_t>(number);
+  }
+
+  static float castValue(const folly::dynamic& dynamic, float* /*type*/) {
     return static_cast<float>(dynamic.asDouble());
   }
 
-  static double castValue(const folly::dynamic& dynamic, double* type) {
+  static float
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, float* /*type*/) {
+    double number = value.asNumber();
+    return static_cast<float>(number);
+  }
+
+  static double castValue(const folly::dynamic& dynamic, double* /*type*/) {
     return dynamic.asDouble();
   }
 
+  static double
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, double* /*type*/) {
+    return value.asNumber();
+  }
+
   static std::string castValue(
       const folly::dynamic& dynamic,
-      std::string* type) {
+      std::string* /*type*/) {
     return dynamic.getString();
   }
 
+  static std::string castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::string* /*type*/) {
+    jsi::String stringValue = value.asString(*runtime);
+    return stringValue.utf8(*runtime);
+  }
+
+  static JsiValueReturnType castValue(
+      const folly::dynamic& dynamic,
+      JsiValueReturnType* /*type*/) {
+    react_native_assert(false);
+    throw new std::runtime_error(
+        "Cannot cast dynamic to a jsi::Value type. Please use the 'useRawPropsJsiValue' feature flag to enable jsi::Value support for RawValues.");
+  }
+
+  static JsiValueReturnType castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      JsiValueReturnType* /*type*/) {
+    return JsiValueReturnType(runtime, value);
+  }
+
   template <typename T>
   static std::vector<T> castValue(
       const folly::dynamic& dynamic,
-      std::vector<T>* type) {
+      std::vector<T>* /*type*/) {
     react_native_assert(dynamic.isArray());
     auto result = std::vector<T>{};
     result.reserve(dynamic.size());
@@ -250,10 +465,30 @@ class RawValue {
     return result;
   }
 
+  template <typename T>
+  static std::vector<T> castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::vector<T>* /*type*/) {
+    react_native_assert(value.isObject());
+    jsi::Object object = value.getObject(*runtime);
+    react_native_assert(object.isArray(*runtime));
+    jsi::Array array = object.getArray(*runtime);
+    size_t size = array.size(*runtime);
+    std::vector<T> result;
+    result.reserve(size);
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value itemValue = array.getValueAtIndex(*runtime, i);
+      T item = castValue(runtime, itemValue, (T*)nullptr);
+      result.push_back(std::move(item));
+    }
+    return result;
+  }
+
   template <typename T>
   static std::vector<std::vector<T>> castValue(
       const folly::dynamic& dynamic,
-      std::vector<std::vector<T>>* type) {
+      std::vector<std::vector<T>>* /*type*/) {
     react_native_assert(dynamic.isArray());
     auto result = std::vector<std::vector<T>>{};
     result.reserve(dynamic.size());
@@ -263,10 +498,31 @@ class RawValue {
     return result;
   }
 
+  template <typename T>
+  static std::vector<std::vector<T>> castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::vector<std::vector<T>>* /*type*/) {
+    react_native_assert(value.isObject());
+    jsi::Object object = value.getObject(*runtime);
+    react_native_assert(object.isArray(*runtime));
+    jsi::Array array = object.getArray(*runtime);
+    size_t size = array.size(*runtime);
+    std::vector<std::vector<T>> result;
+    result.reserve(size);
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value itemValue = array.getValueAtIndex(*runtime, i);
+      std::vector<T> item =
+          castValue(itemValue, runtime, (std::vector<T>*)nullptr);
+      result.push_back(std::move(item));
+    }
+    return result;
+  }
+
   template <typename T>
   static std::unordered_map<std::string, T> castValue(
       const folly::dynamic& dynamic,
-      std::unordered_map<std::string, T>* type) {
+      std::unordered_map<std::string, T>* /*type*/) {
     react_native_assert(dynamic.isObject());
     auto result = std::unordered_map<std::string, T>{};
     for (const auto& item : dynamic.items()) {
@@ -275,6 +531,33 @@ class RawValue {
     }
     return result;
   }
+
+  template <typename T>
+  static std::unordered_map<std::string, T> castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::unordered_map<std::string, T>* /*type*/) {
+    react_native_assert(value.isObject());
+    jsi::Object object = value.getObject(*runtime);
+    jsi::Array propertyNames = object.getPropertyNames(*runtime);
+    size_t size = propertyNames.size(*runtime);
+    std::unordered_map<std::string, T> result;
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value propertyNameValue = propertyNames.getValueAtIndex(*runtime, i);
+      jsi::String propertyName = propertyNameValue.getString(*runtime);
+      jsi::Value propertyValue = object.getProperty(*runtime, propertyName);
+      if (propertyValue.isUndefined()) {
+        // Skip undefined values to mimic JSIDynamic::dynamicFromValue behavior.
+        // Null values are allowed in the map.
+        continue;
+      }
+
+      std::string propertyNameString = propertyName.utf8(*runtime);
+      T property = castValue(runtime, propertyValue, (T*)nullptr);
+      result.emplace(propertyNameString, std::move(property));
+    }
+    return result;
+  }
 };
 
 } // namespace facebook::react
