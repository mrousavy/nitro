diff --git a/node_modules/react-native/React/Fabric/RCTThirdPartyFabricComponentsProvider.h b/node_modules/react-native/React/Fabric/RCTThirdPartyFabricComponentsProvider.h
new file mode 100644
index 0000000..31fd046
--- /dev/null
+++ b/node_modules/react-native/React/Fabric/RCTThirdPartyFabricComponentsProvider.h
@@ -0,0 +1,53 @@
+
+/*
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by GenerateRCTThirdPartyFabricComponentsProviderH
+ */
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wreturn-type-c-linkage"
+
+#import <React/RCTComponentViewProtocol.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+Class<RCTComponentViewProtocol> RCTThirdPartyFabricComponentsProvider(const char *name);
+#if RCT_NEW_ARCH_ENABLED
+#ifndef RCT_DYNAMIC_FRAMEWORKS
+
+#if !TARGET_OS_TV
+Class<RCTComponentViewProtocol> RNCSafeAreaProviderCls(void) __attribute__((used)); // 0
+Class<RCTComponentViewProtocol> RNCSafeAreaViewCls(void) __attribute__((used)); // 0
+#endif
+
+#if !TARGET_OS_OSX
+Class<RCTComponentViewProtocol> RNSFullWindowOverlayCls(void) __attribute__((used)); // 1
+Class<RCTComponentViewProtocol> RNSModalScreenCls(void) __attribute__((used)); // 1
+Class<RCTComponentViewProtocol> RNSScreenContainerCls(void) __attribute__((used)); // 1
+Class<RCTComponentViewProtocol> RNSScreenContentWrapperCls(void) __attribute__((used)); // 1
+Class<RCTComponentViewProtocol> RNSScreenFooterCls(void) __attribute__((used)); // 1
+Class<RCTComponentViewProtocol> RNSScreenCls(void) __attribute__((used)); // 1
+Class<RCTComponentViewProtocol> RNSScreenNavigationContainerCls(void) __attribute__((used)); // 1
+Class<RCTComponentViewProtocol> RNSScreenStackHeaderConfigCls(void) __attribute__((used)); // 1
+Class<RCTComponentViewProtocol> RNSScreenStackHeaderSubviewCls(void) __attribute__((used)); // 1
+Class<RCTComponentViewProtocol> RNSScreenStackCls(void) __attribute__((used)); // 1
+Class<RCTComponentViewProtocol> RNSSearchBarCls(void) __attribute__((used)); // 1
+#endif
+
+
+
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#pragma GCC diagnostic pop
+
diff --git a/node_modules/react-native/React/Fabric/RCTThirdPartyFabricComponentsProvider.mm b/node_modules/react-native/React/Fabric/RCTThirdPartyFabricComponentsProvider.mm
new file mode 100644
index 0000000..31e2621
--- /dev/null
+++ b/node_modules/react-native/React/Fabric/RCTThirdPartyFabricComponentsProvider.mm
@@ -0,0 +1,65 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by GenerateRCTThirdPartyFabricComponentsProviderCpp
+ */
+
+// OSS-compatibility layer
+
+#import "RCTThirdPartyFabricComponentsProvider.h"
+
+#import <string>
+#import <unordered_map>
+
+Class<RCTComponentViewProtocol> RCTThirdPartyFabricComponentsProvider(const char *name) {
+  static std::unordered_map<std::string, Class (*)(void)> sFabricComponentsClassMap = {
+    #if RCT_NEW_ARCH_ENABLED
+    #ifndef RCT_DYNAMIC_FRAMEWORKS
+#if !TARGET_OS_TV
+
+    {"RNCSafeAreaProvider", RNCSafeAreaProviderCls}, // 0
+
+    {"RNCSafeAreaView", RNCSafeAreaViewCls}, // 0
+#endif
+
+#if !TARGET_OS_OSX
+
+    {"RNSFullWindowOverlay", RNSFullWindowOverlayCls}, // 1
+
+    {"RNSModalScreen", RNSModalScreenCls}, // 1
+
+    {"RNSScreenContainer", RNSScreenContainerCls}, // 1
+
+    {"RNSScreenContentWrapper", RNSScreenContentWrapperCls}, // 1
+
+    {"RNSScreenFooter", RNSScreenFooterCls}, // 1
+
+    {"RNSScreen", RNSScreenCls}, // 1
+
+    {"RNSScreenNavigationContainer", RNSScreenNavigationContainerCls}, // 1
+
+    {"RNSScreenStackHeaderConfig", RNSScreenStackHeaderConfigCls}, // 1
+
+    {"RNSScreenStackHeaderSubview", RNSScreenStackHeaderSubviewCls}, // 1
+
+    {"RNSScreenStack", RNSScreenStackCls}, // 1
+
+    {"RNSSearchBar", RNSSearchBarCls}, // 1
+#endif
+
+
+    #endif
+    #endif
+  };
+
+  auto p = sFabricComponentsClassMap.find(name);
+  if (p != sFabricComponentsClassMap.end()) {
+    auto classFunc = p->second;
+    return classFunc();
+  }
+  return nil;
+}
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/unimplementedview/UnimplementedViewComponentDescriptor.cpp b/node_modules/react-native/ReactCommon/react/renderer/components/unimplementedview/UnimplementedViewComponentDescriptor.cpp
index 7b42990..7ab61cc 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/unimplementedview/UnimplementedViewComponentDescriptor.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/unimplementedview/UnimplementedViewComponentDescriptor.cpp
@@ -29,7 +29,7 @@ Props::Shared UnimplementedViewComponentDescriptor::cloneProps(
   // We have to clone `Props` object one more time to make sure that we have
   // an unshared (and non-`const`) copy of it which we can mutate.
   RawProps emptyRawProps{};
-  emptyRawProps.parse(rawPropsParser_);
+  emptyRawProps.parse(*rawPropsParser_);
   auto unimplementedViewProps = std::make_shared<UnimplementedViewProps>(
       context,
       static_cast<const UnimplementedViewProps&>(*clonedProps),
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.cpp b/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.cpp
index ca23205..961c10b 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.cpp
@@ -11,10 +11,12 @@
 namespace facebook::react {
 
 ComponentDescriptor::ComponentDescriptor(
-    const ComponentDescriptorParameters& parameters)
+    const ComponentDescriptorParameters& parameters,
+    std::unique_ptr<RawPropsParser> rawPropsParser)
     : eventDispatcher_(parameters.eventDispatcher),
       contextContainer_(parameters.contextContainer),
-      flavor_(parameters.flavor) {}
+      flavor_(parameters.flavor),
+      rawPropsParser_(std::move(rawPropsParser)) {}
 
 const std::shared_ptr<const ContextContainer>&
 ComponentDescriptor::getContextContainer() const {
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.h b/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.h
index 07c5c6c..f0a8422 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/ComponentDescriptor.h
@@ -46,7 +46,10 @@ class ComponentDescriptor {
    */
   using Flavor = std::shared_ptr<const void>;
 
-  ComponentDescriptor(const ComponentDescriptorParameters& parameters);
+  ComponentDescriptor(
+      const ComponentDescriptorParameters& parameters,
+      std::unique_ptr<RawPropsParser> rawPropsParser =
+          std::make_unique<RawPropsParser>());
 
   virtual ~ComponentDescriptor() = default;
 
@@ -133,7 +136,7 @@ class ComponentDescriptor {
 
   EventDispatcher::Weak eventDispatcher_;
   std::shared_ptr<const ContextContainer> contextContainer_;
-  RawPropsParser rawPropsParser_{};
+  std::unique_ptr<RawPropsParser> rawPropsParser_;
   Flavor flavor_;
 
   /*
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/ConcreteComponentDescriptor.h b/node_modules/react-native/ReactCommon/react/renderer/core/ConcreteComponentDescriptor.h
index 5405660..3564965 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/ConcreteComponentDescriptor.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/ConcreteComponentDescriptor.h
@@ -11,6 +11,7 @@
 #include <vector>
 
 #include <react/debug/react_native_assert.h>
+#include <react/featureflags/ReactNativeFeatureFlags.h>
 #include <react/renderer/core/ComponentDescriptor.h>
 #include <react/renderer/core/EventDispatcher.h>
 #include <react/renderer/core/Props.h>
@@ -46,9 +47,12 @@ class ConcreteComponentDescriptor : public ComponentDescriptor {
   using ConcreteState = typename ShadowNodeT::ConcreteState;
   using ConcreteStateData = typename ShadowNodeT::ConcreteState::Data;
 
-  ConcreteComponentDescriptor(const ComponentDescriptorParameters& parameters)
-      : ComponentDescriptor(parameters) {
-    rawPropsParser_.prepare<ConcreteProps>();
+  ConcreteComponentDescriptor(
+      const ComponentDescriptorParameters& parameters,
+      std::unique_ptr<RawPropsParser> rawPropsParser =
+          std::make_unique<RawPropsParser>())
+      : ComponentDescriptor(parameters, std::move(rawPropsParser)) {
+    rawPropsParser_->prepare<ConcreteProps>();
   }
 
   ComponentHandle getComponentHandle() const override {
@@ -110,7 +114,7 @@ class ConcreteComponentDescriptor : public ComponentDescriptor {
       ShadowNodeT::filterRawProps(rawProps);
     }
 
-    rawProps.parse(rawPropsParser_);
+    rawProps.parse(*rawPropsParser_);
 
     // Use the new-style iterator
     // Note that we just check if `Props` has this flag set, no matter
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp b/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp
index 122956d..9b09bf7 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.cpp
@@ -8,6 +8,7 @@
 #include "RawPropsParser.h"
 
 #include <react/debug/react_native_assert.h>
+#include <react/featureflags/ReactNativeFeatureFlags.h>
 #include <react/renderer/core/RawProps.h>
 
 #include <glog/logging.h>
@@ -136,8 +137,13 @@ void RawPropsParser::preparse(const RawProps& rawProps) const noexcept {
         rawProps.keyIndexToValueIndex_[keyIndex] = valueIndex;
 
         auto value = object.getProperty(runtime, nameValue);
-        rawProps.values_.push_back(
-            RawValue(jsi::dynamicFromValue(runtime, value)));
+        RawValue rawValue;
+        if (useRawJsiProps_) {
+          rawValue = RawValue(runtime, std::move(value));
+        } else {
+          rawValue = RawValue(jsi::dynamicFromValue(runtime, value));
+        }
+        rawProps.values_.push_back(std::move(rawValue));
         valueIndex++;
       }
 
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.h b/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.h
index 6016c39..8e8b5fd 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/RawPropsParser.h
@@ -21,13 +21,14 @@ namespace facebook::react {
  * Specialized (to a particular type of Props) parser that provides the most
  * efficient access to `RawProps` content.
  */
-class RawPropsParser final {
+class RawPropsParser {
  public:
   /*
    * Default constructor.
    * To be used by `ConcreteComponentDescriptor` only.
    */
-  RawPropsParser() = default;
+  RawPropsParser(bool useRawJsiProps = false)
+      : useRawJsiProps_(useRawJsiProps) {};
 
   /*
    * To be used by `ConcreteComponentDescriptor` only.
@@ -56,6 +57,7 @@ class RawPropsParser final {
   template <class ShadowNodeT>
   friend class ConcreteComponentDescriptor;
   friend class RawProps;
+  bool useRawJsiProps_;
 
   /*
    * To be used by `RawProps` only.
diff --git a/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h b/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h
index ef13688..d0101c0 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/core/RawValue.h
@@ -8,6 +8,7 @@
 #pragma once
 
 #include <unordered_map>
+#include <variant>
 
 #include <folly/dynamic.h>
 #include <jsi/JSIDynamic.h>
@@ -54,38 +55,52 @@ class RawValue {
   /*
    * Constructors.
    */
-  RawValue() noexcept : dynamic_(nullptr) {}
+  RawValue() noexcept : value_(folly::dynamic(nullptr)) {}
 
-  RawValue(RawValue&& other) noexcept : dynamic_(std::move(other.dynamic_)) {}
+  RawValue(RawValue&& other) noexcept : value_(std::move(other.value_)) {}
 
   RawValue& operator=(RawValue&& other) noexcept {
     if (this != &other) {
-      dynamic_ = std::move(other.dynamic_);
+      value_ = std::move(other.value_);
     }
     return *this;
   }
 
-  explicit RawValue(const folly::dynamic& dynamic) noexcept
-      : dynamic_(dynamic) {}
+  explicit RawValue(jsi::Runtime& runtime, const jsi::Value& value) noexcept
+      : value_(std::make_pair(&runtime, jsi::Value(runtime, value))) {}
+
+  explicit RawValue(jsi::Runtime& runtime, jsi::Value&& value) noexcept
+      : value_(std::make_pair(&runtime, std::move(value))) {}
+
+  explicit RawValue(const folly::dynamic& dynamic) noexcept : value_(dynamic) {}
 
   explicit RawValue(folly::dynamic&& dynamic) noexcept
-      : dynamic_(std::move(dynamic)) {}
+      : value_(std::move(dynamic)) {}
 
  private:
   friend class RawProps;
   friend class RawPropsParser;
   friend class UIManagerBinding;
 
-  /*
-   * Copy constructor and copy assignment operator would be private and only for
-   * internal use, but it's needed for user-code that does `auto val =
-   * (butter::map<std::string, RawValue>)rawVal;`
-   */
-  RawValue(const RawValue& other) noexcept : dynamic_(other.dynamic_) {}
+  RawValue(const RawValue& other) noexcept {
+    if (std::holds_alternative<folly::dynamic>(other.value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(other.value_);
+      value_ = dynamic;
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(other.value_);
+      value_ = std::make_pair(runtime, jsi::Value(*runtime, value));
+    }
+  }
 
   RawValue& operator=(const RawValue& other) noexcept {
     if (this != &other) {
-      dynamic_ = other.dynamic_;
+      if (std::holds_alternative<folly::dynamic>(other.value_)) {
+        folly::dynamic dynamic = std::get<folly::dynamic>(other.value_);
+        value_ = dynamic;
+      } else {
+        const auto& [runtime, value] = std::get<JsiValuePair>(other.value_);
+        value_ = std::make_pair(runtime, jsi::Value(*runtime, value));
+      }
     }
     return *this;
   }
@@ -96,77 +111,161 @@ class RawValue {
    */
   template <typename T>
   explicit operator T() const {
-    return castValue(dynamic_, (T*)nullptr);
+    if (std::holds_alternative<folly::dynamic>(value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(value_);
+      return castValue(dynamic, (T*)nullptr);
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(value_);
+      return castValue(runtime, value, (T*)nullptr);
+    }
   }
 
   inline explicit operator folly::dynamic() const noexcept {
-    return dynamic_;
+    return std::get<folly::dynamic>(value_);
   }
 
   /*
    * Checks if the stored value has specified type.
    */
   template <typename T>
-  bool hasType() const noexcept {
-    return checkValueType(dynamic_, (T*)nullptr);
+  bool hasType() const {
+    if (std::holds_alternative<folly::dynamic>(value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(value_);
+      return checkValueType(dynamic, (T*)nullptr);
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(value_);
+      return checkValueType(runtime, value, (T*)nullptr);
+    }
   }
 
   /*
    * Checks if the stored value is *not* `null`.
    */
-  bool hasValue() const noexcept {
-    return !dynamic_.isNull();
+  bool hasValue() const {
+    if (std::holds_alternative<folly::dynamic>(value_)) {
+      folly::dynamic dynamic = std::get<folly::dynamic>(value_);
+      return !dynamic.isNull();
+    } else {
+      const auto& [runtime, value] = std::get<JsiValuePair>(value_);
+      return !value.isNull() && !value.isUndefined();
+    }
   }
 
  private:
-  folly::dynamic dynamic_;
+  using JsiValuePair = std::pair<jsi::Runtime*, jsi::Value>;
+  using ValueVariant = std::variant<folly::dynamic, JsiValuePair>;
+  ValueVariant value_;
+
+  using JsiValueReturnType = std::pair<jsi::Runtime*, const jsi::Value&>;
 
   static bool checkValueType(
-      const folly::dynamic& dynamic,
-      RawValue* type) noexcept {
+      const folly::dynamic& /*dynamic*/,
+      RawValue* /*type*/) noexcept {
+    return true;
+  }
+
+  static bool checkValueType(
+      jsi::Runtime* /*runtime*/,
+      const jsi::Value& /*value*/,
+      RawValue* /*type*/) noexcept {
     return true;
   }
 
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      bool* type) noexcept {
+      bool* /*type*/) noexcept {
     return dynamic.isBool();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      bool* /*type*/) noexcept {
+    return value.isBool();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      int* type) noexcept {
+      int* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      int* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      int64_t* type) noexcept {
+      int64_t* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      int64_t* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      float* type) noexcept {
+      float* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      float* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      double* type) noexcept {
+      double* /*type*/) noexcept {
     return dynamic.isNumber();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      double* /*type*/) noexcept {
+    return value.isNumber();
+  }
+
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      std::string* type) noexcept {
+      std::string* /*type*/) noexcept {
     return dynamic.isString();
   }
 
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::string* /*type*/) noexcept {
+    return value.isString();
+  }
+
+  static bool checkValueType(
+      const folly::dynamic& dynamic,
+      JsiValueReturnType* /*type*/) noexcept {
+    return false;
+  }
+
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      JsiValueReturnType* /*type*/) noexcept {
+    return true;
+  }
+
   template <typename T>
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      std::vector<T>* type) noexcept {
+      std::vector<T>* /*type*/) noexcept {
     if (!dynamic.isArray()) {
       return false;
     }
@@ -183,10 +282,40 @@ class RawValue {
     return true;
   }
 
+  template <typename T>
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::vector<T>* /*type*/) noexcept {
+    if (!value.isObject()) {
+      return false;
+    }
+
+    jsi::Object asObject = value.getObject(*runtime);
+
+    if (!asObject.isArray(*runtime)) {
+      return false;
+    }
+
+    jsi::Array array = asObject.getArray(*runtime);
+    size_t size = array.size(*runtime);
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value itemValue = array.getValueAtIndex(*runtime, i);
+      if (!checkValueType(runtime, itemValue, (T*)nullptr)) {
+        return false;
+      }
+
+      // Note: We test only one element.
+      break;
+    }
+
+    return true;
+  }
+
   template <typename T>
   static bool checkValueType(
       const folly::dynamic& dynamic,
-      std::unordered_map<std::string, T>* type) noexcept {
+      std::unordered_map<std::string, T>* /*type*/) noexcept {
     if (!dynamic.isObject()) {
       return false;
     }
@@ -204,43 +333,129 @@ class RawValue {
     return true;
   }
 
+  template <typename T>
+  static bool checkValueType(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::unordered_map<std::string, T>* /*type*/) noexcept {
+    if (!value.isObject()) {
+      return false;
+    }
+
+    jsi::Object asObject = value.getObject(*runtime);
+
+    auto propertyNames = asObject.getPropertyNames(*runtime);
+    size_t size = propertyNames.size(*runtime);
+    for (size_t i = 0; i < size; i++) {
+      jsi::String propertyName =
+          propertyNames.getValueAtIndex(*runtime, i).getString(*runtime);
+      jsi::Value propertyValue = asObject.getProperty(*runtime, propertyName);
+      if (!checkValueType(runtime, propertyValue, (T*)nullptr)) {
+        return false;
+      }
+
+      // Note: We test only one element.
+      break;
+    }
+
+    return true;
+  }
+
   // Casts
   static RawValue castValue(
       const folly::dynamic& dynamic,
-      RawValue* type) noexcept {
+      RawValue* /*type*/) noexcept {
     return RawValue(dynamic);
   }
 
-  static bool castValue(const folly::dynamic& dynamic, bool* type) {
+  static RawValue castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      RawValue* /*type*/) noexcept {
+    return RawValue(*runtime, value);
+  }
+
+  static bool castValue(const folly::dynamic& dynamic, bool* /*type*/) {
     return dynamic.getBool();
   }
 
-  static int castValue(const folly::dynamic& dynamic, int* type) {
+  static bool
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, bool* /*type*/) {
+    return value.asBool();
+  }
+
+  static int castValue(const folly::dynamic& dynamic, int* /*type*/) {
     return static_cast<int>(dynamic.asInt());
   }
 
-  static int64_t castValue(const folly::dynamic& dynamic, int64_t* type) {
+  static int
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, int* /*type*/) {
+    double number = value.asNumber();
+    return static_cast<int>(number);
+  }
+
+  static int64_t castValue(const folly::dynamic& dynamic, int64_t* /*type*/) {
     return dynamic.asInt();
   }
 
-  static float castValue(const folly::dynamic& dynamic, float* type) {
+  static int64_t
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, int64_t* /*type*/) {
+    double number = value.asNumber();
+    return static_cast<int64_t>(number);
+  }
+
+  static float castValue(const folly::dynamic& dynamic, float* /*type*/) {
     return static_cast<float>(dynamic.asDouble());
   }
 
-  static double castValue(const folly::dynamic& dynamic, double* type) {
+  static float
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, float* /*type*/) {
+    double number = value.asNumber();
+    return static_cast<float>(number);
+  }
+
+  static double castValue(const folly::dynamic& dynamic, double* /*type*/) {
     return dynamic.asDouble();
   }
 
+  static double
+  castValue(jsi::Runtime* runtime, const jsi::Value& value, double* /*type*/) {
+    return value.asNumber();
+  }
+
   static std::string castValue(
       const folly::dynamic& dynamic,
-      std::string* type) {
+      std::string* /*type*/) {
     return dynamic.getString();
   }
 
+  static std::string castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::string* /*type*/) {
+    jsi::String stringValue = value.asString(*runtime);
+    return stringValue.utf8(*runtime);
+  }
+
+  static JsiValueReturnType castValue(
+      const folly::dynamic& dynamic,
+      JsiValueReturnType* /*type*/) {
+    react_native_assert(false);
+    throw new std::runtime_error(
+        "Cannot cast dynamic to a jsi::Value type. Please use the 'useRawPropsJsiValue' feature flag to enable jsi::Value support for RawValues.");
+  }
+
+  static JsiValueReturnType castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      JsiValueReturnType* /*type*/) {
+    return JsiValueReturnType(runtime, value);
+  }
+
   template <typename T>
   static std::vector<T> castValue(
       const folly::dynamic& dynamic,
-      std::vector<T>* type) {
+      std::vector<T>* /*type*/) {
     react_native_assert(dynamic.isArray());
     auto result = std::vector<T>{};
     result.reserve(dynamic.size());
@@ -250,10 +465,30 @@ class RawValue {
     return result;
   }
 
+  template <typename T>
+  static std::vector<T> castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::vector<T>* /*type*/) {
+    react_native_assert(value.isObject());
+    jsi::Object object = value.getObject(*runtime);
+    react_native_assert(object.isArray(*runtime));
+    jsi::Array array = object.getArray(*runtime);
+    size_t size = array.size(*runtime);
+    std::vector<T> result;
+    result.reserve(size);
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value itemValue = array.getValueAtIndex(*runtime, i);
+      T item = castValue(runtime, itemValue, (T*)nullptr);
+      result.push_back(std::move(item));
+    }
+    return result;
+  }
+
   template <typename T>
   static std::vector<std::vector<T>> castValue(
       const folly::dynamic& dynamic,
-      std::vector<std::vector<T>>* type) {
+      std::vector<std::vector<T>>* /*type*/) {
     react_native_assert(dynamic.isArray());
     auto result = std::vector<std::vector<T>>{};
     result.reserve(dynamic.size());
@@ -263,10 +498,31 @@ class RawValue {
     return result;
   }
 
+  template <typename T>
+  static std::vector<std::vector<T>> castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::vector<std::vector<T>>* /*type*/) {
+    react_native_assert(value.isObject());
+    jsi::Object object = value.getObject(*runtime);
+    react_native_assert(object.isArray(*runtime));
+    jsi::Array array = object.getArray(*runtime);
+    size_t size = array.size(*runtime);
+    std::vector<std::vector<T>> result;
+    result.reserve(size);
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value itemValue = array.getValueAtIndex(*runtime, i);
+      std::vector<T> item =
+          castValue(itemValue, runtime, (std::vector<T>*)nullptr);
+      result.push_back(std::move(item));
+    }
+    return result;
+  }
+
   template <typename T>
   static std::unordered_map<std::string, T> castValue(
       const folly::dynamic& dynamic,
-      std::unordered_map<std::string, T>* type) {
+      std::unordered_map<std::string, T>* /*type*/) {
     react_native_assert(dynamic.isObject());
     auto result = std::unordered_map<std::string, T>{};
     for (const auto& item : dynamic.items()) {
@@ -275,6 +531,33 @@ class RawValue {
     }
     return result;
   }
+
+  template <typename T>
+  static std::unordered_map<std::string, T> castValue(
+      jsi::Runtime* runtime,
+      const jsi::Value& value,
+      std::unordered_map<std::string, T>* /*type*/) {
+    react_native_assert(value.isObject());
+    jsi::Object object = value.getObject(*runtime);
+    jsi::Array propertyNames = object.getPropertyNames(*runtime);
+    size_t size = propertyNames.size(*runtime);
+    std::unordered_map<std::string, T> result;
+    for (size_t i = 0; i < size; i++) {
+      jsi::Value propertyNameValue = propertyNames.getValueAtIndex(*runtime, i);
+      jsi::String propertyName = propertyNameValue.getString(*runtime);
+      jsi::Value propertyValue = object.getProperty(*runtime, propertyName);
+      if (propertyValue.isUndefined()) {
+        // Skip undefined values to mimic JSIDynamic::dynamicFromValue behavior.
+        // Null values are allowed in the map.
+        continue;
+      }
+
+      std::string propertyNameString = propertyName.utf8(*runtime);
+      T property = castValue(runtime, propertyValue, (T*)nullptr);
+      result.emplace(propertyNameString, std::move(property));
+    }
+    return result;
+  }
 };
 
 } // namespace facebook::react
