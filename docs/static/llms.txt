# Nitro Modules

> A framework to build mindblowingly fast native modules with type-safe statically compiled JS bindings.

This file contains all documentation content in a single document following the llmstxt.org standard.

## Comparison with other frameworks

# Comparison with other frameworks

Nitro is not the only one of it's kind. There's multiple ways to build native modules for React Native:

- Nitro Modules
- [Turbo Modules](#turbo-modules)
- [Legacy Native Modules](#legacy-native-modules)
- [Expo Modules](#expo-modules)

## Benchmarks

[This benchmark](https://github.com/mrousavy/NitroBenchmarks) compares the total execution time when calling a single native method 100.000 times:

  
    
    ExpoModules
    TurboModules
    NitroModules
  
  
    100.000x addNumbers(...)
    434.85ms
    115.86ms
    7.27ms
  
  
    100.000x addStrings(...)
    429.53ms
    179.02ms
    29.94ms
  

Note: These benchmarks only compare native method throughput in extreme cases, and do not necessarily reflect real world use-cases. In a real-world app, results may vary. See [NitroBenchmarks](https://github.com/mrousavy/NitroBenchmarks) for full context.

It's not all about performance though - there are some key differences between Nitro-, Turbo- and Expo-Modules:

## Turbo Modules

[Turbo Modules](https://github.com/reactwg/react-native-new-architecture/blob/main/docs/turbo-modules.md) are React Native's default framework for building native modules.
They use a code-generator called "[codegen](https://github.com/reactwg/react-native-new-architecture/blob/main/docs/codegen.md)" to convert Flow (or TypeScript) specs to native interfaces, similar to Nitro's nitrogen.

```swift title="Nitro Module (Swift)"
class HybridMath : HybridMathSpec {
  func add(a: Double, b: Double) -> Double {
    return a + b
  }
}
```

```objc title="Turbo Module (Objective-C)"
@implementation RTNMath
RCT_EXPORT_MODULE()

- (NSNumber*)add:(NSNumber*)a b:(NSNumber*)b {
  double added = a.doubleValue + b.doubleValue;
  return [NSNumber numberWithDouble:added];
}
@end
```

Turbo Modules can be built with Objective-C for iOS and Java for Android, or C++ for cross-platform.

### Shipped with react-native core

Unlike Nitro, Turbo Modules are actually part of react-native core. This means, users don't have to install a single dependency to build- or use a Turbo Module.

### Implementation details

#### No Swift

There is no direct Swift support for Turbo Modules. You could bridge from Objective-C to Swift, but that would still always go through Objective-C, which is comparatively slower than bridging directly from C++ to Swift, like Nitro does.

```mermaid
---
title: "Nitro Modules"
---
graph LR;
    JS--> C++ --> Swift;
```

```mermaid
---
title: "Turbo Modules"
---
graph LR;
    JS--> C++ --> Objective-C --> Swift;
```

#### No properties

A Turbo Module does not provide a syntax for properties. Instead, conventional getter/setter methods have to be used.

```swift title="Nitro Module (Swift)"
class HybridMath : HybridMathSpec {
  var someValue: Double
}
```

```objc title="Turbo Module (Objective-C)"
@implementation RTNMath {
  NSNumber* _someValue;
}
RCT_EXPORT_MODULE()

- (NSNumber*)getSomeValue {
  return _someValue;
}
- (void)setSomeValue:(NSNumber*)someValue {
  _someValue = someValue;
}
@end
```

#### Not object-oriented

While a Turbo Module can represent many types from JavaScript, there is no equivalent to Nitro's **Hybrid Object** in Turbo Modules. Instead, every Turbo Module is a singleton, and every native method is similar to a static method.

Native objects, like Image instances, can not be represented in Turbo Modules. Common workarounds include writing the image to a file, converting images to base64 strings, or using Blobs - which all introduce runtime overhead and performance hits _just to pass an image instance to JS_.

```swift title="HybridImageEditor.swift"
class HybridImageEditor: HybridImageEditorSpec {
  func crop(image: HybridImage,
            size: Size) -> HybridImage {
    let original = image.cgImage
    let cropped = original.cropping(to: size)
    return HybridImage(cgImage: cropped)
  }
}
```

```objc title="ImageEditor.mm"
@implementation ImageEditor
- (NSString*)crop:(NSString*)imageUri
             size:(CGRect)size {
  UIImage* image = [UIImage imageWithContentsOfFile:imageUri];
  CGImageRef cropped = CGImageCreateWithImageInRect([image CGImage], size);
  UIImage* croppedImage = [UIImage imageWithCGImage:cropped];
  CGImageRelease(cropped);

  NSString* fileName = [NSString stringWithFormat:@"%@.png", [[NSUUID UUID] UUIDString]];
  NSString* filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:fileName];
  NSData* pngData = UIImagePNGRepresentation(croppedImage);
  [pngData writeToFile:tempPath atomically:YES];
  return tempPath;
}
@end
```

Using native objects (like the `HybridImage`) directly is much more efficient and performant, as well as more convenient to use than to write everything to a file.

#### No tuples

There are no tuples in Turbo Modules.

```ts
type SomeTuple = [number, number]
```

#### No callbacks with return values

Turbo Modules do not allow JS callbacks to return a value.

```ts
type SomeCallback = () => number
```

#### Events

Since functions are not first-class citizens in Turbo Modules, you cannot hold onto a JavaScript callback in native code and call it more often, like you could in Nitro.
Instead, Turbo Modules has "Events". Events are essentially just native functions that notify JS and potentially also pass data to JS more often.

```swift title="HybridMath.swift (Nitro)"
class Math: MathSpec {
  var listeners: [(String) -> Void] = []
  func addListener(listener: (String) -> Void) {
    listeners.add(listener)
  }

  func onSomethingChanged() {
    for listener in listeners {
      listener("something changed!")
    }
  }
}
```

```objc title="RTNMath.mm (Turbo)"
@implementation RTNMath
RCT_EXPORT_MODULE();

- (NSArray *)supportedEvents {
  return @[@"onSomethingChanged"];
}

- (void)onSomethingChanged {
  NSString* message = @"something changed!";
  [self sendEventWithName:@"onSomethingChanged"
                     body:@{@"msg": message}];
}
@end
```

Events are untyped and have to be natively defined via `supportedEvents`. In Nitro, this would be fully typesafe as functions are first class citizens. (see `addListener(..)`)

#### HostObject vs NativeState

As of today, Turbo Modules are implemented using `jsi::HostObject`, whereas Nitro Modules are built with `jsi::NativeState`.
NativeState has been proven to be much more efficient and performant, as property- and method-access is much faster - it can be properly cached by the JS Runtime and does not involve any virtual/Proxy-like accessors.

Additionally, Nitro Modules properly set up memory pressure per object, so the JS garbage collector actually knows a native module's memory size and can properly delete them when no longer needed. This is not the case with Turbo Modules.

### Codegen

Codegen is similar to Nitrogen as it also generates native interfaces from TypeScript specifications. This ensures type-safety on the JavaScript side, as specs have to be implemented on the native side in order for the app to build successfully. This prevents any wrong type errors and ensures undefined/null-safety.

```ts title="Nitrogen"
export interface Math extends HybridObject {
  add(a: number, b: number): Promise
}

export const Math =
  NitroModules.createHybridObject("Math")
```

```ts title="Codegen"
export interface Spec extends TurboModule {
  add(a: number, b: number): Promise;
}

export const Math =
  TurboModuleRegistry.get("RTNMath")
    as Spec | null;
```

#### Codegen runs on app build

Nitrogen is executed explicitly by the library developer and all generated interfaces are part of the npm package to always ship a working solution.
Codegen on the other hand runs on app build, which causes specs to always be re-generated for every app.

#### Codegen cannot resolve imports

While Nitrogen can properly resolve imports from other files, Codegen can not.

#### Codegen supports Flow

Codegen also supports [Flow](https://flow.org), while Nitrogen doesn't.

## Legacy Native Modules

Prior to [Turbo Modules](#turbo-modules), React Native provided a default approach for building native modules which was just called ["Native Modules"](https://reactnative.dev/docs/native-modules-intro).
Instead of using JSI, Native Modules were built on top of a communication layer that sent events and commands using JSON messages, both asynchronous and batched.

Because Turbo Modules are just an evolution of Native Modules, their API is almost identical:

```swift title="Nitro Module (Swift)"
class HybridMath : HybridMathSpec {
  func add(a: Double, b: Double) -> Double {
    return a + b
  }
}
```

```objc title="Native Module (Objective-C)"
@implementation RTNMath
RCT_EXPORT_MODULE()

- (NSNumber*)add:(NSNumber*)a b:(NSNumber*)b {
  double added = a.doubleValue + b.doubleValue;
  return [NSNumber numberWithDouble:added];
}
@end
```

They are now deprecated in favor of [Turbo Modules](#turbo-modules).

## Expo Modules

[Expo Modules](https://docs.expo.dev/modules/overview/) is an easy to use API to build native modules by Expo.

Unlike both Nitro- and Turbo-, Expo-Modules does not have a code-generator.
All native modules are considered untyped, and TypeScript definitions can be written afterwards.

An Expo Module can be written using a declarative syntax (_DSL_) where each function and property is declared inside the `definition()` function:

```swift title="Nitro Module (Swift)"
class HybridMath : HybridMathSpec {
  func add(a: Double, b: Double) -> Double {
    return a + b
  }
}
```

```swift title="Expo Module (Swift)"
public class MathModule: Module {
  public func definition() -> ModuleDefinition {
    Name("Math")

    Function("add") { (a: Double,
                       b: Double) -> Double in
      return a + b
    }
  }
}
```

### Implementation details

#### Swift support

Just like Nitro, Expo Modules are written in Swift, instead of Objective-C.

Expo Modules however bridge through Objective-C, whereas Nitro bridges to Swift directly (using the new Swift &lt;&gt; C++ interop) which has proven to be much more efficient.

```mermaid
---
title: "Nitro Modules"
---
graph LR;
    JS--> C++ --> Swift;
```

```mermaid
---
title: "Expo Modules"
---
graph LR;
    JS--> C++ --> Objective-C --> Swift;
```

#### Kotlin coroutines

Asynchronous functions can be implemented using Kotlin coroutines, which is a convenient pattern for asynchronous code. This is similar to Nitro's `Promise.async` function.

```kotlin title="HybridMath.kt (Nitro)"
class HybridMath: HybridMathSpec {
  override fun doSomeWork(): Promise {
    return Promise.async {
      delay(5000)
      return@async "done!"
    }
  }
}
```

```kotlin title="Math.kt (Expo)"
class MathModule: Module {
  override fun definition() = ModuleDefinition {
    Name("Math")

    AsyncFunction("doSomeWork") Coroutine {
      delay(5000)
      return@Coroutine "done!"
    }
  }
}
```

#### Properties

Expo Modules supports getting and setting properties, just like Nitro.

#### Events

Similar to Turbo Modules, Expo Modules also uses Events to notify JS about any changes on the native side.

```swift title="HybridMath.swift (Nitro)"
class Math: MathSpec {
  var listeners: [(String) -> Void] = []
  func addListener(listener: (String) -> Void) {
    listeners.add(listener)
  }

  func onSomethingChanged() {
    for listener in listeners {
      listener("something changed!")
    }
  }
}
```

```swift title="MathModule.swift (Expo)"
let SOMETHING_CHANGED = "onSomethingChanged"
public class MathModule: Module {
  public func definition() -> ModuleDefinition {
    Name("Math")
    Events(SOMETHING_CHANGED)
  }

  private func onSomethingChanged() {
    sendEvent(SOMETHING_CHANGED, [
      "message": "something changed!"
    ])
  }
}
```

#### HostObject vs NativeState

As of today, Expo Modules are implemented using `jsi::HostObject`, whereas Nitro Modules are built with `jsi::NativeState`.
NativeState has been proven to be much more efficient and performant, as property- and method-access is much faster - it can be properly cached by the JS Runtime and does not involve any virtual/Proxy-like accessors.

Expo-Modules do however properly set memory pressure of native objects, just like in Nitro.

#### Shared Objects

Expo Modules has a concept of "shared objects", which is similar to Hybrid Objects in Nitro.

:::note
I could not find any documentation for Shared Objects, so I cannot really compare them here.
:::

#### No tuples

There are no tuples in Expo Modules.

```ts
type SomeTuple = [number, number]
```

#### No callbacks with return values

Expo-Modules does not allow JS callbacks to return a value.

```ts
type SomeCallback = () => number
```

### No code-generator

Since Expo Modules does not provide a code-generator, all native modules are untyped by default.
While TypeScript definitions can be written afterwards, it is possible that the handwritten TypeScript definitions are out of sync with the actual native types due to a user-error, especially when it comes to null-safety.

```ts title="Math.ts (Expo JS side)"
interface Math {
  add(a: number, b: number | undefined): number
//  b can be undefined here: ^
}

const math = ...
math.add(5, undefined)
// code-error
//          ^ will throw at runtime!
```

```swift title="HybridMath.swift (Expo Native side)"
public class MathModule: Module {
  public func definition() -> ModuleDefinition {
    Name("Math")

    Function("add") { (a: Double,
                       b: Double) -> Double in
// b CANNOT be undefined here: ^
      return a + b
    }
  }
}
```

Note: It is also possible for Nitro specs to go out of sync, but only if you forget to run Nitrogen. In both cases, it's a user-error - one more likely than the other.

## Supported Types

  
    JS Type
    Expo Modules
    Turbo Modules
    Nitro Modules
  
  
    number
    âœ…
    âœ…
    âœ…
  
  
    boolean
    âœ…
    âœ…
    âœ…
  
  
    string
    âœ…
    âœ…
    âœ…
  
  
    bigint
    âœ…
    âŒ
    âœ…
  
  
    object
    âœ…
    âœ…
    âœ…
  
  
    T?
    âœ…
    âœ…
    âœ…
  
  
    T[]
    âœ…
    âœ…
    âœ…
  
  
    Promise&lt;T&gt;
    âœ…
    âœ…
    âœ…
  
  
    (T...) =&gt; void
    âœ…
    âœ…
    âœ…
  
  
    (T...) =&gt; R
    âŒ
    âŒ
    âœ…
  
  
    [A, B, C, ...]
    âŒ
    âŒ
    âœ…
  
  
    A | B | C | ...
    âœ…
    âŒ
    âœ…
  
  
    Record&lt;string, T&gt;
    âŒ (no codegen)
    âŒ
    âœ…
  
  
    ArrayBuffer
    âœ…
    âŒ
    âœ…
  
  
    ..any HybridObject
    âœ…
    âŒ
    âœ…
  
  
    ..any interface
    âŒ (no codegen)
    âœ…
    âœ…
  
  
    ..any enum
    âŒ (no codegen)
    âœ…
    âœ…
  
  
    ..any union
    âŒ (no codegen)
    âŒ
    âœ…
  

## Correctness of this page

Note: If anything is missing, wrong, or outdated, please let me know so I can correct it immediately!

---

## Configuration (`nitro.json`)

# Configuration (`nitro.json`)

[Nitrogen](nitrogen) requires a `nitro.json` file to be configured at the root of each [Nitro Module](nitro-modules).

```json
{
  "$schema": "https://nitro.margelo.com/nitro.schema.json",
  "cxxNamespace": ["$$cxxNamespace$$"],
  "ios": {
    "iosModuleName": "$$iosModuleName$$"
  },
  "android": {
    "androidNamespace": ["$$androidNamespace$$"],
    "androidCxxLibName": "$$androidCxxLibName$$"
  },
  "autolinking": {},
  "ignorePaths": ["**/node_modules"],
  "gitAttributesGeneratedFlag": true
}
```

Nitrogen parses this file with Zod, see [`NitroUserConfig.ts`](https://github.com/mrousavy/nitro/blob/main/packages/nitrogen/src/config/NitroUserConfig.ts) for more information.

## `cxxNamespace`

The `cxxNamespace` is the C++ namespace that all C++ specs will be generated in. It is always relative to `margelo::nitro`, and can also have multiple sub-namespaces:

  
  ```json
  {
    "cxxNamespace": ["math", "extra"]
  }
  ```
  
  
  ```cpp
  namespace margelo::nitro::math::extra {
    // ...generated classes
  }
  ```
  

## `ios`

Settings specifically for the iOS platform.

### `iosModuleName`

The `iosModuleName` represents the name of the [clang module](https://clang.llvm.org/docs/Modules.html) that will be emitted by the Swift compiler.
When this Nitro Module is a CocoaPod, this is the same thing as the `$$iosModuleName$$.podspec`'s name:

  
  ```json
  {
    "ios": {
      "iosModuleName": "NitroMath"
    }
  }
  ```
  
  
  ```ruby title="NitroMath.podspec"
  Pod::Spec.new do |s|
    s.name         = "NitroMath"
    # ...
  ```
  

## `android`

Settings specifically for the Android platform.

### `androidNamespace`

The `androidNamespace` represents the package namespace in which all Java/Kotlin files are generated and written in.
Similar to the `cxxNamespace`, this is always relative to `margelo.nitro`, and can also have multiple sub-namespaces.

In most cases, you should keep this in sync with the `namespace` specified in your `build.gradle`.

  
  ```json
  {
    "android": {
      "androidNamespace": ["math", "extra"]
    }
  }
  ```
  
  
  ```kotlin
  package com.margelo.nitro.test

  // ...
  ```
  

### `androidCxxLibName`

The `androidCxxLibName` represents the name of the native C++ library that JNI will load to connect Java/Kotlin to C++.

When this Nitro Module is using CMake, this is the same thing as the library defined in `CMakeLists.txt`.
Nitro will load this library at runtime using `System.loadLibrary`.

  
  ```json
  {
    "android": {
      "androidCxxLibName": "NitroMath"
    }
  }
  ```
  
  
  ```cmake
  project(NitroMath)
  add_library(NitroMath SHARED
          src/main/cpp/cpp-adapter.cpp
          ../cpp/HybridMath.cpp
  )
  ```
  

## `autolinking`

Contains configuration for all [Hybrid Objects](hybrid-objects) that should be autolinked by Nitrogen.

All Hybrid Objects specified here must follow these requirements:

- They must be default-constructible. That means they need a public constructor that takes zero arguments.
If you have a Hybrid Object that is not default-constructible (e.g. `Image` needs a `path` or `url` argument), consider creating a factory Hybrid Object that can initialize instances of your Hybrid Object internally.
- C++ Hybrid Objects must be declared in a file that has the same name as the Hybrid Object (for `HybridMath`, create `HybridMath.hpp`).
- C++ Hybrid Objects must be scoped in the namespace specified in [`cxxNamespace`](#cxxnamespace).
- Kotlin Hybrid Objects must be inside the package namespace specified in [`androidNamespace`](#androidnamespace).
- Kotlin Hybrid Objects should be annotated with `@DoNotStrip` to prevent them from being compiled out when using ProGuard.

Nitrogen will then generate the following code:

  
  ```json
  {
    "autolinking": {
      "Math": {
        "cpp": "HybridMath"
      }
    }
  }
  ```
  
  
  ```cpp
  HybridObjectRegistry::registerHybridObjectConstructor(
    "Math",
    []() -> std::shared_ptr {
      return std::make_shared();
    }
  );
  ```
  

Here, the Hybrid Object "`Math`" is autolinked to create an instance of `HybridMath`, a C++ class. Instead of `cpp`, you can also use `swift` or `kotlin`.

## `ignorePaths`

Configures the TypeScript parser to ignore specific given paths when looking for `*.nitro.ts` specs.

By default, this is empty (`[]`), but it can be set to ignore paths like `["node_modules", "lib"]`.

## `gitAttributesGeneratedFlag`

Configures whether all nitro-generated files are marked as [`linguist-generated`](https://docs.github.com/en/repositories/working-with-files/managing-files/customizing-how-changed-files-appear-on-github) for GitHub. This disables diffing for generated content and excludes them from language statistics.
This is controlled via `nitrogen/generated/.gitattributes`.

---

## Contributing

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Contributing

If you encounter issues with Nitro, want to fix a bug, or reproduce a bug in the example app, you'd need to clone the repo and get it running first.

The nitro repo is a Bun monorepo, and is set up like this:

- `example/`: A react-native app that uses `react-native-nitro-modules` and `react-native-nitro-test`.
- `packages/`
  - `/nitrogen/`: The Node app that generates Nitro bindings. On npm, it is called `nitro-codegen`.
  - `/react-native-nitro-modules/`: The core Nitro Modules library which contains mostly C++ code.
  - `/react-native-nitro-test/`: An example Nitro Module library that contains a lot of test code.
  - `/template/`: A template for a Nitro Module library.

## Run Nitro Example

### 1. Set up your development environment

You need:

- [Bun](https://bun.sh)
- [CocoaPods](https://cocoapods.org)
- Xcode 16 or higher
- Android Studio

### 2. Clone the repo

Clone [mrousavy/**nitro**](https://github.com/mrousavy/nitro) using git, and navigate into the `nitro` folder using Terminal.

### 3. Install dependencies

Using Bun, install all required dependencies:

```sh
bun install
bun run build
```

#### 3.1. (Optional) Install iOS dependencies

If you want to work on the iOS codebase, you also need to install the Pods:

```sh
cd example
bundle install
bun pods
```

### 4. Run the app

After installing all dependencies, you can run the React Native app in `example/`:

  
    1. Open `example/ios/NitroExample.xcworkspace` in Xcode
    2. Select your target (iPhone Simulator)
    3. Click Run
  
  
    1. Open `example/android` in Android Studio
    2. Click Gradle Sync
    3. Click Run
  

## Reproduce something in the Nitro Example app

With most issue reports, it is required to reproduce the issue in the Nitro example app (`example/`).
Whether it's a build error, a nitrogen error, or a runtime error, there needs to be a way to reproduce it here.
Usually, you can reproduce issues like this:

1. Fork the repository
2. Change the code to reproduce the issue
3. Create a PR to the **nitro** repository which demonstrates the issue

### Reproduce a build error

If you encounter a build error, compare your setup to the setup in `example/`.
For example, if you have a different setting in your `Podfile`, try changing it here in Nitro `example/` as well to see if it builds here. Submit a PR with the change required to make it fail, and see if the CI fails to build.

### Reproduce a nitrogen bug

The Nitro `example/` app uses a Nitro Module (`packages/react-native-nitro-test/`) which acts as an example contains a lot of test code, like `src/specs/TestObject.nitro.ts` ([link](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-test/src/specs/TestObject.nitro.ts)). If you change something in `TestObject.nitro.ts`, make sure to run nitrogen:

```sh
bun nitro-test specs
```

### Reproduce a runtime error

Submit a PR to the nitro repository that demonstrates this runtime error or crash in the Nitro `example/` app.

## Run Nitro Docs

The Nitro docs ([nitro.margelo.com](https://nitro.margelo.com)) are built with [Docusaurus](https://docusaurus.io).

To run the Nitro docs, follow these steps:

### 1. Install dependencies

Navigate into the `docs/` folder, and install all dependencies:

```sh
cd docs
bun install
```

### 2. Run docs (dev)

Then, just run the docs development server using the docusaurus command:

```sh
bun start
```

## Linting

We value code quality and consistent styling.

For JS/TS, we use ESLint and Prettier:

```sh
bun lint
```

For C++, we use clang-format:

```sh
bun lint-cpp
```

Make sure to lint your files everytime before creating a PR. This is also enforced in the CI, but linting beforehand also applies auto-fixes.

---

## Entry Point

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Entry Point

Nitro is built on top of JSI - while the primary target is React Native, Nitro even works on any other target that provides JSI.

## React Native's Entry Point

In React Native apps, Nitro makes use of the [autolinking functionality](https://github.com/react-native-community/cli/blob/main/docs/autolinking.md) provided by RN CLI.

Nitro itself is a react-native library - either a Native Module (old arch) or a Turbo Module (new arch) - with a single native method: `install()`.
This native method will be called from JS when importing `react-native-nitro-modules`, so it will always happen before trying to use the `NitroModules` JS object.

## Manually registering Nitro

If you are not within a typical React Native environment (e.g. a brownfield app, an out-of-tree platform, or simply a pure JSI environment), you can also use Nitro Modules by just installing Nitro manually.

After creating your `jsi::Runtime` and an instance of `Dispatcher`, simply call `margelo::nitro::install()`:

```cpp
#include 
#include 
#include 

jsi::Runtime& runtime = ...
std::shared_ptr dispatcher = ...
margelo::nitro::install(runtime, dispatcher);
```

Your `Dispatcher` implementation must properly implement `runAsync` and `runSync` to schedule calls on a Thread that can safely access the `jsi::Runtime`.

:::tip
If your Runtime can be accessed from any Thread, you can also skip Thread-hops here and just call the functions directly in your Dispatcher.
:::

### No Dispatcher

Nitro can also be installed without a `Dispatcher`:

```cpp
#include 
#include 

jsi::Runtime& runtime = ...
margelo::nitro::install(runtime);
```

In this case, all synchronous methods and properties remain in-tact, but any asynchronous hybrid methods (`Promise`) or callbacks will throw an error that Nitro does not have a `Dispatcher` to get back to the JS Thread.

---

## Errors

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Errors

Every method in a [Hybrid Object](hybrid-objects) can throw an error using the language-default error throwing feature:

  
    ```swift title="HybridMath.swift"
    class HybridMath : HybridMathSpec {
      public func add(a: Double, b: Double) throws -> Double {
        if a 
  
    ```kotlin title="HybridMath.kt"
    class HybridMath : HybridMathSpec() {
      override fun add(a: Double, b: Double): Double {
        if (a 
  
    ```cpp title="HybridMath.hpp"
    class HybridMath: public HybridMathSpec {
      double add(double a, double b) override {
        if (a 

Errors will be propagated upwards to JS and can be caught just like any other kind of error using `try`/`catch`:

```diff
// code-error
`Math.add(...)`: Value cannot be negative!
```

### Promise rejections

Promises can also be rejected using error throwing syntax on the native side:

  
    ```swift title="HybridMath.swift"
    class HybridMath : HybridMathSpec {
      public func add(a: Double, b: Double) throws -> Promise {
        return Promise.async {
          if a 
  
    ```kotlin title="HybridMath.kt"
    class HybridMath : HybridMathSpec() {
      override fun add(a: Double, b: Double): Promise {
        return Promise.async {
          if (a 
  
    ```cpp title="HybridMath.hpp"
    class HybridMath: public HybridMathSpec {
      std::shared_ptr> add(double a, double b) override {
        return Promise::async([=]() -> double {
          if (a 

Promise rejections are handled as usual using the `.catch`, or `await`/`catch` syntax in JS:

```ts
const math = // ...
try {
  await math.add(-5, -1)
} catch (error) {
  console.log(error)
}
```

---

## For library users

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# For library users

If you are using a library that is built with Nitro, all you need to do is install the Nitro Modules core package:

  
    ```sh
    npm i react-native-nitro-modules
    cd ios && pod install
    ```
  
  
    ```sh
    yarn add react-native-nitro-modules
    cd ios && pod install
    ```
  
  
    ```sh
    pnpm add react-native-nitro-modules
    cd ios && pod install
    ```
  
  
    ```sh
    bun i react-native-nitro-modules
    cd ios && pod install
    ```
  

Nitro Modules are lightweight, yet powerful native bindings to native code, so thank the library author for choosing Nitro to make your app faster! ðŸ˜„

---

## Hybrid Objects

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Hybrid Objects

A **Hybrid Object** is a native object that can be used from JS like any other object.
They can have natively implemented methods, as well as properties (get + set).

```ts title="Math.nitro.ts"
interface Math extends HybridObject {
  readonly pi: number
  add(a: number, b: number): number
}
```

```swift title="HybridMath.swift"
class HybridMath : HybridMathSpec {
  var pi: Double {
    return Double.pi
  }
  func add(a: Double, b: Double) -> Double {
    return a + b
  }
}
```

## Working with Hybrid Objects

If a Hybrid Object is _autolinked_ (see ["**Nitrogen**: 5. Register the Hybrid Objects"](nitrogen#5-register-the-hybrid-objects)), it can be created from JS via `createHybridObject(..)`:

```ts
const math = NitroModules.createHybridObject("Math")
const result = math.add(5, 7)
```

To enable the usage of `new` and `instanceof`, you can use the `getHybridObjectConstructor(..)` helper method:

```ts
const HybridMath = getHybridObjectConstructor("Math")
const math = new HybridMath()
const isMath = math instanceof HybridMath
```

A Hybrid Object can also create other Hybrid Objects:

```ts title="Image.nitro.ts"
interface Image extends HybridObject {
  readonly width: number
  readonly height: number
  saveToFile(path: string): Promise
}

interface ImageFactory extends HybridObject {
  loadImageFromWeb(path: string): Promise
  loadImageFromFile(path: string): Image
  loadImageFromResources(name: string): Image
}
```

## Base Methods

Every Hybrid Object has base methods and properties, like `name`, `toString()` and `equals(..)`:

```ts
const math = NitroModules.createHybridObject("Math")
const anotherMath = math

console.log(math.name) // "Math"
console.log(math.toString()) // "[HybridObject Math]"
console.log(math.equals(anotherMath)) // true
```

### `dispose()`

Additionally, every Hybrid Object has a `dispose()` method.
Usually, you should not need to manually dispose Hybrid Objects as the JS garbage collector will delete any unused objects anyways.
Also, most Hybrid Objects in Nitro are just statically exported singletons, in which case they should never be deleted throughout the app's lifetime.

In some rare, often performance-critical- cases it is beneficial to eagerly destroy any Hybrid Objects, which is why `dispose()` exists.
For example, [VisionCamera](https://github.com/mrousavy/react-native-vision-camera) uses `dispose()` to clean up already processed Frames to make room for new incoming Frames:

```ts
const onFrameListener = (frame: Frame) => {
  doSomeProcessing(frame)
  frame.dispose()
}
```

## Implementation

Hybrid Objects can be implemented in C++, Swift or Kotlin:

  

  Nitrogen will âœ¨ automagically âœ¨ generate native specifications for each Hybrid Object based on a given TypeScript definition:

  ```ts title="Math.nitro.ts"
  interface Math extends HybridObject {
    readonly pi: number
    add(a: number, b: number): number
  }
  ```

  Running [nitrogen](nitrogen) will generate the native Swift and Kotlin protocol "`HybridMathSpec`", that now just needs to be implemented in a class:

  
    
      ```swift title="HybridMath.swift"
      class HybridMath : HybridMathSpec {
        public var pi: Double {
          return Double.pi
        }
        public func add(a: Double, b: Double) throws -> Double {
          return a + b
        }
      }
      ```
    
    
      ```kotlin title="HybridMath.kt"
      class HybridMath : HybridMathSpec() {
        override var pi: Double
          get() = Double.PI

        override fun add(a: Double, b: Double): Double {
          return a + b
        }
      }
      ```
    
  

  For more information, see the [Nitrogen documentation](nitrogen).

  
  

  To implement a Hybrid Object without nitrogen, you just need to create a C++ class that inherits from the [`HybridObject`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/cpp/core/HybridObject.hpp) base class, and override `loadHybridMethods()`:

  
    
      ```cpp title="HybridMath.hpp"
      class HybridMath: public HybridObject {
      public:
        HybridMath(): HybridObject(NAME) { }

      public:
        double add(double a, double b);

      protected:
        void loadHybridMethods() override;

      private:
        static constexpr auto NAME = "Math";
      };
      ```
    
    
      ```cpp title="HybridMath.cpp"
      double HybridMath::add(double a, double b) {
        return a + b;
      }

      void HybridMath::loadHybridMethods() {
        // register base methods (toString, ...)
        HybridObject::loadHybridMethods();
        // register custom methods (add)
        registerHybrids(this, [](Prototype& proto) {
          proto.registerHybridMethod(
            "add",
            &HybridMath::add
          );
        });
      }
      ```
    
  

  A Hybrid Object should also override `getExternalMemorySize()` to properly reflect native memory size:

  ```cpp
  class HybridMath: public HybridObject {
  public:
    // ...
    size_t getExternalMemorySize() override {
      return sizeOfSomeImageWeAllocated;
    }
  }
  ```

  Optionally, you can also override `toString()` and `dispose()` for custom behaviour.

  

## Inheritance

As the name suggests, Hybrid Objects are object-oriented, meaning they have full support for inheritance and abstraction.
A Hybrid Object can either inherit from other Hybrid Objects, or satisfy a common interface.

  

  ### Inherit from other Hybrid Objects

  Each Hybrid Object has a proper JavaScript prototype chain, created automatically and lazily.
  When a Hybrid Object inherits from another Hybrid Object, it extends the prototype chain:

  
    
    
    ```ts
    interface Media extends HybridObject {
      readonly width: number
      readonly height: number
      saveToFile(): Promise
    }

    type ImageFormat = 'jpg' | 'png'
    interface Image extends HybridObject, Media {
      readonly format: ImageFormat
    }

    const image1 = NitroModules.createHybridObject('Image')
    const image2 = NitroModules.createHybridObject('Image')
    ```
    
    

    
    ```mermaid
    graph TD;
      HybridObject["HybridObject (4 props)"]-->HybridMediaSpec["Media (3 props)"]
      HybridMediaSpec-->HybridImageSpec["Image (1 prop)"]
      HybridImageSpec-->Image1["const image1"]
      HybridImageSpec-->Image2["const image2"]
    ```
    
  

  ### Inherit from a common interface

  With Nitrogen, you can define a common TypeScript interface that multiple Hybrid Objects inherit from.
  This non-HybridObject interface (`Media`) will not be a separate type on the native side, but all Hybrid Objects that extend from it will satisfy the TypeScript type:

  ```ts
  interface Media {
    readonly width: number
    readonly height: number
  }

  interface Image extends HybridObject, Media {}
  interface Video extends HybridObject, Media {}
  ```

  
  

  ### Inherit from other Hybrid Objects

  In C++, inheriting from a Hybrid Object is as simple as extending it, and adding the prototype in `loadHybridMethods()`:

  ```cpp title="HybridMath.hpp"
  class HybridImage: public HybridMedia {
  public:
    // Image specific methods
    ImageFormat getFormat();

    void loadHybridMethods() override {
      // register base prototype
      HybridMedia::loadHybridMethods();
      // register all methods we add here
      registerHybrids(this, [](Prototype& prototype) {
        prototype.registerHybridGetter("format", &HybridImage::getFormat);
      });
    }
  };
  ```

  ### Override base methods/properties

  In a C++ Hybrid Object, you can also override base methods and properties, even with different types:

  ```cpp title="HybridMath.hpp"
  class HybridImage: public HybridMedia {
  public:
    // Image specific methods
    std::string getSize();

    void loadHybridMethods() override {
      // register base protoype
      HybridMedia::loadHybridMethods();
      // HybridMedia already has .width, but it's a number.
      // We override it to be a string in HybridImage.
      registerHybrids(this, [](Prototype& prototype) {
        prototype.registerHybridGetter("width", &HybridImage::getSize);
      });
    }
  }
  ```

  The HybridImage's prototype's prototype (= HybridMedia's prototype) will still contain the original method/property.
  

## Memory Size (`memorySize`)

Since it's implementation is in native code, the JavaScript runtime does not know the actual memory size of a Hybrid Object.
Nitro allows Hybrid Objects to declare their memory size via the `memorySize`/`getExternalMemorySize()` accessors, which can account for any external heap allocations you perform:

```swift
class HybridImage : HybridImageSpec {
  private var cgImage: CGImage
  public var memorySize: Int {
    let imageSize = cgImage.width * cgImage.height * cgImage.bytesPerPixel
    return imageSize
  }
}
```

Any unused `Image` objects can now be deleted sooner by the JS garbage collector, preventing memory pressures or frequent garbage collector calls.

:::tip
It is safe to return `0` here, but recommended to somewhat closely estimate the actual size of native object if possible.
:::

### Raw JSI methods

If for some reason Nitro's typing system is not sufficient in your case, you can also create a raw JSI method using `registerRawHybridMethod(...)` to directly work with the `jsi::Runtime` and `jsi::Value` types:

```cpp title="HybridMath.hpp"
class HybridMath: HybridMathSpec {
public:
  jsi::Value sayHello(jsi::Runtime& runtime,
                      const jsi::Value& thisValue,
                      const jsi::Value* args,
                      size_t count);

  void loadHybridMethods() override {
    // register base protoype
    HybridMathSpec::loadHybridMethods();
    // register all methods we override here
    registerHybrids(this, [](Prototype& prototype) {
      prototype.registerRawHybridMethod("sayHello", 0, &HybridMath::sayHello);
    });
  }
}
```

---

## Hybrid Views

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Hybrid Views

A **Hybrid View** is just a [**Hybrid Object**](hybrid-objects) that can also be rendered.
It has one additional class-member, `view`:

```ts title="Camera.nitro.ts"
export interface CameraProps
       extends HybridViewProps {
  enableFlash: boolean
}
export interface CameraMethods
       extends HybridViewMethods { }

// highlight-next-line
export type CameraView =
  HybridView
```

```swift title="HybridCamera.swift"
class HybridCamera : HybridCameraSpec {
  var enableFlash: Bool = false

  var view: UIView {
    get {
      return CameraPreviewView()
    }
  }
}
```

## Rendering Hybrid Views

Unlike a **Hybrid Object**, **Hybrid Views** should not be created manually. Instead, you should use the `getHostComponent(...)` function to get a renderable version of your Hybrid View:

```ts
export const Camera = getHostComponent(
  'Camera',
  () => CameraViewConfig
)
```

This can then be rendered in React;

```tsx
function App() {
  return 
}
```

Internally, the `` view will create the `HybridCamera` hybrid object - one hybrid object per view.

## Accessing the underlying Hybrid Object

To access the actual underlying object, you can use the `hybridRef`:

```jsx
function App() {
  return (
     {
          console.log(ref.name) // 
  )
}
```

## Full Guides

Check out the [View Components](view-components) section for a full guide on Hybrid Views.

---

## Minimum Requirements

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Minimum Requirements

Nitro is a Framework built on top of newer APIs like `jsi::NativeState`.
To use Nitro, make sure your app meets the minimum requirements:

  
    - react-native 0.75 or higher
    - Xcode 16 or higher
  
  
    - react-native 0.75 or higher
    - `compileSdkVersion` 34 or higher

---

## Nitro Modules

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Nitro Modules

A **Nitro Module** is a library built with Nitro. It may contain one or more [**Hybrid Objects**](hybrid-objects).

## Structure

A Nitro Module contains the usual react-native library structure, with `ios/` and `android/` folders, a `package.json`, and a `*.podspec` file for iOS.
In addition to the base react-native library template, a Nitro Module also contains:

- A TypeScript setup
- A `nitro.json` configuration file

## Creating a Nitro Module

### 1. Initialize the template

To create a new Nitro Module, simply run `nitro-codegen init `:

```sh
npx nitro-codegen@latest init react-native-math
```

### 2. Implement your Hybrid Objects

Once you set up the library, you can start implementing your Hybrid Objects!

  

  With [Nitrogen](nitrogen) you can âœ¨ automagically âœ¨ generate all native interfaces from your TypeScript definitions.
  After implementing the generated specs, register them using the `HybridObjectRegistry`.

  See [Hybrid Objects (Implementation)](hybrid-objects#implementation) for more information.

  
  

  If you don't want to use Nitrogen, simply create your native C++ classes that inherit from `HybridObject`, and register them using the `HybridObjectRegistry`.

  See [Hybrid Objects (Implementation)](hybrid-objects#implementation) for more information.

  

### 3. Set up an example app

After creating a Nitro Module, it's time to set up an example app to test your library!

  
  ```sh
  npx create-expo-app@latest
  ```
  
  
  ```sh
  npx @react-native-community/cli@latest init NitroMathExample
  ```
  

:::tip
The Hybrid Objects from your Nitro Module will be registered in the `HybridObjectRegistry`. This registration process needs to be called from somewhere:
- In React Native, this happens in the `*Package.java` file which calls `.initializeNative()`.
- If you are not using React Native, you need to manually call `.initializeNative()` in your library's entry point.
:::

---

## Nitrogen

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Nitrogen

**Nitrogen** is Nitro's code-generator. It parses TypeScript code using an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) parser to generate native interfaces from TypeScript definitions.

```ts title="Math.nitro.ts"
interface Math extends HybridObject {
  readonly pi: number
  add(a: number, b: number): number
}
```

```swift title="HybridMathSpec.swift (generated)"
protocol HybridMathSpec: HybridObject {
  var pi: Double { get }
  func add(a: Double, b: Double) -> Double
}
```

When `HybridMathSpec` is not implemented properly on the native side (e.g. if `add(..)` is missing, or if a type is incorrect), **the app will not compile**, which ensures full **type-safety** and **null-safety** at compile-time.

## Nitrogen is optional

Nitrogen is a fully optional CLI that does some of the work for you.
You can also build Nitro Modules and create Hybrid Objects without nitrogen, by just calling the `registerHybrids` method yourself.

## Who uses Nitrogen?

Nitrogen should be used by library-authors, and generated specs should be committed to the repository/package.

If you build an app that uses libraries built with Nitro, **you do not need to run nitrogen yourself**.

## Configuration

Nitrogen should be installed as a dev-dependency in the Nitro Module (library).

  
    ```sh
    npm i nitro-codegen --save-dev
    ```
  
  
    ```sh
    yarn add nitro-codegen -D
    ```
  
  
    ```sh
    pnpm add nitro-codegen -D
    ```
  
  
    ```sh
    bun i nitro-codegen -d
    ```
  

:::warning
Nitrogen is currently named `nitro-codegen` instead of `nitrogen` on npm.
:::

Each Nitro Module needs to have a `nitro.json` configuration file.

Create a `nitro.json` file in the root directory of your Nitro Module (next to `package.json`), and add the following content:

```json title="nitro.json"
{
  "$schema": "https://nitro.margelo.com/nitro.schema.json",
  "cxxNamespace": ["math"],
  "ios": {
    "iosModuleName": "NitroMath"
  },
  "android": {
    "androidNamespace": ["math"],
    "androidCxxLibName": "NitroMath"
  },
  "autolinking": {}
}
```

Tweak your module name and namespaces as needed.

## Usage

Nitrogen parses all TypeScript files that end in `.nitro.ts`.

### 1. Write TypeScript specs

For example, let's create `Math.nitro.ts`:

```ts title="Math.nitro.ts"
import { type HybridObject } from 'react-native-nitro-modules'

interface Math extends HybridObject {
  add(a: number, b: number): number
}
```

### 2. Generate native specs

Now run nitrogen:

  
    ```sh
    npx nitro-codegen
    ```
  
  
    ```sh
    yarn nitro-codegen
    ```
  
  
    ```sh
    pnpm nitro-codegen
    ```
  
  
    ```sh
    bun nitro-codegen
    ```
  

:::warning
Nitrogen is currently named `nitro-codegen` instead of `nitrogen` on npm.
:::

This will always generate a shared C++ interface, and then optionall also Swift and Kotlin sub-classes. The specs go into `./nitrogen/generated/`:

```
ðŸ”§  Loading nitro.json config...
ðŸš€  Nitrogen runs at ~/Projects/nitro/example/dummy
    ðŸ”  Nitrogen found 1 spec in ~/Projects/nitro/example/dummy
â³  Parsing Math.nitro.ts...
    âš™ï¸  Generating specs for HybridObject "Math"...
        shared: Generating C++ code...
â›“ï¸   Setting up build configs for autolinking...
ðŸŽ‰  Generated 1/1 HybridObject in 0.6s!
ðŸ’¡  Your code is in ./nitrogen/generated
â€¼ï¸  Added 8 files - you need to run `pod install`/sync gradle to update files!
```

:::important
You should push the files in `./nitrogen/generated/` to git, and make sure those files are part of your npm package.
This way your library will always ship a working package as a whole (including generated interfaces), and the user does not need to do anything else than to install your package.
:::

### 3. Add generated sources to your library

All the generated sources (`./nitrogen/generated/`) need to be part of your library's code - so we need to add it to the iOS/Android build files.

  

  If you created a library using the [Nitro Module template](https://github.com/mrousavy/nitro/tree/main/packages/template), your library already includes nitrogen's generated sources.

  
  

  #### iOS

  On iOS, you need to call `add_nitrogen_files(...)` from your library's `.podspec`. Put this at the very end of your spec declaration:
  ```ruby
  Pod::Spec.new do |s|
    # ...
    load 'nitrogen/generated/ios/NitroExample+autolinking.rb'
    add_nitrogen_files(s)
  end
  ```

  #### Android

  On Android, you first need to add the autogenerated Java/Kotlin sources to your `build.gradle`. Put this at the top of your `build.gradle`, right after any other `apply` calls:

  ```groovy
  apply from: '../nitrogen/generated/android/NitroExample+autolinking.gradle'
  ```

  Then, add the autogenerated C++ sources to your `CMakeLists.txt`. Put this somewhere **after** `add_library(...)`:

  ```cmake
  include(${CMAKE_SOURCE_DIR}/../nitrogen/generated/android/NitroExample+autolinking.cmake)
  ```

  :::tip
  Replace `NitroExample` with your Nitro Module's name as defined in your `nitro.json`.
  :::
  

### 4. Implement the Hybrid Objects

To implement `Math` now, you just need to implement the spec:

  
    ```swift title="HybridMath.swift"
    class HybridMath : HybridMathSpec {
      public func add(a: Double, b: Double) throws -> Double {
        return a + b
      }
    }
    ```
  
  
    ```kotlin title="HybridMath.kt"
    class HybridMath : HybridMathSpec() {
      override fun add(a: Double, b: Double): Double {
        return a + b
      }
    }
    ```
  
  
    
      
        ```cpp title="HybridMath.hpp"
        class HybridMath: public HybridMathSpec {
        public:
          HybridMath(): HybridObject(TAG) {}
        public:
          double add(double a, double b) override;
        };
        ```
      
      
        ```cpp title="HybridMath.cpp"
        double HybridMath::add(double a, double b) {
          return a + b;
        }
        ```
      
    
  

### 5. Register the Hybrid Objects

Nitro needs to be able to initialize an instance of your Hybrid Object - so we need to tell it how to do that.
In your `nitro.json`, register `HybridMath` in the `"autolinking"` section:

  
    ```json
    {
      ...
      "autolinking": {
        "Math": {
          "swift": "HybridMath",
          "kotlin": "HybridMath"
        }
      }
    }
    ```
  
  
    ```json
    {
      ...
      "autolinking": {
        "Math": {
          "cpp": "HybridMath"
        }
      }
    }
    ```
  

Make sure `HybridMath` is default-constructible and scoped inside the correct namespace/package/file, **then run Nitrogen**.

#### 5.1. Initialize Android (C++)

  

  If you created a library using the [Nitro Module template](https://github.com/mrousavy/nitro/tree/main/packages/template), your library already initializes the C++ autolinking process from your `*Package.java` and `OnLoad.cpp` files.

  
  

  In your JNI OnLoad function (`OnLoad.cpp` or `cpp-adapter.cpp`), initialize your module:

  ```cpp title="cpp-adapter.cpp"
  #include 
  #include "NitroMathOnLoad.hpp"

  JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*) {
    return margelo::nitro::math::initialize(vm);
  }
  ```

  Then, to actually load and initialize the C++ part of your library (which calls `JNI_OnLoad` from above), call `initializeNative()` from your library's entry point (`*Package.java`):

  ```java title="NitroMathPackage.java"
  public class NitroMathPackage extends TurboReactPackage {
    // ...
    static {
      NitroMathOnLoad.initializeNative();
    }
  }
  ```

  

#### 5.2. (Optional) ProGuard

If you are using ProGuard on Android, make sure to add a `@DoNotStrip` annotation above your `HybridMath` class (and constructor) so Nitro can construct it from C++ in release builds.

### 6. Initialize the Hybrid Objects

And finally, to initialize `HybridMath` from JS you just need to call `createHybridObject`:

```ts
export const MathModule = NitroModules.createHybridObject("Math")
const result = MathModule.add(5, 7)
```

---

## Performance Tips

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Performance Tips

While Nitro is already insanely fast, there are some things you can do that affect the performance of your library.
Here are some tips to make your library even faster.

## Avoid dynamic types

Any dynamic types require runtime type checking, and cannot be optimized as good as statically known types (compile-time).

### Untyped Maps

An [untyped map](types/untyped-maps) (`AnyMap`) is not only untyped, but also in-efficient. If you can, avoid untyped maps:

```ts title="Bad âŒ"
interface BadDatabase extends HybridObject {
  getUser(): AnyMap
}
```

```ts title="Good âœ…"
interface User {
  name: string
  age: number
}
interface GoodDatabase extends HybridObject {
  getUser(): User
}
```

In some cases (e.g. network requests) you do not know the shape of your data, like in a JSON web-request.
In this case, it might make sense to use `ArrayBuffer` or `string`, and parse the data on the JS side using `JSON.parse` - benchmark your code (before vs after) to see if this optimization makes sense for you.

### Variants

[Variants](types/variants) (`A | B`) are dynamic types. Each time you pass a variant to native, Nitro has to check it's type at runtime - is it `A` or `B`?
Those type-checks are very efficient so this is considered a micro-optimization, but if you can, avoid variants like so:

```ts title="Bad âŒ"
interface BadDatabase extends HybridObject {
  set(value: number | string): void
}
```

```ts title="Good âœ…"
interface GoodDatabase extends HybridObject {
  setNumber(value: number): void
  setString(value: string): void
}
```

## Avoid unnecessary objects

It is a common pattern to wrap everything in an object in JavaScript.
In Nitro, every object gets it's own struct and has to be allocated.
On iOS this performance impact is almost zero, but on Android the struct is a heap-allocation.

If you can, avoid unnecessarily wrapping everything in objects, and flatten the types out in the function signature:

```ts title="Bad âŒ"
interface SetPayload {
  key: string
  value: string
  onCompleted: () => void
}
interface BadDatabase extends HybridObject {
  set(payload: SetPayload): void
}
```

```ts title="Good âœ…"
interface GoodDatabase extends HybridObject {
  set(key: string,
      value: string,
      onCompleted: () => void): void
}
```

## Use Threading/Asynchronous Promises

By default, every function in Nitro is fully synchronous.
If your function takes long to execute, the JS Thread can not do any other work in the meantime.

In such cases, mark your function asynchronous by returning a [`Promise`](types/promises), which you can then use to run the heavy processing code on a different thread:

```ts title="Bad âŒ"
interface BadDatabase extends HybridObject {
  writeLargeData(data: string): void
}
```

```ts title="Good âœ…"
interface GoodDatabase extends HybridObject {
  writeLargeData(data: string): Promise
}
```

Keep in mind that switching to a different Thread on the native side introduces a small overhead by itself. This only benefits performance if the actual computation inside the function body takes longer than the thread-switch.

## Use `ArrayBuffer` for large data

For large data sets, conventional [arrays](types/arrays) are in-efficient as each value has to be copied individually.
In contrast to conventional arrays, [Array Buffers](types/array-buffers) are zero-copy, meaning native memory can be directly shared to JS without copying the data.

For example, to return a large list of numbers we could use [array buffers](types/array-buffers) (`Float64Array`) instead of [arrays](types/arrays):

```ts title="Bad âŒ"
interface BadDatabase extends HybridObject {
  getAsBlob(): number[]
}
```

```ts title="Good âœ…"
interface GoodDatabase extends HybridObject {
  getAsBlob(): ArrayBuffer
}
```

## Use Hybrid Objects to implement proxy-results

If a function returns a large amount of data to JS, but only a sub-set of that data is used, we can implement it as a [Hybrid Object](types/hybrid-objects) instead of a [struct](types/custom-types).

This way data will be accessed lazily, and all the data that the user does not access will never be converted to JS, which means Nitro has to do less work:

```ts title="Bad âŒ"
interface AllData {
  rows: DataRow[]
}

interface BadDatabase extends HybridObject {
  getAllData(): AllData
}

const database = // ...
const data = database.getAllData()
const row = data.rows
  .find((r) => r.name === "Marc")
```

```ts title="Good âœ…"
interface AllData extends HybridObject {
  findRowWithName(name: string): DataRow
}

interface GoodDatabase extends HybridObject {
  getAllData(): AllData
}

const database = // ...
const data = database.getAllData()
const row = data.findRowWithName("Marc")
```

The **Bad** example is significantly slower than **Good**, because Nitro has to convert **all rows** to JS, and there could be thousands of rows - even if we only use the row with the `name` "Marc".

The **Good** example is significantly faster than **Bad** because the result of `getAllData()` is a [Hybrid Object](types/hybrid-objects), and all the thousands of rows do not have to be converted to JS at all, instead they are simply held in native memory. The function `findRowWithName(...)` iterates through the list on the native side and finds the matching row - only this single row will then have to be converted to JS.

## Properly use `memorySize`

Since Hybrid Objects are implemented in native code, the JS runtime does not know the memory size of such objects.
To let the JavaScript runtime know about a Hybrid Object's actual size in memory, Nitro exposes a `memorySize` (or `getExternalMemoryPressure()`) API which you can use to give a rough estimation on the native object's memory size (including any heap allocations you perform):

```swift
class HybridImage : HybridImageSpec {
  private var cgImage: CGImage
  public var memorySize: Int {
    let imageSize = cgImage.width * cgImage.height * cgImage.bytesPerPixel
    return imageSize
  }
}
```

That way the JS garbage collector knows how big an `Image` is exactly in memory, and can delete any unused `Image` objects sooner to free up the native memory (`cgImage`), potentially avoiding memory warnings or garbage collector panics.

## Avoid too many native calls

While Nitro is insanely fast, there is still an unavoidable overhead associated with calling native code from JS.
In general, it is a good practice to stay within one environment (here; JavaScript) as long as possible, and only call into native when really needed.

Some things (like the `Math.add(...)` function I often use) are faster in JavaScript, as the overhead of calling into native might be greater than the overall execution time of the function.

## Use C++ if possible

If possible, write Nitro Modules in C++. This is faster as bridging to Swift or Kotlin is not required.

## Avoid large arrays

Large arrays have to be deep-copied, as they are immutable memory in JS. If possible, avoid sending large arrays back and forth - this is the same principle as ["Use Hybrid Objects to implement proxy-results"](#use-hybrid-objects-to-implement-proxy-results).

---

## Sync vs Async

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Sync vs Async

By default, every method on a [Hybrid Object](hybrid-objects) is synchronous and runs on the JS Thread.
This means, as long as your native method is executing, the JS Thread is blocked and can not do any other work (like state updates or view changes).

## Light Methods

For small/light methods this is great because you can return results to the caller (JS) immediately without having to await a Promise.

For example, [react-native-mmkv](https://github.com/mrousavy/react-native-mmkv) allows you to _get_ values synchronously:

```ts
function App() {
  const mmkv = new MMKV()
  const name = mmkv.getString('username') // --> Marc
}
```

If it would be async, it would be quite cumbersome to use in some contexts:

```ts
function App() {
  const mmkv = new MMKV()
  const [name, setName] = useState(undefined)

  useEffect(() => {
    (async () => {
      const n = await mmkv.getString('username') // --> Marc
      setName(n)
    })()
  }, [])
}
```

## Heavy Methods

For larger/heavy methods that take a while to execute this can be problematic, because the JS Thread will be blocked for a longer duration then.

To free up the JS Thread while the long-running method is executing, you can make it **asynchronous** by just returning a `Promise`:

```ts title="MinerSpec.nitro.ts"
interface Miner extends HybridObject {
  mineOneBitcoin(): Promise
}
```

On the native side you still start out with a synchronous method, but you can return a Promise:

  
    ```swift title="HybridMiner.swift"
    class HybridMiner : HybridMinerSpec {
      public func mineOneBitcoin() throws -> Promise {
        // 1. synchronous in here, JS Thread is still blocked
        //    useful e.g. for argument checking before starting async Thread
        return Promise.async {
          // 2. asynchronous in here, JS Thread is now free
          return computeBitcoin()
        }
      }
    }
    ```
  
  
    ```kotlin title="HybridMiner.kt"
    class HybridMiner : HybridMinerSpec() {
      override fun mineOneBitcoin(): Promise {
        // 1. synchronous in here, JS Thread is still blocked
        //    useful e.g. for argument checking before starting async Thread
        return Promise.async {
          // 2. asynchronous in here, JS Thread is now free
          return computeBitcoin()
        }
      }
    }
    ```
  
  
    ```cpp title="HybridMiner.hpp"
    class HybridMiner: public HybridMinerSpec {
      std::shared_ptr> mineOneBitcoin() override {
        // 1. synchronous in here, JS Thread is still blocked
        //    useful e.g. for argument checking before starting async Thread
        return Promise::async([]() {
          // 2. asynchronous in here, JS Thread is now free
          return computeBitcoin();
        });
      }
    };
    ```
  

## When should it be async?

It's up to you to decide when to make a native method asynchronous.
Benchmark the total execution time of your method - a good rule of thumb is: _if it takes longer than 50ms, make it asynchronous_.

## Why isn't everything async?

There's two reasons:

1. Jumping from one thread (JS) to another (background) introduces a tiny overhead. Sometimes the total execution time of the method itself is smaller than just the Thread-jump, so it would make more sense to just keep it synchronous right away.
2. For small/fast methods it's more ergonomic to keep them synchronous as the caller receives the return value right away - no awaiting or Promises.

---

## Troubleshooting

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Troubleshooting

This guide helps you troubleshoot issues in Nitro and should give you enough context to open a well-formed issue, even if you're not a native developer.

## Minimum requirements

First, make sure you meet the [minimum requirements](minimum-requirements) for Nitro.

## Ask for help

If you want to ask for help, join our [Margelo Community Discord](https://margelo.com/discord).

## Build error

If your app fails to build after installing Nitro or a library powered by Nitro, make sure to post full build logs:

  

  1. Build the app with Xcode.
  2. When the build fails in Xcode, open the "Report Navigator" tab from within the left sidebar:

      

  3. Then, find the most recent build attempt and click on "Build":

      

  4. Scroll through the build report and find the step(s) that failed to build. They usually have a âŒ icon on the left. Click on the parent item's hamburger menu on the right to open the full logs:

      

  5. Scroll down through the build logs (the long part is just the command invocation) to find the actual error messages:

      

  6. Copy those bottom logs only (not the build command invocation above) and create a GitHub issue with that.

  
  

  1. Build the app with Android Studio.
  2. When the build fails in Android Studio, open the "Build" tab from within the bottom left sidebar:

      

  3. Find the top-most entry in the Build window (which contains full unfiltered logs) and click it:

      

  4. Copy those full logs and paste them in the GitHub issue (or serve via pastebin). Make sure they actually contain the **error** message and not just something like "BUILD FAILED in 7s" (which is what most people post):

      

  

## Runtime error

If your app crashes at runtime, make sure to inspect the native logs.

  

  1. Run your app through Xcode
  2. If the app hits an unhandled error, it should pause in Xcode. Share the line it stopped in, and also the call-stack (stacktrace) on the left side.
  3. If the app didn't pause, then it might have been a handled error - in this case just check the Xcode logs at the bottom:

      

  
  

  1. Run your app through Android Studio by using the Debug button (ðŸª²)
  2. If the app hits an unhandled error, it should pause in Android Studio. Share the line it stopped in, and also the call-stack (stacktrace) on the bottom window.
  3. If the app didn't pause, then it might have been a handled error - in this case just check the Android Logcat logs at the bottom:

---

## ArrayBuffers (`ArrayBuffer`)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# ArrayBuffers (`ArrayBuffer`)

Array Buffers allow highly efficient access to the same data from both JS and native.
Passing an `ArrayBuffer` from native to JS and back does not involve any copies, and is therefore the fastest way of passing around data in Nitro.

  
    ```ts
    interface Image extends HybridObject {
      getData(): ArrayBuffer
    }
    ```
  
  
    ```swift
    class HybridImage: HybridImageSpec {
      func getData() -> ArrayBufferHolder
    }
    ```
  
  
    ```kotlin
    class HybridImage: HybridImageSpec() {
      fun getData(): ArrayBuffer
    }
    ```
  
  
    ```cpp
    class HybridImage: public HybridImageSpec {
      std::shared_ptr getData();
    }
    ```
  

It is important to understand the ownership, and threading concerns around such shared memory access.

## Ownership

There's two types of `ArrayBuffer`s, **owning** and **non-owning**:

### Owning

An `ArrayBuffer` that was created on the native side is **owning**, which means you can safely access it's data as long as the `ArrayBuffer` reference is alive.
It can be safely held strong for longer, e.g. as a class property/member, and accessed from different Threads.

```swift
func doSomething() -> ArrayBufferHolder {
  // highlight-next-line
  let buffer = ArrayBufferHolder.allocate(1024 * 10)
  let data = buffer.data   // 
  
    ```swift
    let myData = UnsafeMutablePointer.allocate(capacity: 4096)

    // wrap (no copy)
    let wrappingArrayBuffer = ArrayBufferHolder.wrap(dataWithoutCopy: myData,
                                                     size: 4096,
                                                     onDelete: { myData.deallocate() })
    // copy
    let copiedArrayBuffer = ArrayBufferHolder.copy(of: wrappingArrayBuffer)
    // new blank buffer
    let newArrayBuffer = ArrayBufferHolder.allocate(size: 4096)
    ```
  
  
    ```kotlin
    val myData = ByteBuffer.allocateDirect(4096)

    // wrap (no copy)
    val wrappingArrayBuffer = ArrayBuffer.wrap(myData)

    // copy
    let copiedArrayBuffer = ArrayBuffer.copy(myData)
    // new blank buffer
    val newArrayBuffer = ArrayBuffer.allocate(4096)
    ```
  
  
    ```cpp
    auto myData = new uint8_t[4096];

    // wrap (no copy)
    auto wrappingArrayBuffer = ArrayBuffer::wrap(myData, 4096, [=]() {
      delete[] myData;
    });
    // copy
    auto copiedArrayBuffer = ArrayBuffer::copy(myData, 4096);
    // new blank buffer
    auto newArrayBuffer = ArrayBuffer::allocate(4096);
    ```
  

#### Language-native buffer types

ArrayBuffers also provide helper and conversion methods for the language-native conventional buffer types:

  
    Swift often uses [`Data`](https://developer.apple.com/documentation/foundation/data) to represent Data.
    ```swift
    let data = Data(capacity: 1024)
    let buffer = ArrayBufferHolder.copy(data: data)
    let dataAgain = buffer.toData(copyIfNeeded: true)
    ```
  
  
    Kotlin often uses [`ByteBuffer`](https://developer.android.com/reference/java/nio/ByteBuffer) to represent Data.
    ```kotlin
    val data = ByteBuffer.allocateDirect(1024)
    val buffer = ArrayBuffer.copy(data)
    val dataAgain = buffer.getBuffer(copyIfNeeded = true)
    ```
  
  
    C++ often uses [`std::vector`](https://en.cppreference.com/w/cpp/container/vector) to represent Data.
    ```cpp
    std::vector data;
    auto buffer = ArrayBuffer::copy(data);
    /* convert back to vector would be a copy. */
    ```
  

### From JS

From JS, a **non-owning** `ArrayBuffer` can be created via the [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) web APIs, and viewed or edited using the typed array APIs (e.g. [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)).

```ts
const arrayBuffer = new ArrayBuffer(4096)
const view = new Uint8Array(arrayBuffer)
view[0] = 64
view[1] = 128
view[2] = 255
```

---

## Arrays (`T[]`)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Arrays (`T[]`)

Arrays of items are represented with the most common, and most efficient array datastructures in native languages, such as `std::vector` or `Array`.

  
    ```ts
    interface Contacts extends HybridObject {
      getAllUsers(): User[]
    }
    ```
  
  
    ```swift
    class HybridContacts: HybridContactsSpec {
      fun getAllUsers() -> Array
    }
    ```
  
  
    ```kotlin
    class HybridContacts: HybridContactsSpec() {
      fun getAllUsers(): Array
    }
    ```
  
  
    ```cpp
    class HybridContacts : public HybridContactsSpec {
      std::vector getAllUsers();
    }
    ```
  

## Kotlin `PrimitiveArray`

As a performance improvement, the JNI (C++ -> Kotlin interface) provides **Primitive Array** datatypes which can avoid boxing primitives into `Object`s, and provides bulk copy methods.
This makes all array operations **a lot faster**, and Nitrogen is smart enough to âœ¨**automagically**âœ¨ use Primitive Arrays whenever possible.
This will replace the following arrays:

- `Array` -> [`DoubleArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/)
- `Array` -> [`BooleanArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean-array/)
- `Array` -> [`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/)

---

## Callbacks (`(...) => T`)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Callbacks (`(...) => T`)

Callbacks are functions created in one language and passed to another to provide a way to "call back" later.

Nitro has a clever reference counting system to allow users to use callbacks/functions from JS safely, and without any limitations.
Each callback holds a strong reference on the native side and can be called as often as needed.
Once the callback is no longer used, it will be safely deleted from memory.

  
    In TypeScript, a callback is represented as an anonymous function:

    ```ts
    interface Server extends HybridObject {
      start(onNewUserJoined: (user: User) => void): void
    }
    ```
  
  
    In Swift, a callback is represented as a closure:

    ```swift
    func start(onNewUserJoined: (User) -> Void) {
      onNewUserJoined(user)
    }
    ```
  
  
    In Kotlin, a callback is represented as a lambda:

    ```kotlin
    fun start(onNewUserJoined: (User) -> Unit) {
      onNewUserJoined(user)
    }
    ```
  
  
    In C++, a callback is represented as a function:

    ```cpp
    void start(std::function onNewUserJoined) {
      onNewUserJoined(user);
    }
    ```
  

## Events

Since callbacks can be safely kept in memory for longer and called multiple times, Nitro does not have a special type for an "event".
It is simply a function you store in memory and call later, just like in a normal JS class. âœ¨

  
    In TypeScript, a callback is represented as an anonymous function:

    ```ts
    type Orientation = "portrait" | "landscape"
    interface DeviceInfo extends HybridObject {
      listenToOrientation(onChanged: (o: Orientation) => void): void
    }

    const deviceInfo = // ...
    deviceInfo.listenToOrientation((o) => {
      console.log(`Orientation changed to ${o}!`)
    })
    ```
  
  
    In Swift, a callback is represented as a closure:

    ```swift
    func listenToOrientation(onChanged: (Orientation) -> Void) {
      self.listeners.append(onChanged)
    }

    func onRotate() {
      for listener in self.listeners {
        listener(newOrientation)
      }
    }
    ```
  
  
    In Kotlin, a callback is represented as a lambda:

    ```kotlin
    fun listenToOrientation(onChanged: (Orientation) -> Unit) {
      this.listeners.add(onChanged)
    }

    fun onRotate() {
      for (listener in this.listeners) {
        listener(newOrientation)
      }
    }
    ```
  
  
    In C++, a callback is represented as a function:

    ```cpp
    void listenToOrientation(std::function onChanged) {
      this->listeners.push_back(onChanged);
    }

    void onRotate() {
      for (const auto& listener: this->listeners) {
        listener(newOrientation);
      }
    }
    ```
  

## Callbacks that return a value (`(...) => T`)

Since JS callbacks could theoretically be called from any native Thread,
Nitro safely wraps the result types of callbacks that return a value in **Promises which need to be awaited**.

```ts title="Math.nitro.ts"
interface Math extends HybridObject {
  some(getValue: () => number): void
}
```

```swift title="HybridMath.swift"
func some(getValue: () -> Promise) {
  Task {
    let promise = getValue()
    let valueFromJs = try await promise.await()
  }
}
```

## Synchronous Callbacks

By default, callback functions in Nitro are _asynchronous_. Their execution is scheduled on the JS Thread, and if they return a value they always return a `Promise` wrapping the value.
This ensures that you can call the callback from any Thread, and it safely executes the actual JS function on the correct JS Thread.

In addition to that, Nitro also supports fully _synchronous_ callbacks. They are considered dangerous, as the caller is responsible for ensuring Thread safety.
To extend the previous example, we can make `getValue()` synchronous by wrapping it in the `Sync` type provided by Nitro:

```ts title="Math.nitro.ts"
interface Math extends HybridObject {
  some(getValue: Sync number>): void
}
```

```swift title="HybridMath.swift"
func some(getValue: () -> Double) {
  let valueFromJs = getValue()
}
```

:::warning
The `getValue()` callback can now only be called from the JS Thread.
:::

## How was it before Nitro?

Conventionally (in legacy React Native Native Modules), a native method could only have a maximum of two callbacks, one "success" and one "failure" callback.
Once one of these callbacks is called, both will be destroyed and can no longer be called later.
This is why React Native introduced "Events" as a way to call into JS more than just once.
This also meant that an asynchronous function could not have any callbacks, since a Promise's resolve and reject functions are already two callbacks.
For example, this was **not possible**:

```ts
interface Camera {
  startRecording(onStatusUpdate: () => void,
  // code-error
                 onRecordingFailed: () => void,
  // code-error
                 onRecordingFinished: () => void): Promise
}
```

Thanks to Nitro's clever reference system, functions can be safely held in memory and called as many times as you like, just like in a normal JS class.
This makes "Events" obsolete, and allows using as many callbacks per native method as required.

---

## Custom Types (...any `T`)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Custom Types (...any `T`)

  

    Nitrogen can âœ¨**automagically**âœ¨ generate custom types and their respective bindings for any types used in your specs.

    ## Custom interfaces (structs)

    Any custom `interface` or `type` will be represented as a fully type-safe `struct` in C++/Swift/Kotlin. Simply define the type in your `.nitro.ts` spec:

    
    

    ```ts title="Nitro.nitro.ts"
    interface Person {
      name: string
      age: number
    }

    interface Nitro extends HybridObject {
      getAuthor(): Person
    }
    ```

    
    

    ```swift title="HybridNitro.swift"
    class HybridNitro: HybridNitroSpec {
      func getAuthor() -> Person {
        return Person(name: "Marc", age: 24)
      }
    }

    ```

    
    

    Nitro enforces full type-safety to avoid passing or returning wrong types.
    Both `name` and `age` are always part of `Person`, they are never a different type than a `string`/`number`, and never null or undefined.

    This makes the TypeScript definition the **single source of truth**, allowing you to rely on types! ðŸ¤©

    ## Enums (TypeScript enum)

    A [TypeScript enum](https://www.typescriptlang.org/docs/handbook/enums.html) is essentially just an object where each key has an incrementing integer value,
    so Nitrogen will just generate a C++ enum natively, and bridges to JS using simple integers:

    ```ts
    enum Gender {
      MALE,
      FEMALE
    }
    interface Person extends HybridObject {
      getGender(): Gender
    }
    ```

    This is efficient because `MALE` is the number `0`, `FEMALE` is the number `1`, and all other values are invalid.

    ## Enums (TypeScript union)

    A [TypeScript union](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types) is essentially just a string, which is only "typed" via TypeScript.

    ```ts
    type Gender = 'male' | 'female'
    interface Person extends HybridObject {
      getGender(): Gender
    }
    ```

    Nitrogen statically generates hashes for the strings `"male"` and `"female"` at compile-time, allowing for very efficient conversions between JS `string`s and native `enum`s.

  
  

    ## Overloading a simple type

    The `JSIConverter` is a template which can be extended with any custom type.

    For example, if you want to use `float` directly you can tell Nitro how to convert a `jsi::Value` to `float` by implementing `JSIConverter`:

    ```cpp title="JSIConverter+Float.hpp"
    template 
    struct JSIConverter final {
      static inline float fromJSI(jsi::Runtime&, const jsi::Value& arg) {
        return static_cast(arg.asNumber());
      }
      static inline jsi::Value toJSI(jsi::Runtime&, float arg) {
        return jsi::Value(arg);
      }
      static inline bool canConvert(jsi::Runtime&, const jsi::Value& value) {
        return value.isNumber();
      }
    };
    ```

    Then just use it in your methods:

    ```cpp title="HybridMath.hpp"
    class HybridMath : public HybridObject {
    public:
      float add(float a, float b) {
        return a + b;
      }

      void loadHybridMethods() {
        HybridObject::loadHybridMethods();
        registerHybrids(this, [](Prototype& prototype) {
          prototype.registerHybridMethod("add", &HybridMath::add);
        });
      }
    }
    ```

    :::info
    Make sure the compiler knows about `JSIConverter` at the time when `HybridMath` is declared, so import your `JSIConverter+Float.hpp` in your Hybrid Object's header file as well!
    :::

    ## Complex types (e.g. `struct`)

    The same goes for any complex type, like a custom typed `struct`:

    ```cpp title="JSIConverter+Person.hpp"
    struct Person {
      std::string name;
      double age;
    };

    template 
    struct JSIConverter {
      static Person fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
        jsi::Object obj = arg.asObject(runtime);
        return Person(
          JSIConverter::fromJSI(runtime, obj.getProperty(runtime, "name")),
          JSIConverter::fromJSI(runtime, obj.getProperty(runtime, "age"))
        );
      }
      static jsi::Value toJSI(jsi::Runtime& runtime, const Person& arg) {
        jsi::Object obj(runtime);
        obj.setProperty(runtime, "name", JSIConverter::toJSI(runtime, arg.name));
        obj.setProperty(runtime, "age", JSIConverter::toJSI(runtime, arg.age));
        return obj;
      }
      static bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
        if (!value.isObject())
          return false;
        jsi::Object obj = value.getObject(runtime);
        if (!JSIConverter::canConvert(runtime, obj.getProperty(runtime, "name")))
          return false;
        if (!JSIConverter::canConvert(runtime, obj.getProperty(runtime, "age")))
          return false;
        return true;
      }
    };
    ```

    ..which can now safely be called with any JS value.
    If the given JS value is not an object of exactly the shape of `Person` (that is, a `name: string` and an `age: number` values), Nitro will throw an error.

---

## Dates (`Date`)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Dates (`Date`)

Dates are date and time instances that can be passed between JS and native.
Under the hood, conversions take place using milliseconds, so it's essentially a wrapper around `numbers`.

  
    ```ts
    interface Image extends HybridObject {
      getCreationDate(): Date
    }
    ```
  
  
    ```swift
    class HybridImage: HybridImageSpec {
      func getCreationDate() -> Date
    }
    ```
  
  
    ```kotlin
    class HybridImage: HybridImageSpec() {
      fun getCreationDate(): Instant
    }
    ```
  
  
    ```cpp
    class HybridImage: public HybridImageSpec {
      std::chrono::system_clock::time_point getCreationDate();
    }
    ```

---

## Other Hybrid Objects (`HybridObject`)

# Other Hybrid Objects (`HybridObject`)

Since Nitro Modules are object-oriented, a `HybridObject` itself is a first-class citizen.
This means you can pass around instances of native `HybridObject`s between JS and native, allowing for safe interface-level abstractions:

```ts title="Camera.nitro.ts"
interface Image extends HybridObject {
  readonly width: number
  readonly height: number
}

interface Camera extends HybridObject {
  takePhoto(): Image
}
```

```swift title="HybridCamera.swift"
class HybridImage: HybridImageSpec {
  var width: Double { get }
  var height: Double { get }
}

class HybridCamera: HybridCameraSpec {
  func takePhoto() -> HybridImageSpec
}
```

## Interface-level abstraction

Since Hybrid Objects are declared as interfaces, `Image` could have different implementations...

```swift
class HybridUIImage: HybridImageSpec {
  // ...
  var uiImage: UIImage
}
class HybridCGImage: HybridImageSpec {
  // ...
  var cgImage: CGImage
}
class HybridBufferImage: HybridImageSpec {
  // ...
  var gpuBuffer: CMSampleBuffer
}
```

...but still be used exactly the same in other places, as it is all a `HybridImageSpec`.
Even if they use different implementations under the hood, they all share a common interface with properties like `width`, `height` and more:

```ts title="Cropper.nitro.ts"
interface Cropper extends HybridObject {
  crop(image: Image, size: Size): Image
}
```

```swift title="Cropper.swift"
class HybridCropper: HybridCropperSpec {
  func crop(image: HybridImageSpec,
            size: Size) -> HybridImageSpec {
    let data = image.data
    let croppedData = cropFunc(data, size)
    return HybridCGImage(data: croppedData)
  }
}
```

---

## Optionals (`T?`)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Optionals (`T?`)

Optional or nullable values can be declared either by using the questionmark operator (`?`), or by adding an `undefined` variant:

  
    ```ts
    interface Math extends HybridObject {
      a?: number
      b: number | undefined
    }
    ```
  
  
    ```swift
    class HybridMath: HybridMathSpec {
      var a: Double?
      var b: Double?
    }
    ```
  
  
    ```kotlin
    class HybridMath: HybridMathSpec() {
      override var a: Double?
      override var b: Double?
    }
    ```
  
  
    ```cpp
    class HybridMath: public HybridMathSpec {
      std::optional a;
      std::optional b;
    };
    ```
  

In Kotlin/Java, nullables have to be boxed in object types.

---

## Primitives (`number`, `boolean`, `bigint`)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Primitives (`number`, `boolean`, `bigint`)

Primitive datatypes like `number`, `boolean` or `bigint` can use platform-native datatypes directly.
For example, a JS `number` is always a 64-bit `double` in C++, a `Double` in Swift, and a `Double` in Kotlin.

  
    ```ts
    interface Math extends HybridObject {
      add(a: number, b: number): number
    }
    ```
  
  
    ```swift
    class HybridMath: HybridMathSpec {
      func add(a: Double, b: Double) -> Double
    }
    ```
  
  
    ```kotlin
    class HybridMath: HybridMathSpec() {
      fun add(a: Double, b: Double): Double
    }
    ```
  
  
    ```cpp
    class HybridMath : public HybridMathSpec {
      double add(double a, double b);
    }
    ```
  

Primitives are very efficient and can be passed with little to no overhead, especially between C++ and Swift, and C++ and Kotlin.

## `bigint`'s actual type

A `bigint` is actually a variable-size type. While it is bridged to a 64-bit Integer (-263 â€¦ 263âˆ’1), it can theoretically be larger than that.

Since there is no built-in equivalent of `bigint` in C++/Swift/Kotlin, you'd need to stringify the `bigint` value on the JS side and parse it from a string to your big number library of choice on the native side again in cases where you really need big numbers.

---

## Promises (`Promise<T>`)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Promises (`Promise`)

A function can be made asynchronous by returning a `Promise` to JS.
This allows your native code to perform heavy-, long-running tasks in parallel, while the JS thread can continue rendering and performing other business logic.

  
    In TypeScript, a `Promise` is represented using the built-in `Promise` type, which can be awaited:

    ```ts
    interface Math extends HybridObject {
      fibonacci(n: number): Promise
    }

    const math = // ...
    await math.fibonacci(13)
    ```
  
  
    In Swift, a `Promise` can be created via Nitro's [`Promise`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/ios/core/Promise.swift) type - for example, to use Swift's new async/await syntax:

    ```swift
    func fibonacci(n: Double) -> Promise {
      return Promise.async {
        // This runs on a separate Thread, and can use `await` syntax!
        return try await calculateFibonacciSequence(n)
      }
    }
    ```
  
  
    In Kotlin, a `Promise` can be created via Nitro's [`Promise`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/core/Promise.kt) type - for example, to use Kotlin's coroutine syntax:

    ```kotlin
    fun fibonacci(n: Double): Promise {
      return Promise.async {
        // This runs on a separate Thread, and can use suspending coroutine functions!
        return calculateFibonacciSequence(n)
      }
    }
    ```
  
  
    In C++, a `Promise` can be created via Nitro's [`Promise`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/cpp/core/Promise.hpp) type - for example, to use an asynchronous Thread pool:

    ```cpp
    std::shared_ptr> fibonacci(double n) {
      return Promise::async([=]() -> double {
        // This runs on a separate Thread!
        return calculateFibonacciSequence(n);
      });
    }
    ```
  

Additionally, Nitro statically enforces that **Promises can never go stale**, preventing you from accidentally "forgetting" to resolve or reject a Promise:

```swift title="HybridMath.swift"
func saveToFile(image: HybridImage) -> Promise {
  guard let data = image.data else { return }
  // code-error
                                     ^ // Error: Cannot return void!
  return Promise.async {
    try await data.writeToFile("file://tmp/img.png")
  }
}
```

---

## Tuples (`[A, B, ...]`)

# Tuples (`[A, B, ...]`)

A Tuple is a fixed-length set of items of the given types. Example:

```ts
type Point = [number, number]
interface Math extends HybridObject {
  distance(a: Point, b: Point): number
}
```

Tuples can also have different types per value:

```ts title="Bad âŒ"
type Values = (number | string | Person)[]
interface Math extends HybridObject {
  calculate(values: Values): void
}
```
The type in the **Bad âŒ** example generates an [array](arrays) of [variants](variants), where it's size is unknown and each value could be a `number`, a `string` or a `Person`. It is less efficient than a **tuple** because of the variant allocation.

```ts title="Good âœ…"
type Values = [number, string, Person]
interface Math extends HybridObject {
  calculate(values: Values): void
}
```
The type in the **Good âœ…** example generates a **tuple**, where it's size is guaranteed to be **3** and each value is known at compile-time: `values[0]: number`, `values[1]: string`, `values[2]: Person`.

---

## Typed maps (`Record<string, T>`)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Typed maps (`Record`)

A typed map is an object where each value is of the given type `T`.

For example, if your API returns a map of users with their ages, you _could_ use a `Record`:

  
    ```ts
    interface Database extends HybridObject {
      getAllUsers(): Record
    }
    ```
  
  
    ```swift
    class HybridDatabase: HybridDatabaseSpec {
      func getAllUsers() -> Dictionary
    }
    ```
  
  
    ```kotlin
    class HybridDatabase: HybridDatabaseSpec() {
      fun getAllUsers(): Map
    }
    ```
  
  
    ```cpp
    class HybridDatabase: public HybridDatabaseSpec {
      std::unordered_map getAllUsers();
    }
    ```
  

:::tip
While typed maps are very efficient, Nitro cannot sufficiently optimize the object as keys are not known in advance.
If possible, **avoid typed maps** and use [arrays](arrays) for unknown number of items, or [strongly typed objects](custom-types) for known number of items instead.
:::

---

## Nitro's Typing System

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Nitro's Typing System

Nitro uses an extensible typing system to efficiently convert between JS and C++ types - **statically defined** and fully **type-safe** and **null-safe at compile-time**.

For example, a JS `number` will always be a `double` on the native side:

```ts title="Math.nitro.ts"
interface Math extends HybridObject {
  add(a: number, b: number): number
}
```

```cpp title="HybridMath.hpp"
class HybridMath : public HybridMathSpec {
  double add(double a, double b);
}
```

Nitro strictly enforces **type-safety** and **null-safety** - both at compile-time and at runtime.
This prevents accidentally passing a wrong type to `add(..)` (for example, a `string`) and performs null-checks to prevent passing and returning `null`/`undefined` values.

On the JS side (TypeScript), type- and null-safety is enforced via TypeScript - so use it!

## Nitrogen

[Nitrogen](nitrogen) ensures that TypeScript definitions are always in sync with native type definitions.
You can also use Nitro without nitrogen, in this case TypeScript definitions have to be written manually.

## Supported Types

These are all the types Nitro supports out of the box:

  
    JS Type
    C++ Type
    Swift Type
    Kotlin Type
  

  
    number
    double / int / float
    Double
    Double
  
  
    boolean
    bool
    Bool
    Boolean
  
  
    string
    std::string
    String
    String
  
  
    bigint
    int64_t / uint64_t
    Int64
    Long
  
  
    T[]
    std::vector&lt;T&gt;
    [T]
    Array&lt;T&gt; / PrimitiveArray
  
  
    T?
    std::optional&lt;T&gt;
    T?
    T?
  
  
    [A, B, ...]
    std::tuple&lt;A, B, ...&gt;
    (A, B) ðŸŸ¡Â Â (#38)
    âŒ
  
  
    A | B | ...
    std::variant&lt;A, B, ...&gt;
    Variant_A_B_C
    Variant_A_B_C
  
  
    (T...) =&gt; void
    std::function&lt;void (T...)&gt;
    @escaping (T...) -&gt; Void
    (T...) -&gt; Unit
  
  
    (T...) =&gt; R
    std::function&lt;std::shared_ptr&lt;Promise&lt;R&gt;&gt; (T...)&gt;
    @escaping (T...) -&gt; Promise&lt;R&gt;
    (T...) -&gt; Promise&lt;R&gt;
  
  
    Sync&lt;(T...) =&gt; R&gt;
    std::function&lt;R (T...)&gt;
    @escaping (T...) -&gt; R
    (T...) -&gt; R
  
  
    Record&lt;string, T&gt;
    std::unordered_map&lt;std::string, T&gt;
    Dictionary&lt;String, T&gt;
    Map&lt;String, T&gt;
  
  
    Error
    std::exception_ptr
    Error
    Throwable
  
  
    Promise&lt;T&gt;
    std::shared_ptr&lt;Promise&lt;T&gt;&gt;
    Promise&lt;T&gt;
    Promise&lt;T&gt;
  
  
    object
    std::shared_ptr&lt;AnyMap&gt;
    AnyMapHolder
    AnyMap
  
  
    ArrayBuffer
    std::shared_ptr&lt;ArrayBuffer&gt;
    ArrayBufferHolder
    ArrayBuffer
  
  
    Date
    std::chrono::system_clock::time_point
    Date
    java.time.Instant
  
  
    ..any HybridObject
    std::shared_ptr&lt;HybridObject&gt;
    HybridObject
    HybridObject
  
  
    ..any interface
    T
    T
    T
  
  
    ..any enum
    T
    T
    T
  
  
    ..any union
    T
    T
    T

---

## Untyped maps (`AnyMap` / `object`)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Untyped maps (`AnyMap` / `object`)

An untyped map represents a JSON-like structure with a value that can either be a `number`, a `string`, a `boolean`, a `bigint`, a `null`, an array or an object.

  
    ```ts
    interface Fetch extends HybridObject {
      get(url: string): AnyMap
    }
    ```
  
  
    ```swift
    class HybridFetch: HybridFetchSpec {
      func get(url: String) -> AnyMapHolder
    }
    ```
  
  
    ```kotlin
    class HybridFetch: HybridFetchSpec() {
      fun get(url: String): AnyMap
    }
    ```
  
  
    ```cpp
    class HybridFetch: public HybridFetchSpec {
      std::shared_ptr get(const std::string& url);
    }
    ```
  

:::tip
While untyped maps are implemented efficiently, Nitro cannot sufficiently optimize the object as keys and value-types are not known in advance.
If possible, **avoid untyped maps** and use [strongly typed objects](custom-types) instead.
:::

---

## Variants (`A | B | ...`)

# Variants (`A | B | ...`)

A Variant is a type of either one of the values defined in it's declaration. Example:

```ts
interface Math extends HybridObject {
  distance(value: number | Point): number
}
```

:::tip
While variants are still very efficient, they need runtime-checks for type conversions,
which comes with a tiny overhead compared to all other statically defined types. If possible, **avoid variants**.
:::

## Custom Alias Names

Each variant is a unique type in Swift/Kotlin - for example: `string | number` becomes `Variant_String_Double`.

Since the generated names are hard to read, it is recommended to declare type-aliases with custom names instead:

```ts title="Bad âŒ"
export interface Math extends HybridObject {
  calculate(): string | number
}
```

```ts title="Good âœ…"
export type MathOutput = string | number
export interface Math extends HybridObject {
  calculate(): MathOutput
}
```

This will then use the easier-to-read type-alias name instead of `Variant_String_Double`:

```swift title="nitrogen/generated/ios/HybridMathSpec.swift"
public protocol HybridMathSpec: HybridObject {
  // diff-remove
  func calculate() -> Variant_String_Double
  // diff-add
  func calculate() -> MathOutput
}
```

---

## Using Nitro in a library

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Using Nitro in a library

Nitro can be used as a simple C++ library in your React Native library, which is very lightweight and simple.

## 1. Create a Nitro Module

First, you need to create a [Nitro Module](nitro-modules) - either by just using the [Nitro Modules template](https://github.com/mrousavy/nitro/tree/main/packages/template), or by just adding `react-native-nitro-modules` to your existing React Native library.

## 2. Create Hybrid Objects

To actually use Nitro, you need to create [Hybrid Objects](hybrid-objects) - either by using Nitro's code-generator CLI â€œ[Nitrogen](nitrogen)â€, or by just manually extending the `HybridObject` base class in C++.

## 3. Register Hybrid Objects

Each Hybrid Object you want to initialize from JS has to be registered in Nitro - either by autolinking them with Nitrogen (see [Configuration (Autolinking)](configuration-nitro-json#autolinking)), or by manually registering the constructors in the [`HybridObjectRegistry`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/cpp/registry/HybridObjectRegistry.hpp).

## 4. Use your Hybrid Objects in JS

Lastly, you can initialize and use the registered Hybrid Objects from JS. This is what this will ultimately look like:

```ts
interface Math extends HybridObject {
  add(a: number, b: number): number
}

const math = NitroModules.createHybridObject("Math")
const value = math.add(5, 7) // --> 12
```

## 5. Run it

To test the library you just created, you now need to set up an example app for it.
There's multiple different ways to set up a react-native app nowadays, either via Expo, RN CLI, or bare brownfield iOS/Android apps.

For example, to create a new Expo app, run `create-expo-app`:

```sh
npx create-expo-app@latest
```

Then add the Nitro Module you created in step 1 as a local library (aka _linking it_), and run it.

---

## Using Nitro in your app

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Using Nitro in your app

While most libraries are built with Nitro and shipped over npm, you can also easily build a library with Nitro in your app - that's the "brownfield" way of doing things.

## Installing Nitro

First, you need to install the Nitro Modules core package from npm:

  
    ```sh
    npm i react-native-nitro-modules
    cd ios && pod install
    ```
  
  
    ```sh
    yarn add react-native-nitro-modules
    cd ios && pod install
    ```
  
  
    ```sh
    pnpm add react-native-nitro-modules
    cd ios && pod install
    ```
  
  
    ```sh
    bun i react-native-nitro-modules
    cd ios && pod install
    ```
  

## Creating a Hybrid Object

After installing Nitro, you can start creating your [Hybrid Objects](hybrid-objects) - either with [Nitrogen](nitrogen), or manually:

  

  Nitrogen will âœ¨ automagically âœ¨ generate native specifications for each Hybrid Object based on a given TypeScript definition.

  ### 1. Installing Nitrogen

  First, install Nitrogen:

  
    
      ```sh
      npm i nitro-codegen --save-dev
      ```
    
    
      ```sh
      yarn add nitro-codegen -D
      ```
    
    
      ```sh
      pnpm add nitro-codegen -D
      ```
    
    
      ```sh
      bun i nitro-codegen -d
      ```
    
  

  :::warning
  Nitrogen is currently named `nitro-codegen` instead of `nitrogen` on npm.
  :::

  Then, create your `nitro.json` configuration in your app's root directory:

  ```json
  {
    "$schema": "https://nitro.margelo.com/nitro.schema.json",
    "cxxNamespace": ["example"],
    "ios": {
      "iosModuleName": "NitroExample"
    },
    "android": {
      "androidNamespace": ["example"],
      "androidCxxLibName": "NitroExample"
    },
    "autolinking": {}
  }
  ```

  Note: Replace `Example` with your app's name.

  ### 2. Creating Nitro specs

  Now it's time to create your first spec. Let's create `Math.nitro.ts`:

  ```ts title="Math.nitro.ts"
  interface Math extends HybridObject {
    readonly pi: number
    add(a: number, b: number): number
  }
  ```

  And now let's run Nitrogen:

  ```sh
  npx nitro-codegen
  ```

  :::warning
  Nitrogen is currently named `nitro-codegen` instead of `nitrogen` on npm.
  :::

  This will generate the native Swift and Kotlin protocol "`HybridMathSpec`", as well as some helper classes for autolinking and bridging to C++.

  ### 3. Adding the generated sources to your project

  You now need to add the generated sources to your project - either by creating a sub-package that you will use in your app (e.g. in a monorepo), or by just manually adding the source files:

  
    

      #### iOS

      On iOS, you just need to drag and drop the `nitrogen/generated/ios` and `nitrogen/generated/shared` folders into your Xcode project. That's it.

      #### Android

      For Android, you need to add everything in `nitrogen/generated/android` and `nitrogen/generated/shared` to your build.gradle (Java/Kotlin source) and CMake (C++ sources) project.

      ##### Java/Kotlin sources (`build.gradle`)

      Add the Java/Kotlin sources to your Gradle project by including the generated autolinking gradle file. Simply add this to the top of your `app/build.gradle`:

      ```groovy
      apply from: '../nitrogen/generated/android/NitroExample+autolinking.gradle'
      ```

      ##### C++ sources (`CMakeLists.txt`)

      Add the C++ sources to your CMake project by including the generated autolinking CMake file. If you do not have a CMake setup yet, make sure to configure CMake through `externalNativeBuild` in `build.gradle`. Simply add this to your `CMakeLists.txt`:

      ```cmake
      include(${CMAKE_SOURCE_DIR}/../nitrogen/generated/android/NitroTest+autolinking.cmake)
      ```

    
    

      #### iOS

      On iOS, you need to create a local Podspec (`$$iosModuleName$$.podspec`). In this local pod you need to include the autolinking code that has been generated by Nitrogen:
      ```ruby
      load 'nitrogen/generated/ios/NitroExample+autolinking.rb'
      add_nitrogen_files(s)
      ```
      And then just add this local Pod to your `Podfile`:
      ```ruby
      pod '$$iosModuleName$$', :path => '../'
      ```

      #### Android

      On Android, you need to create a local Android library (`build.gradle`). This library also needs to set up a CMake build (via `externalNativeBuild`). See the template for an example.

      Inside the local Android library's `build.gradle`, add the autogenerated Java/Kotlin sources:

      ```groovy
      apply from: '../nitrogen/generated/android/NitroExample+autolinking.gradle'
      ```

      Inside the local Android library's `CMakeLists.txt`, add the autogenerated C++ sources:

      ```cmake
      include(${CMAKE_SOURCE_DIR}/../nitrogen/generated/android/NitroTest+autolinking.cmake)
      ```

      And lastly, add this local Android library to your app's `build.gradle` using `dependencies`:

      ```groovy
      // ...
      dependencies {
        // ...
        implementation project(':your-local-library')
      }
      ```

      You might also need to include the local library in your app's `settings.gradle`:

      ```groovy
      include ':your-local-library'
      ```

    
  

  ### 4. Implement Hybrid Object Specs

  After adding the generated sources to your project, you can start implementing the spec in a class:

  
    
      ```swift title="HybridMath.swift"
      class HybridMath : HybridMathSpec {
        public var pi: Double {
          return Double.pi
        }
        public func add(a: Double, b: Double) throws -> Double {
          return a + b
        }
      }
      ```
    
    
      ```kotlin title="HybridMath.kt"
      class HybridMath : HybridMathSpec() {
        override var pi: Double
          get() = Double.PI

        override fun add(a: Double, b: Double): Double {
          return a + b
        }
      }
      ```
    
  

  ### 5. Registering the Hybrid Objects

  Nitro needs to be able to initialize an instance of your Hybrid Object - so we need to tell it how to do that.
  In your `nitro.json`, register `HybridMath` in the `"autolinking"` section:
  
    
      ```json
      {
        ...
        "autolinking": {
          "Math": {
            "swift": "HybridMath",
            "kotlin": "HybridMath"
          }
        }
      }
      ```

      :::warning
      - Make sure `HybridMath` is default-constructible. That is, it has a public initializer that takes no arguments.
      - Make sure the Java/Kotlin class `HybridMath` is inside the package/namespace `com.margelo.nitro.$$androidNamespace$$` (as configured in `nitro.json`).
      - Make sure the Java/Kotlin class `HybridMath` is annotated with `@DoNotStrip` to avoid it from being compiled out in production builds.
      :::
    
    
      ```json
      {
        ...
        "autolinking": {
          "Math": {
            "cpp": "HybridMath"
          }
        }
      }
      ```

      :::warning
      - Make sure `HybridMath` is default-constructible. That is, it has a public constructor that takes no arguments.
      - Make sure the `HybridMath` class is defined in a header named `HybridMath.hpp` - this is what Nitro will import.
      - Also make sure `HybridMath` is either in the global namespace, or in `margelo::nitro::` (configured in `nitro.json`).
      :::
    
  

  For more information, see the [Nitrogen documentation](nitrogen).

  
  

  Manually creating Hybrid Objects is quite easy, but since Nitro is a C++ library, you need to use C++.
  You can bridge the implementations of those methods to Swift/Objective-C/Java/Kotlin/Rust yourself, but Nitrogen usually does all of that âœ¨ automagically âœ¨.

  Simply create your C++ classes and inherit from `HybridObject`:

  
    
      ```cpp title="HybridMath.hpp"
      class HybridMath: public HybridObject {
      public:
        HybridMath(): HybridObject(NAME) { }

      public:
        double add(double a, double b);

      protected:
        void loadHybridMethods() override;

      private:
        static constexpr auto NAME = "Math";
      };
      ```
    
    
      ```cpp title="HybridMath.cpp"
      double HybridMath::add(double a, double b) {
        return a + b;
      }

      void HybridMath::loadHybridMethods() {
        // register base methods (toString, ...)
        HybridObject::loadHybridMethods();
        // register custom methods (add)
        registerHybrids(this, [](Prototype& proto) {
          proto.registerHybridMethod(
            "add",
            &HybridMath::add
          );
        });
      }
      ```
    
  

  Then, register the Hybrid Object constructor somewhere on app startup - e.g. in `AppDelegate`'s `application:didFinishLaunchingWithOptions:`, or in your `cpp-adapter`'s JNI on load:

  ```cpp
  HybridObjectRegistry::registerHybridObjectConstructor(
    "Math",
    []() -> std::shared_ptr {
      return std::make_shared();
    }
  );
  ```

  

## Using your Hybrid Objects

And finally, to initialize `HybridMath` from JS you just need to call `createHybridObject`:

```ts
export const MathModule = NitroModules.createHybridObject("Math")
const result = MathModule.add(5, 7)
```

:::note
If this call failed, you might have forgotten to register your Hybrid Object's constructor in the `HybridObjectRegistry`.
:::

---

## View Components

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# View Components

Nitro provides first-class support for creating React Native Views.

Such views can be rendered within React Native apps using [Fabric](https://reactnative.dev/architecture/fabric-renderer), and are backed by a C++ ShadowNode.
The key difference to a Fabric view is that it uses Nitro for prop parsing, which is more lightweight, performant and flexible.

:::note
Nitro Views require **react-native 0.78.0** or higher, and require the new architecture.
:::

## Create a Nitro View

### 1. Declaration

To create a new Nitro View, declare it's props and methods in a `*.nitro.ts` file, and create a type that specializes `HybridView` - here `CameraView`:

```ts title="Camera.nitro.ts"
import type { HybridView, HybridViewProps, HybridViewMethods } from 'react-native-nitro-modules'

export interface CameraProps extends HybridViewProps {
  enableFlash: boolean
}
export interface CameraMethods extends HybridViewMethods { }

// highlight-next-line
export type CameraView = HybridView
```

### 2. Code Generation

Then, run [nitrogen](nitrogen):

  
    ```sh
    npx nitro-codegen
    ```
  
  
    ```sh
    yarn nitro-codegen
    ```
  
  
    ```sh
    pnpm nitro-codegen
    ```
  
  
    ```sh
    bun nitro-codegen
    ```
  

This will create a C++ ShadowNode, with an iOS (Swift) and Android (Kotlin) interface, just like any other [Hybrid Object](hybrid-objects).
Additionally, a view config (`CameraViewConfig.json`) will be generated - this is required by Fabric.

### 3. Implementation

Now it's time to implement the View - simply create a new Swift/Kotlin class/file, extend from `HybridCameraViewSpec` and implement your `.enableFlash` property, as well as the common `.view` accessor:

  
    ```swift title="HybridCameraView.swift"
    class HybridCameraView : HybridCameraViewSpec {
      // Props
      var enableFlash: Bool = false

      // View
      var view: UIView = UIView()
    }
    ```
  
  
    ```kotlin title="HybridCameraView.kt"
    class HybridCameraView(val context: ThemedReactContext) : HybridCameraViewSpec() {
      // Props
      override var enableFlash: Boolean = false

      // View
      override val view: View = View(context)
    }
    ```
  

### 4. Autolink

Just like any other Hybrid Object, add the Hybrid View to your `nitro.json`'s autolinking configuration:

```json title="nitro.json"
{
  // ...
  "autolinking": {
    "CameraView": {
      "swift": "HybridCameraView",
      "kotlin": "HybridCameraView"
    }
  }
}
```

Now run nitrogen again.

#### 4.1. Android: Register the View Manager

On Android, you need to register the generated view manager in your React Native package:

```java title="CameraPackage.java"
// ...
public class CameraPackage extends TurboReactPackage {
  // ...

  @Override
  public List createViewManagers(@NonNull ReactApplicationContext reactContext) {
    List viewManagers = new ArrayList();
    // diff-add
    viewManagers.add(new HybridCameraViewManager());
    return viewManagers;
  }
}
```

### 5. Initialization

Then, to use the view in JavaScript, use `getHostComponent(..)`:

```ts
import { getHostComponent } from 'react-native-nitro-modules'
import CameraViewConfig from '../nitrogen/generated/shared/json/CameraViewConfig.json'

export const Camera = getHostComponent(
  'Camera',
  () => CameraViewConfig
)
```

### 6. Rendering

And finally, render it:

```jsx
function App() {
  return 
}
```

## Props

Since every `HybridView` is also a `HybridObject`, you can use any type that Nitro supports as a property - including custom types (`interface`), `ArrayBuffer`, and even other `HybridObject`s!

For example, a custom `` component can be used to render custom `Image` types:

```ts title="Image.nitro.ts"
export interface Image extends HybridObject {
  readonly width: number
  readonly height: number
  save(): Promise
}
```

```ts title="ImageView.nitro.ts"
import { type Image } from './Image.nitro.ts'
export interface ImageProps extends HybridViewProps {
  image: Image
}
export type ImageView = HybridView
```

Then;

```jsx
function App() {
  const image = await loadImage('https://...')
  return 
}
```

### Threading

Since Nitro bridges props directly to JS, you are responsible for ensuring thread-safety.
- If props are set normally via React, they will be set on the UI Thread.
- If the user sets props on the view `hybridRef` (e.g. also if the `HybridView` is passed to a `HybridObject` in native), props _could_ be set on a different Thread, like the JS Thread.

### Before/After update

To batch prop changes, you can override `beforeUpdate()` and `afterUpdate()` in your views:

  
    ```swift title="HybridCameraView.swift"
    class HybridCameraView : HybridCameraViewSpec {
      // View
      var view: UIView = UIView()

      func beforeUpdate() { }
      func afterUpdate() { }
    }
    ```
  
  
    ```kotlin title="HybridCameraView.kt"
    class HybridCameraView : HybridCameraViewSpec() {
      // View
      override val view: View = View(NitroModules.applicationContext)

      override fun beforeUpdate() { }
      override fun afterUpdate() { }
    }
    ```
  

### Callbacks have to be wrapped

Whereas Nitro allows passing JS functions to native code directly, React Native core doesn't allow that. Instead, functions are wrapped in an event listener registry, and a simple boolean is passed to the native side.
Unfortunately React Native's renderer does not allow changing this behaviour, so functions cannot be passed directly to Nitro Views. As a workaround, Nitro requires you to wrap each function in an object, which bypasses React Native's conversion.

So every function (`() => void`) has to be wrapped in an object with one key - `f` - which holds the function: `{ f: () => void }`

```tsx
export interface CameraProps extends HybridViewProps {
  onCaptured: (image: Image) => void
}
export type CameraView = HybridView

function App() {
  // diff-remove
  return  console.log(i)} />
  // diff-add
  return  console.log(i) }} />
}
```

:::info
We are working on a fix here: [facebook/react #32119](https://github.com/facebook/react/pull/32119)
:::

## Methods

Since every `HybridView` is also a `HybridObject`, methods can be directly called on the object.
Assuming our `` component has a `takePhoto()` function like so:

```ts
export interface CameraProps extends HybridViewProps { ... }
export interface CameraMethods extends HybridViewMethods {
  takePhoto(): Promise
}

export type CameraView = HybridView
```

To call the function, you would need to get a reference to the `HybridObject` first using `hybridRef`:

```jsx
function App() {
  return (
     {
          const image = ref.takePhoto()
        }
      }}
    />
  )
}
```

> Note: If you're wondering about the `{ f: ... }` syntax, see ["Callbacks have to be wrapped"](#callbacks-have-to-be-wrapped).

The `ref` from within `hybridRef`'s callback is pointing to the `HybridObject` directly - you can also pass this around freely.

---

## What is Nitro?

# What is Nitro?

Nitro is a framework for building powerful and fast native modules for JS.
Put simply, a JS object can be implemented in C++, Swift or Kotlin instead of JS by using Nitro.

While Nitro's primary environment is React Native, it also works in any other environment that uses JSI.

- A [**Nitro Module**](nitro-modules) is a library built with Nitro. It contains one or more **Hybrid Objects**.
- A [**Hybrid Object**](hybrid-objects) is a native object in Nitro, implemented in either C++, Swift or Kotlin.
- [**Nitrogen**](nitrogen) is a code-generator a library author can use to generate native bindings from a custom TypeScript interface.

```ts title="Math.nitro.ts"
interface Math extends HybridObject {
  readonly pi: number
  add(a: number, b: number): number
}
```

```swift title="HybridMath.swift"
class HybridMath : HybridMathSpec {
  var pi: Double {
    return Double.pi
  }
  func add(a: Double, b: Double) -> Double {
    return a + b
  }
}
```

This Hybrid Object can then be accessed directly from JS:

```ts
const math = NitroModules.createHybridObject('Math')
const result = math.add(5, 7)
```

## Performance

Nitro is all about **performance**. [This benchmark](https://github.com/mrousavy/NitroBenchmarks) compares the total execution time when calling a single native method 100.000 times:

  
    
    ExpoModules
    TurboModules
    NitroModules
  
  
    100.000x addNumbers(...)
    434.85ms
    115.86ms
    7.27ms
  
  
    100.000x addStrings(...)
    429.53ms
    179.02ms
    29.94ms
  

Note: These benchmarks only compare native method throughput in extreme cases, and do not necessarily reflect real world use-cases. In a real-world app, results may vary. See [NitroBenchmarks](https://github.com/mrousavy/NitroBenchmarks) for full context.

### Lightweight layer

While Nitro is built on top of JSI, the layer is very lightweight and efficient.
Many things like type-checking is compile-time only, and built with C++ templates or `constexpr` which introduces zero runtime overhead.

### Direct Swift &lt;&gt; C++ interop

Unlike Turbo- or Expo-Modules, Nitro-Modules does not use Objective-C at all.
Nitro is built using the new [Swift &lt;&gt; C++ interop](https://www.swift.org/documentation/cxx-interop/), which is close to zero-overhead.

### Uses `jsi::NativeState`

Hybrid Objects in Nitro are built on top of `jsi::NativeState`, which is more efficient than `jsi::HostObject`. Such objects have proper native prototypes, and their native memory size is known, which allows the garbage collector to properly clean up unused objects.

## Type Safety

Nitro Modules are **type-safe** and **null-safe**. By using Nitro's code-generator, [nitrogen](nitrogen), TypeScript specs are the single source of truth as generated native interfaces have to exactly represent the declared types.
If a function declares a `number`, you can only implement it on the native side as a `Double`, otherwise the app will not compile.

```ts title="Math.nitro.ts"
interface Math extends HybridObject {
  add(a: number, b: number): number
}
```

```swift title="HybridMath.swift"
class HybridMath : HybridMathSpec {
  func add(a: Double, b: Double) -> String {
// code-error
//  Compile-error: Expected Double! ^
    return a + b
  }
}
```

### Null-safety

There is no way for a Nitro Module to return a type that is not expected in TypeScript, which also guarantees null-safety.

```ts
interface Math extends HybridObject {
  getValue(): number
  getValueOrNull(): number | undefined
}
```

## Object-Oriented approach

Every Hybrid Object in Nitro is a native object, which can be created, passed around, and destroyed.

```ts
interface Image extends HybridObject {
  readonly width: number
  readonly height: number
  saveToFile(path: string): Promise
}

interface ImageEditor extends HybridObject {
  loadImage(path: string): Promise
  crop(image: Image, size: Size): Image
}
```

Functions (or "callbacks") are also first-class citizens of Nitro, which means they can safely be kept in memory, called as often as needed, and will automatically be cleaned up when no longer needed.
This is somewhat similar to how other frameworks (like Turbo-Modules) implement "events".

## Modern Languages

Nitro is a modern framework, built on top of modern languages like Swift and Kotlin.
It has first-class support for modern language features.

### Swift

Nitro bridges to Swift directly using the new highly efficient [Swift &lt;&gt; C++ interop](https://www.swift.org/documentation/cxx-interop/).

* **Protocols**: Every Hybrid Object's generated specification is a [Swift protocol](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols/).
* **Properties**: A getter (and setter) property can be implemented using [Swift properties](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/).
* **Async**/**Await**: Asynchronous functions can use Swift's new [async/await syntax](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/) using the `Promise.async` API.
* **No Objective-C**: Instead of bridging through Objective-C interfaces, Nitro bridges to Swift directly from C++.

### Kotlin

Nitro bridges to Kotlin directly using [fbjni](https://github.com/facebookincubator/fbjni).

* **Interfaces**: Every Hybrid Object's generated specification is a [Kotlin interface](https://kotlinlang.org/docs/interfaces.html).
* **Properties**: A getter (and setter) property can be implemented using [Kotlin properties](https://kotlinlang.org/docs/properties.html).
* **Coroutines**: Asynchronous functions can use Kotlin's [coroutine syntax](https://kotlinlang.org/docs/coroutines-overview.html) using the `Promise.async` API.
* **No Java**: Instead of requiring Java classes, Nitro bridges to Kotlin directly.

---

## Worklets/Threading

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Worklets/Threading

Nitro itself is fully runtime-agnostic, which means every [Hybrid Object](hybrid-objects) can be used from any JS Runtime or Worklet Context.

This allows the caller to call into native Nitro Modules from libraries like [react-native-worklets-core](https://github.com/margelo/react-native-worklets-core), or [react-native-reanimated](https://github.com/software-mansion/react-native-reanimated).
You can use a Nitro [Hybrid Object](hybrid-objects) on the default React JS context, on the UI context, or on any other background worklet context.

  
  ```ts
  const math = NitroModules.createHybridObject('Math')
  const boxed = NitroModules.box(math)

  const context = Worklets.createContext('DummyContext')
  context.runAsync(() => {
    'worklet'
    const unboxed = boxed.unbox()
    console.log(unboxed.add(5, 3)) // --> 8
  })
  ```
  
  
  ```ts
  const math = NitroModules.createHybridObject('Math')
  const boxed = NitroModules.box(math)

  runOnUI(() => {
    'worklet'
    const unboxed = boxed.unbox()
    console.log(unboxed.add(5, 3)) // --> 8
  })()
  ```
  

## Boxing

Since Nitro uses newer JSI APIs like `jsi::NativeState` - which current worklet libraries (like [react-native-worklets-core](https://github.com/margelo/react-native-worklets-core) or [react-native-reanimated](https://github.com/software-mansion/react-native-reanimated)) do not yet fully support - Hybrid Objects cannot yet be _directly_ used in worklet contexts - they have to be _boxed_.

A _boxed_ Hybrid Object is a native `jsi::HostObject`, which is supported by worklet libraries. The process is as following:

1. In the runtime your `HybridObject` was created in (probably the default runtime), call `NitroModules.box(...)` to box it.
2. The boxed result can be shared in any (worklet-)runtime if needed.
3. To use the original `HybridObject`, simply call `.unbox()` on it in the desired (worklet-)runtime.
4. The result of `.unbox()` is the original `HybridObject` - you can now call any methods on it as usual.

In future versions of [react-native-worklets-core](https://github.com/margelo/react-native-worklets-core) or [react-native-reanimated](https://github.com/software-mansion/react-native-reanimated) we expect fullly automatic `jsi::NativeState` support, which will make boxing obsolete.

## Dispatcher

All synchronous APIs of Nitro work âœ¨ automagically âœ¨ on any runtime, but asynchronous APIs (Promises and callbacks) require a `Dispatcher`.
If you call an asynchronous API on a runtime that Nitro doesn't know, it likely doesn't have a `Dispatcher`, so it doesn't know how to call back to the JS Thread after the asynchronous operation has finished (Promise resolve or callback call).

If **you** created that `jsi::Runtime`, you need to create a `Dispatcher` for it and implement `runSync` and `runAsync`:

```cpp
#include 
using namespace margelo::nitro;

class MyRuntimeDispatcher: public Dispatcher {
public:
  void runSync(std::function&& function) override;
  void runAsync(std::function&& function) override;
};
```

Then, simply install this `Dispatcher` into your runtime so Nitro can use it:

```cpp
auto myDispatcher = std::make_shared();
Dispatcher::installRuntimeGlobalDispatcher(myRuntime, myDispatcher);
```

This needs to be done once, ideally immediately as soon as possible after creating the `jsi::Runtime`.

Your `runSync` and `runAsync` implementations must run the given `function` on the same Thread that the `jsi::Runtime` was created on - see [`CallInvokerDispatcher.hpp`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/cpp/threading/CallInvokerDispatcher.hpp) for an example.
