# https://nitro.margelo.com/ llms.txt

## Fast and Flexible Nitro Modules
[Skip to main content](https://nitro.margelo.com/#__docusaurus_skipToContent_fallback)

![](https://nitro.margelo.com/assets/images/lightning-bolt-25058645733a4329a835fad14487463b.png)

### Mindblowingly Fast

Nitro Modules are built on top of a highly optimized JSI foundation that handles caching and property lookup really well. Nitro's communication layer is incredibly efficient and lightweight in memory!

![](https://nitro.margelo.com/assets/images/dna-495aa1de824f4e7efcd59e801b4998a5.png)

### Statically Typed

Nitro's code-generator ("Nitrogen") statically generates **type-safe** C++/Swift/Kotlin types from your TypeScript interfaces. This way you'll never pass wrong types, nulls or undefined again!

![](https://nitro.margelo.com/assets/images/spring-d3dde99226276cd3a76f75158af2ffd6.png)

### Powerful and Flexible

Similar to pure JavaScript objects, a "HybridObject" in Nitro can work with almost **all JavaScript types** such as primitives, typed- or untyped- objects, arrays and even variants or other native objects.

## React Native Module Comparison
[Skip to main content](https://nitro.margelo.com/docs/comparison#__docusaurus_skipToContent_fallback)

On this page

Nitro is not the only one of it's kind, but it's the most powerful, easiest to use and fastest solution. There's multiple other ways to build native modules for React Native:

- Nitro Modules
- [Turbo Modules](https://nitro.margelo.com/docs/comparison#turbo-modules)
- [Legacy Native Modules](https://nitro.margelo.com/docs/comparison#legacy-native-modules)
- [Expo Modules](https://nitro.margelo.com/docs/comparison#expo-modules)

## Benchmarks [​](https://nitro.margelo.com/docs/comparison\#benchmarks "Direct link to Benchmarks")

[This benchmark](https://github.com/mrousavy/NitroBenchmarks) compares the total execution time when calling a single native method 100.000 times:

|  | ExpoModules | TurboModules | NitroModules |
| --- | --- | --- | --- |
| 100.000x `addNumbers(...)` | 434.85ms | 115.86ms | **7.27ms** |
| 100.000x `addStrings(...)` | 429.53ms | 179.02ms | **29.94ms** |

Nitro is 59x faster than Expo Modules, and 15x faster than Turbo Modules in this specific benchmark.

It's not all about performance though - there are some key differences between Nitro-, Turbo- and Expo-Modules:

## Turbo Modules [​](https://nitro.margelo.com/docs/comparison\#turbo-modules "Direct link to Turbo Modules")

[Turbo Modules](https://github.com/reactwg/react-native-new-architecture/blob/main/docs/turbo-modules.md) are React Native's default framework for building native modules.
They use a code-generator called " [codegen](https://github.com/reactwg/react-native-new-architecture/blob/main/docs/codegen.md)" to convert Flow (or TypeScript) specs to native interfaces, similar to Nitro's nitrogen.

Nitro Module (Swift)

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  func add(a: Double, b: Double) -> Double {
    return a + b
  }
}

```

Turbo Module (Objective-C)

```codeBlockLines_AclH
@implementation RTNMath
RCT_EXPORT_MODULE()

- (NSNumber*)add:(NSNumber*)a b:(NSNumber*)b {
  double added = a.doubleValue + b.doubleValue;
  return [NSNumber numberWithDouble:added];
}
@end

```

Turbo Modules can be built with Objective-C for iOS and Java for Android, or C++ for cross-platform.

### Shipped with react-native core [​](https://nitro.margelo.com/docs/comparison\#shipped-with-react-native-core "Direct link to Shipped with react-native core")

Unlike Nitro, Turbo Modules are actually part of react-native core. This means, users don't have to install a single dependency to build- or use a Turbo Module.

### Implementation details [​](https://nitro.margelo.com/docs/comparison\#implementation-details "Direct link to Implementation details")

#### No Swift [​](https://nitro.margelo.com/docs/comparison\#no-swift "Direct link to No Swift")

There is no direct Swift support for Turbo Modules. You could bridge from Objective-C to Swift, but that would still always go through Objective-C, which is comparatively slower than bridging directly from C++ to Swift, like Nitro does.

JS

C++

Swift

Nitro Modules

JS

C++

Objective-C

Swift

Turbo Modules

#### No properties [​](https://nitro.margelo.com/docs/comparison\#no-properties "Direct link to No properties")

A Turbo Module does not provide a syntax for properties. Instead, conventional getter/setter methods have to be used.

Nitro Module (Swift)

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  var someValue: Double
}

```

Turbo Module (Objective-C)

```codeBlockLines_AclH
@implementation RTNMath {
  NSNumber* _someValue;
}
RCT_EXPORT_MODULE()

- (NSNumber*)getSomeValue {
  return _someValue;
}
- (void)setSomeValue:(NSNumber*)someValue {
  _someValue = someValue;
}
@end

```

#### Not object-oriented [​](https://nitro.margelo.com/docs/comparison\#not-object-oriented "Direct link to Not object-oriented")

While a Turbo Module can represent many types from JavaScript, there is no equivalent to Nitro's **Hybrid Object** in Turbo Modules. Instead, every Turbo Module is a singleton, and every native method is similar to a static method.

Native objects, like Image instances, can not be represented in Turbo Modules. Common workarounds include writing the image to a file, converting images to base64 strings, or using Blobs - which all introduce runtime overhead and performance hits _just to pass an image instance to JS_.

HybridImageEditor.swift

```codeBlockLines_AclH
class HybridImageEditor: HybridImageEditorSpec {
  func crop(image: HybridImage,
            size: Size) -> HybridImage {
    let original = image.cgImage
    let cropped = original.cropping(to: size)
    return HybridImage(cgImage: cropped)
  }
}

```

ImageEditor.mm

```codeBlockLines_AclH
@implementation ImageEditor
- (NSString*)crop:(NSString*)imageUri
             size:(CGRect)size {
  UIImage* image = [UIImage imageWithContentsOfFile:imageUri];
  CGImageRef cropped = CGImageCreateWithImageInRect([image CGImage], size);
  UIImage* croppedImage = [UIImage imageWithCGImage:cropped];
  CGImageRelease(cropped);

  NSString* fileName = [NSString stringWithFormat:@"%@.png", [[NSUUID UUID] UUIDString]];
  NSString* filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:fileName];
  NSData* pngData = UIImagePNGRepresentation(croppedImage);
  [pngData writeToFile:tempPath atomically:YES];
  return tempPath;
}
@end

```

Using native objects (like the `HybridImage`) directly is much more efficient and performant, as well as more convenient to use than to write everything to a file.

#### No tuples [​](https://nitro.margelo.com/docs/comparison\#no-tuples "Direct link to No tuples")

There are no tuples in Turbo Modules.

```codeBlockLines_AclH
type SomeTuple = [number, number]

```

#### No callbacks with return values [​](https://nitro.margelo.com/docs/comparison\#no-callbacks-with-return-values "Direct link to No callbacks with return values")

Turbo Modules do not allow JS callbacks to return a value.

```codeBlockLines_AclH
type SomeCallback = () => number

```

#### Events [​](https://nitro.margelo.com/docs/comparison\#events "Direct link to Events")

Since functions are not first-class citizens in Turbo Modules, you cannot hold onto a JavaScript callback in native code and call it more often, like you could in Nitro.
Instead, Turbo Modules has "Events". Events are essentially just native functions that notify JS and potentially also pass data to JS more often.

HybridMath.swift (Nitro)

```codeBlockLines_AclH
class Math: MathSpec {
  var listeners: [(String) -> Void] = []
  func addListener(listener: (String) -> Void) {
    listeners.add(listener)
  }

  func onSomethingChanged() {
    for listener in listeners {
      listener("something changed!")
    }
  }
}

```

RTNMath.mm (Turbo)

```codeBlockLines_AclH
@implementation RTNMath
RCT_EXPORT_MODULE();

- (NSArray<NSString *> *)supportedEvents {
  return @[@"onSomethingChanged"];
}

- (void)onSomethingChanged {
  NSString* message = @"something changed!";
  [self sendEventWithName:@"onSomethingChanged"\
                     body:@{@"msg": message}];
}
@end

```

Events are untyped and have to be natively defined via `supportedEvents`. In Nitro, this would be fully typesafe as functions are first class citizens. (see `addListener(..)`)

#### HostObject vs NativeState [​](https://nitro.margelo.com/docs/comparison\#hostobject-vs-nativestate "Direct link to HostObject vs NativeState")

As of today, Turbo Modules are implemented using `jsi::HostObject`, whereas Nitro Modules are built with `jsi::NativeState`.
NativeState has been proven to be much more efficient and performant, as property- and method-access is much faster - it can be properly cached by the JS Runtime and does not involve any virtual/Proxy-like accessors.

Additionally, Nitro Modules properly set up memory pressure per object, so the JS garbage collector actually knows a native module's memory size and can properly delete them when no longer needed. This is not the case with Turbo Modules.

### Codegen [​](https://nitro.margelo.com/docs/comparison\#codegen "Direct link to Codegen")

Codegen is similar to Nitrogen as it also generates native interfaces from TypeScript specifications. This ensures type-safety on the JavaScript side, as specs have to be implemented on the native side in order for the app to build successfully. This prevents any wrong type errors and ensures undefined/null-safety.

Nitrogen

```codeBlockLines_AclH
export interface Math extends HybridObject {
  add(a: number, b: number): Promise<number>
}

export const Math =
  NitroModules.createHybridObject<Math>("Math")

```

Codegen

```codeBlockLines_AclH
export interface Spec extends TurboModule {
  add(a: number, b: number): Promise<number>;
}

export const Math =
  TurboModuleRegistry.get<Spec>("RTNMath")
    as Spec | null;

```

#### Codegen runs on app build [​](https://nitro.margelo.com/docs/comparison\#codegen-runs-on-app-build "Direct link to Codegen runs on app build")

Nitrogen is executed explicitly by the library developer and all generated interfaces are part of the npm package to always ship a working solution.
Codegen on the other hand runs on app build, which causes specs to always be re-generated for every app.

#### Codegen cannot resolve imports [​](https://nitro.margelo.com/docs/comparison\#codegen-cannot-resolve-imports "Direct link to Codegen cannot resolve imports")

While Nitrogen can properly resolve imports from other files, Codegen can not.

#### Codegen supports Flow [​](https://nitro.margelo.com/docs/comparison\#codegen-supports-flow "Direct link to Codegen supports Flow")

Codegen also supports [Flow](https://flow.org/), while Nitrogen doesn't.

## Legacy Native Modules [​](https://nitro.margelo.com/docs/comparison\#legacy-native-modules "Direct link to Legacy Native Modules")

Prior to [Turbo Modules](https://nitro.margelo.com/docs/comparison#turbo-modules), React Native provided a default approach for building native modules which was just called ["Native Modules"](https://reactnative.dev/docs/native-modules-intro).
Instead of using JSI, Native Modules were built on top of a communication layer that sent events and commands using JSON messages, both asynchronous and batched.

Because Turbo Modules are just an evolution of Native Modules, their API is almost identical:

Nitro Module (Swift)

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  func add(a: Double, b: Double) -> Double {
    return a + b
  }
}

```

Native Module (Objective-C)

```codeBlockLines_AclH
@implementation RTNMath
RCT_EXPORT_MODULE()

- (NSNumber*)add:(NSNumber*)a b:(NSNumber*)b {
  double added = a.doubleValue + b.doubleValue;
  return [NSNumber numberWithDouble:added];
}
@end

```

They are now deprecated in favor of [Turbo Modules](https://nitro.margelo.com/docs/comparison#turbo-modules).

## Expo Modules [​](https://nitro.margelo.com/docs/comparison\#expo-modules "Direct link to Expo Modules")

[Expo Modules](https://docs.expo.dev/modules/overview/) is an easy to use API to build native modules by Expo.

Unlike both Nitro- and Turbo-, Expo-Modules does not have a code-generator.
All native modules are considered untyped, and TypeScript definitions can be written afterwards.

An Expo Module can be written using a declarative syntax ( _DSL_) where each function and property is declared inside the `definition()` function:

Nitro Module (Swift)

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  func add(a: Double, b: Double) -> Double {
    return a + b
  }
}

```

Expo Module (Swift)

```codeBlockLines_AclH
public class MathModule: Module {
  public func definition() -> ModuleDefinition {
    Name("Math")

    Function("add") { (a: Double,
                       b: Double) -> Double in
      return a + b
    }
  }
}

```

### Implementation details [​](https://nitro.margelo.com/docs/comparison\#implementation-details-1 "Direct link to Implementation details")

#### Swift support [​](https://nitro.margelo.com/docs/comparison\#swift-support "Direct link to Swift support")

Just like Nitro, Expo Modules are written in Swift, instead of Objective-C.

Expo Modules however bridge through Objective-C, whereas Nitro bridges to Swift directly (using the new Swift <> C++ interop) which has proven to be much more efficient.

JS

C++

Swift

Nitro Modules

JS

C++

Objective-C

Swift

Expo Modules

#### Kotlin coroutines [​](https://nitro.margelo.com/docs/comparison\#kotlin-coroutines "Direct link to Kotlin coroutines")

Asynchronous functions can be implemented using Kotlin coroutines, which is a convenient pattern for asynchronous code. This is similar to Nitro's `Promise.async` function.

HybridMath.kt (Nitro)

```codeBlockLines_AclH
class HybridMath: HybridMathSpec {
  override fun doSomeWork(): Promise<String> {
    return Promise.async {
      delay(5000)
      return@async "done!"
    }
  }
}

```

Math.kt (Expo)

```codeBlockLines_AclH
class MathModule: Module {
  override fun definition() = ModuleDefinition {
    Name("Math")

    AsyncFunction("doSomeWork") Coroutine {
      delay(5000)
      return@Coroutine "done!"
    }
  }
}

```

#### Properties [​](https://nitro.margelo.com/docs/comparison\#properties "Direct link to Properties")

Expo Modules supports getting and setting properties, just like Nitro.

#### Events [​](https://nitro.margelo.com/docs/comparison\#events-1 "Direct link to Events")

Similar to Turbo Modules, Expo Modules also uses Events to notify JS about any changes on the native side.

HybridMath.swift (Nitro)

```codeBlockLines_AclH
class Math: MathSpec {
  var listeners: [(String) -> Void] = []
  func addListener(listener: (String) -> Void) {
    listeners.add(listener)
  }

  func onSomethingChanged() {
    for listener in listeners {
      listener("something changed!")
    }
  }
}

```

MathModule.swift (Expo)

```codeBlockLines_AclH
let SOMETHING_CHANGED = "onSomethingChanged"
public class MathModule: Module {
  public func definition() -> ModuleDefinition {
    Name("Math")
    Events(SOMETHING_CHANGED)
  }

  private func onSomethingChanged() {
    sendEvent(SOMETHING_CHANGED, [\
      "message": "something changed!"\
    ])
  }
}

```

#### HostObject vs NativeState [​](https://nitro.margelo.com/docs/comparison\#hostobject-vs-nativestate-1 "Direct link to HostObject vs NativeState")

As of today, Expo Modules are implemented using `jsi::HostObject`, whereas Nitro Modules are built with `jsi::NativeState`.
NativeState has been proven to be much more efficient and performant, as property- and method-access is much faster - it can be properly cached by the JS Runtime and does not involve any virtual/Proxy-like accessors.

Expo-Modules do however properly set memory pressure of native objects, just like in Nitro.

#### Shared Objects [​](https://nitro.margelo.com/docs/comparison\#shared-objects "Direct link to Shared Objects")

Expo Modules has a concept of "shared objects", which is similar to Hybrid Objects in Nitro.

note

I could not find any documentation for Shared Objects, so I cannot really compare them here.

#### No tuples [​](https://nitro.margelo.com/docs/comparison\#no-tuples-1 "Direct link to No tuples")

There are no tuples in Expo Modules.

```codeBlockLines_AclH
type SomeTuple = [number, number]

```

#### No callbacks with return values [​](https://nitro.margelo.com/docs/comparison\#no-callbacks-with-return-values-1 "Direct link to No callbacks with return values")

Expo-Modules does not allow JS callbacks to return a value.

```codeBlockLines_AclH
type SomeCallback = () => number

```

### No code-generator [​](https://nitro.margelo.com/docs/comparison\#no-code-generator "Direct link to No code-generator")

Since Expo Modules does not provide a code-generator, all native modules are untyped by default.
While TypeScript definitions can be written afterwards, it is possible that the handwritten TypeScript definitions are out of sync with the actual native types due to a user-error, especially when it comes to null-safety.

Math.ts (Expo JS side)

```codeBlockLines_AclH
interface Math {
  add(a: number, b: number | undefined): number
//  b can be undefined here: ^
}

const math = ...
math.add(5, undefined)
//          ^ will throw at runtime!

```

HybridMath.swift (Expo Native side)

```codeBlockLines_AclH
public class MathModule: Module {
  public func definition() -> ModuleDefinition {
    Name("Math")

    Function("add") { (a: Double,
                       b: Double) -> Double in
// b CANNOT be undefined here: ^
      return a + b
    }
  }
}

```

Note: It is also possible for Nitro specs to go out of sync, but only if you forget to run Nitrogen. In both cases, it's a user-error - one more likely than the other.

## Supported Types [​](https://nitro.margelo.com/docs/comparison\#supported-types "Direct link to Supported Types")

| JS Type | Expo Modules | Turbo Modules | Nitro Modules |
| --- | --- | --- | --- |
| `number` | ✅ | ✅ | ✅ |
| `boolean` | ✅ | ✅ | ✅ |
| `string` | ✅ | ✅ | ✅ |
| `bigint` | ✅ | ❌ | ✅ |
| `object` | ✅ | ✅ | ✅ |
| `T?` | ✅ | ✅ | ✅ |
| `T[]` | ✅ | ✅ | ✅ |
| `Promise<T>` | ✅ | ✅ | ✅ |
| `(T...) => void` | ✅ | ✅ | ✅ |
| `(T...) => R` | ❌ | ❌ | ✅ |
| `[A, B, C, ...]` | ❌ | ❌ | ✅ |
| `A | B | C | ...` | ✅ | ❌ | ✅ |
| `Record<string, T>` | ❌ (no codegen) | ❌ | ✅ |
| `ArrayBuffer` | ✅ | ❌ | ✅ |
| ..any `HybridObject` | ✅ | ❌ | ✅ |
| ..any `interface` | ❌ (no codegen) | ✅ | ✅ |
| ..any `enum` | ❌ (no codegen) | ✅ | ✅ |
| ..any `union` | ❌ (no codegen) | ❌ | ✅ |

## Correctness of this page [​](https://nitro.margelo.com/docs/comparison\#correctness-of-this-page "Direct link to Correctness of this page")

Note: If anything is missing, wrong, or outdated, please let me know so I can correct it immediately!

- [Benchmarks](https://nitro.margelo.com/docs/comparison#benchmarks)
- [Turbo Modules](https://nitro.margelo.com/docs/comparison#turbo-modules)
  - [Shipped with react-native core](https://nitro.margelo.com/docs/comparison#shipped-with-react-native-core)
  - [Implementation details](https://nitro.margelo.com/docs/comparison#implementation-details)
    - [No Swift](https://nitro.margelo.com/docs/comparison#no-swift)
    - [No properties](https://nitro.margelo.com/docs/comparison#no-properties)
    - [Not object-oriented](https://nitro.margelo.com/docs/comparison#not-object-oriented)
    - [No tuples](https://nitro.margelo.com/docs/comparison#no-tuples)
    - [No callbacks with return values](https://nitro.margelo.com/docs/comparison#no-callbacks-with-return-values)
    - [Events](https://nitro.margelo.com/docs/comparison#events)
    - [HostObject vs NativeState](https://nitro.margelo.com/docs/comparison#hostobject-vs-nativestate)
  - [Codegen](https://nitro.margelo.com/docs/comparison#codegen)
    - [Codegen runs on app build](https://nitro.margelo.com/docs/comparison#codegen-runs-on-app-build)
    - [Codegen cannot resolve imports](https://nitro.margelo.com/docs/comparison#codegen-cannot-resolve-imports)
    - [Codegen supports Flow](https://nitro.margelo.com/docs/comparison#codegen-supports-flow)
- [Legacy Native Modules](https://nitro.margelo.com/docs/comparison#legacy-native-modules)
- [Expo Modules](https://nitro.margelo.com/docs/comparison#expo-modules)
  - [Implementation details](https://nitro.margelo.com/docs/comparison#implementation-details-1)
    - [Swift support](https://nitro.margelo.com/docs/comparison#swift-support)
    - [Kotlin coroutines](https://nitro.margelo.com/docs/comparison#kotlin-coroutines)
    - [Properties](https://nitro.margelo.com/docs/comparison#properties)
    - [Events](https://nitro.margelo.com/docs/comparison#events-1)
    - [HostObject vs NativeState](https://nitro.margelo.com/docs/comparison#hostobject-vs-nativestate-1)
    - [Shared Objects](https://nitro.margelo.com/docs/comparison#shared-objects)
    - [No tuples](https://nitro.margelo.com/docs/comparison#no-tuples-1)
    - [No callbacks with return values](https://nitro.margelo.com/docs/comparison#no-callbacks-with-return-values-1)
  - [No code-generator](https://nitro.margelo.com/docs/comparison#no-code-generator)
- [Supported Types](https://nitro.margelo.com/docs/comparison#supported-types)
- [Correctness of this page](https://nitro.margelo.com/docs/comparison#correctness-of-this-page)

## Nitro JSON Configuration
[Skip to main content](https://nitro.margelo.com/docs/configuration-nitro-json#__docusaurus_skipToContent_fallback)

On this page

[Nitrogen](https://nitro.margelo.com/docs/nitrogen) requires a `nitro.json` file to be configured at the root of each [Nitro Module](https://nitro.margelo.com/docs/nitro-modules).

```codeBlockLines_AclH
{
  "$schema": "https://nitro.margelo.com/nitro.schema.json",
  "cxxNamespace": ["$$cxxNamespace$$"],
  "ios": {
    "iosModuleName": "$$iosModuleName$$"
  },
  "android": {
    "androidNamespace": ["$$androidNamespace$$"],
    "androidCxxLibName": "$$androidCxxLibName$$"
  },
  "autolinking": {},
  "ignorePaths": ["**/node_modules"],
  "createGitAttributes": true
}

```

Nitrogen parses this file with Zod, see [`NitroUserConfig.ts`](https://github.com/mrousavy/nitro/blob/main/packages/nitrogen/src/config/NitroUserConfig.ts) for more information.

## `cxxNamespace` [​](https://nitro.margelo.com/docs/configuration-nitro-json\#cxxnamespace "Direct link to cxxnamespace")

The `cxxNamespace` is the C++ namespace that all C++ specs will be generated in. It is always relative to `margelo::nitro`, and can also have multiple sub-namespaces:

```codeBlockLines_AclH
{
  "cxxNamespace": ["math", "extra"]
}

```

```codeBlockLines_AclH
namespace margelo::nitro::math::extra {
  // ...generated classes
}

```

## `ios` [​](https://nitro.margelo.com/docs/configuration-nitro-json\#ios "Direct link to ios")

Settings specifically for the iOS platform.

### `iosModuleName` [​](https://nitro.margelo.com/docs/configuration-nitro-json\#iosmodulename "Direct link to iosmodulename")

The `iosModuleName` represents the name of the [clang module](https://clang.llvm.org/docs/Modules.html) that will be emitted by the Swift compiler.
When this Nitro Module is a CocoaPod, this is the same thing as the `$$iosModuleName$$.podspec`'s name:

```codeBlockLines_AclH
{
  "ios": {
    "iosModuleName": "NitroMath"
  }
}

```

NitroMath.podspec

```codeBlockLines_AclH
Pod::Spec.new do |s|
  s.name         = "NitroMath"
  # ...

```

## `android` [​](https://nitro.margelo.com/docs/configuration-nitro-json\#android "Direct link to android")

Settings specifically for the Android platform.

### `androidNamespace` [​](https://nitro.margelo.com/docs/configuration-nitro-json\#androidnamespace "Direct link to androidnamespace")

The `androidNamespace` represents the package namespace in which all Java/Kotlin files are generated and written in.
Similar to the `cxxNamespace`, this is always relative to `margelo.nitro`, and can also have multiple sub-namespaces.

In most cases, you should keep this in sync with the `namespace` specified in your `build.gradle`.

```codeBlockLines_AclH
{
  "android": {
    "androidNamespace": ["math", "extra"]
  }
}

```

```codeBlockLines_AclH
package com.margelo.nitro.image

// ...

```

### `androidCxxLibName` [​](https://nitro.margelo.com/docs/configuration-nitro-json\#androidcxxlibname "Direct link to androidcxxlibname")

The `androidCxxLibName` represents the name of the native C++ library that JNI will load to connect Java/Kotlin to C++.

When this Nitro Module is using CMake, this is the same thing as the library defined in `CMakeLists.txt`.
Nitro will load this library at runtime using `System.loadLibrary`.

```codeBlockLines_AclH
{
  "android": {
    "androidCxxLibName": "NitroMath"
  }
}

```

```codeBlockLines_AclH
project(NitroMath)
add_library(NitroMath SHARED
        src/main/cpp/cpp-adapter.cpp
        ../cpp/HybridMath.cpp
)

```

## `autolinking` [​](https://nitro.margelo.com/docs/configuration-nitro-json\#autolinking "Direct link to autolinking")

Contains configuration for all [Hybrid Objects](https://nitro.margelo.com/docs/hybrid-objects) that should be autolinked by Nitrogen.

All Hybrid Objects specified here must follow these requirements:

- They must be default-constructible. That means they need a public constructor that takes zero arguments.
If you have a Hybrid Object that is not default-constructible (e.g. `Image` needs a `path` or `url` argument), consider creating a factory Hybrid Object that can initialize instances of your Hybrid Object internally.
- C++ Hybrid Objects must be declared in a file that has the same name as the Hybrid Object (for `HybridMath`, create `HybridMath.hpp`).
- C++ Hybrid Objects must be scoped in the namespace specified in [`cxxNamespace`](https://nitro.margelo.com/docs/configuration-nitro-json#cxxnamespace).
- Kotlin Hybrid Objects must be inside the package namespace specified in [`androidNamespace`](https://nitro.margelo.com/docs/configuration-nitro-json#androidnamespace).
- Kotlin Hybrid Objects should be annotated with `@DoNotStrip` to prevent them from being compiled out when using ProGuard.

Nitrogen will then generate the following code:

```codeBlockLines_AclH
{
  "autolinking": {
    "Math": {
      "cpp": "HybridMath"
    }
  }
}

```

```codeBlockLines_AclH
HybridObjectRegistry::registerHybridObjectConstructor(
  "Math",
  []() -> std::shared_ptr<HybridObject> {
    return std::make_shared<HybridMath>();
  }
);

```

Here, the Hybrid Object " `Math`" is autolinked to create an instance of `HybridMath`, a C++ class. Instead of `cpp`, you can also use `swift` or `kotlin`.

## `ignorePaths` [​](https://nitro.margelo.com/docs/configuration-nitro-json\#ignorepaths "Direct link to ignorepaths")

Configures the TypeScript parser to ignore specific given paths when looking for `*.nitro.ts` specs.

By default, this is empty ( `[]`), but it can be set to ignore paths like `["node_modules", "lib"]`.

## `createGitAttributes` [​](https://nitro.margelo.com/docs/configuration-nitro-json\#creategitattributes "Direct link to creategitattributes")

Configures whether a `.gitattributes` file will be generated in the `nitrogen/generated/` directory to mark files as [`linguist-generated`](https://docs.github.com/en/repositories/working-with-files/managing-files/customizing-how-changed-files-appear-on-github) for GitHub.

- [`cxxNamespace`](https://nitro.margelo.com/docs/configuration-nitro-json#cxxnamespace)
- [`ios`](https://nitro.margelo.com/docs/configuration-nitro-json#ios)
  - [`iosModuleName`](https://nitro.margelo.com/docs/configuration-nitro-json#iosmodulename)
- [`android`](https://nitro.margelo.com/docs/configuration-nitro-json#android)
  - [`androidNamespace`](https://nitro.margelo.com/docs/configuration-nitro-json#androidnamespace)
  - [`androidCxxLibName`](https://nitro.margelo.com/docs/configuration-nitro-json#androidcxxlibname)
- [`autolinking`](https://nitro.margelo.com/docs/configuration-nitro-json#autolinking)
- [`ignorePaths`](https://nitro.margelo.com/docs/configuration-nitro-json#ignorepaths)
- [`createGitAttributes`](https://nitro.margelo.com/docs/configuration-nitro-json#creategitattributes)

## Contributing to Nitro
[Skip to main content](https://nitro.margelo.com/docs/contributing#__docusaurus_skipToContent_fallback)

On this page

If you encounter issues with Nitro, want to fix a bug, or reproduce a bug in the example app, you'd need to clone the repo and get it running first.

The nitro repo is a Bun monorepo, and is set up like this:

- `example/`: A react-native app that uses `react-native-nitro-modules` and `react-native-nitro-image`.
- `packages/`
  - `/nitrogen/`: The Node app that generates Nitro bindings. On npm, it is called `nitro-codegen`.
  - `/react-native-nitro-modules/`: The core Nitro Modules library which contains mostly C++ code.
  - `/react-native-nitro-image/`: An example Nitro Module library that contains a lot of test code.
  - `/template/`: A template for a Nitro Module library.

## Run Nitro Example [​](https://nitro.margelo.com/docs/contributing\#run-nitro-example "Direct link to Run Nitro Example")

### 1\. Set up your development environment [​](https://nitro.margelo.com/docs/contributing\#1-set-up-your-development-environment "Direct link to 1. Set up your development environment")

You need:

- [Bun](https://bun.sh/)
- [CocoaPods](https://cocoapods.org/)
- Xcode 16 or higher
- Android Studio

### 2\. Clone the repo [​](https://nitro.margelo.com/docs/contributing\#2-clone-the-repo "Direct link to 2. Clone the repo")

Clone [mrousavy/ **nitro**](https://github.com/mrousavy/nitro) using git, and navigate into the `nitro` folder using Terminal.

### 3\. Install dependencies [​](https://nitro.margelo.com/docs/contributing\#3-install-dependencies "Direct link to 3. Install dependencies")

Using Bun, install all required dependencies:

```codeBlockLines_AclH
bun install
bun run build

```

#### 3.1. (Optional) Install iOS dependencies [​](https://nitro.margelo.com/docs/contributing\#31-optional-install-ios-dependencies "Direct link to 3.1. (Optional) Install iOS dependencies")

If you want to work on the iOS codebase, you also need to install the Pods:

```codeBlockLines_AclH
cd example
bundle install
bun pods

```

### 4\. Run the app [​](https://nitro.margelo.com/docs/contributing\#4-run-the-app "Direct link to 4. Run the app")

After installing all dependencies, you can run the React Native app in `example/`:

- iOS
- Android

1. Open `example/ios/NitroExample.xcworkspace` in Xcode
2. Select your target (iPhone Simulator)
3. Click Run

1. Open `example/android` in Android Studio
2. Click Gradle Sync
3. Click Run

## Reproduce something in the Nitro Example app [​](https://nitro.margelo.com/docs/contributing\#reproduce-something-in-the-nitro-example-app "Direct link to Reproduce something in the Nitro Example app")

With most issue reports, it is required to reproduce the issue in the Nitro example app ( `example/`).
Whether it's a build error, a nitrogen error, or a runtime error, there needs to be a way to reproduce it here.
Usually, you can reproduce issues like this:

1. Fork the repository
2. Change the code to reproduce the issue
3. Create a PR to the **nitro** repository which demonstrates the issue

### Reproduce a build error [​](https://nitro.margelo.com/docs/contributing\#reproduce-a-build-error "Direct link to Reproduce a build error")

If you encounter a build error, compare your setup to the setup in `example/`.
For example, if you have a different setting in your `Podfile`, try changing it here in Nitro `example/` as well to see if it builds here. Submit a PR with the change required to make it fail, and see if the CI fails to build.

### Reproduce a nitrogen bug [​](https://nitro.margelo.com/docs/contributing\#reproduce-a-nitrogen-bug "Direct link to Reproduce a nitrogen bug")

The Nitro `example/` app uses a Nitro Module ( `packages/react-native-nitro-image/`) which acts as an example contains a lot of test code, like `src/specs/TestObject.nitro.ts` ( [link](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-image/src/specs/TestObject.nitro.ts)). If you change something in `TestObject.nitro.ts`, make sure to run nitrogen:

```codeBlockLines_AclH
bun image specs

```

### Reproduce a runtime error [​](https://nitro.margelo.com/docs/contributing\#reproduce-a-runtime-error "Direct link to Reproduce a runtime error")

Submit a PR to the nitro repository that demonstrates this runtime error or crash in the Nitro `example/` app.

## Run Nitro Docs [​](https://nitro.margelo.com/docs/contributing\#run-nitro-docs "Direct link to Run Nitro Docs")

The Nitro docs ( [nitro.margelo.com](https://nitro.margelo.com/)) are built with [Docusaurus](https://docusaurus.io/).

To run the Nitro docs, follow these steps:

### 1\. Install dependencies [​](https://nitro.margelo.com/docs/contributing\#1-install-dependencies "Direct link to 1. Install dependencies")

Navigate into the `docs/` folder, and install all dependencies:

```codeBlockLines_AclH
cd docs
bun install

```

### 2\. Run docs (dev) [​](https://nitro.margelo.com/docs/contributing\#2-run-docs-dev "Direct link to 2. Run docs (dev)")

Then, just run the docs development server using the docusaurus command:

```codeBlockLines_AclH
bun start

```

## Linting [​](https://nitro.margelo.com/docs/contributing\#linting "Direct link to Linting")

We value code quality and consistent styling.

For JS/TS, we use ESLint and Prettier:

```codeBlockLines_AclH
bun lint

```

For C++, we use clang-format:

```codeBlockLines_AclH
bun lint-cpp

```

Make sure to lint your files everytime before creating a PR. This is also enforced in the CI, but linting beforehand also applies auto-fixes.

- [Run Nitro Example](https://nitro.margelo.com/docs/contributing#run-nitro-example)
  - [1\. Set up your development environment](https://nitro.margelo.com/docs/contributing#1-set-up-your-development-environment)
  - [2\. Clone the repo](https://nitro.margelo.com/docs/contributing#2-clone-the-repo)
  - [3\. Install dependencies](https://nitro.margelo.com/docs/contributing#3-install-dependencies)
    - [3.1. (Optional) Install iOS dependencies](https://nitro.margelo.com/docs/contributing#31-optional-install-ios-dependencies)
  - [4\. Run the app](https://nitro.margelo.com/docs/contributing#4-run-the-app)
- [Reproduce something in the Nitro Example app](https://nitro.margelo.com/docs/contributing#reproduce-something-in-the-nitro-example-app)
  - [Reproduce a build error](https://nitro.margelo.com/docs/contributing#reproduce-a-build-error)
  - [Reproduce a nitrogen bug](https://nitro.margelo.com/docs/contributing#reproduce-a-nitrogen-bug)
  - [Reproduce a runtime error](https://nitro.margelo.com/docs/contributing#reproduce-a-runtime-error)
- [Run Nitro Docs](https://nitro.margelo.com/docs/contributing#run-nitro-docs)
  - [1\. Install dependencies](https://nitro.margelo.com/docs/contributing#1-install-dependencies)
  - [2\. Run docs (dev)](https://nitro.margelo.com/docs/contributing#2-run-docs-dev)
- [Linting](https://nitro.margelo.com/docs/contributing#linting)

## Nitro Installation Guide
[Skip to main content](https://nitro.margelo.com/docs/entry-point#__docusaurus_skipToContent_fallback)

On this page

Nitro is built on top of JSI - while the primary target is React Native, Nitro even works on any other target that provides JSI.

## React Native's Entry Point [​](https://nitro.margelo.com/docs/entry-point\#react-natives-entry-point "Direct link to React Native's Entry Point")

In React Native apps, Nitro makes use of the [autolinking functionality](https://github.com/react-native-community/cli/blob/main/docs/autolinking.md) provided by RN CLI.

Nitro itself is a react-native library - either a Native Module (old arch) or a Turbo Module (new arch) - with a single native method: `install()`.
This native method will be called from JS when importing `react-native-nitro-modules`, so it will always happen before trying to use the `NitroModules` JS object.

## Manually registering Nitro [​](https://nitro.margelo.com/docs/entry-point\#manually-registering-nitro "Direct link to Manually registering Nitro")

If you are not within a typical React Native environment (e.g. a brownfield app, an out-of-tree platform, or simply a pure JSI environment), you can also use Nitro Modules by just installing Nitro manually.

After creating your `jsi::Runtime` and an instance of `Dispatcher`, simply call `margelo::nitro::install()`:

```codeBlockLines_AclH
#include <jsi/jsi.h>
#include <NitroModules/InstallNitro.hpp>
#include <NitroModules/Dispatcher.hpp>

jsi::Runtime& runtime = ...
std::shared_ptr<Dispatcher> dispatcher = ...
margelo::nitro::install(runtime, dispatcher);

```

Your `Dispatcher` implementation must properly implement `runAsync` and `runSync` to schedule calls on a Thread that can safely access the `jsi::Runtime`.

tip

If your Runtime can be accessed from any Thread, you can also skip Thread-hops here and just call the functions directly in your Dispatcher.

### No Dispatcher [​](https://nitro.margelo.com/docs/entry-point\#no-dispatcher "Direct link to No Dispatcher")

Nitro can also be installed without a `Dispatcher`:

```codeBlockLines_AclH
#include <jsi/jsi.h>
#include <NitroModules/InstallNitro.hpp>

jsi::Runtime& runtime = ...
margelo::nitro::install(runtime);

```

In this case, all synchronous methods and properties remain in-tact, but any asynchronous hybrid methods ( `Promise`) or callbacks will throw an error that Nitro does not have a `Dispatcher` to get back to the JS Thread.

- [React Native's Entry Point](https://nitro.margelo.com/docs/entry-point#react-natives-entry-point)
- [Manually registering Nitro](https://nitro.margelo.com/docs/entry-point#manually-registering-nitro)
  - [No Dispatcher](https://nitro.margelo.com/docs/entry-point#no-dispatcher)

## Hybrid Objects Errors
[Skip to main content](https://nitro.margelo.com/docs/errors#__docusaurus_skipToContent_fallback)

On this page

Every method in a [Hybrid Object](https://nitro.margelo.com/docs/hybrid-objects) can throw an error using the language-default error throwing feature:

- Swift
- Kotlin
- C++

HybridMath.swift

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  public func add(a: Double, b: Double) throws -> Double {
    if a < 0 || b < 0 {
      throw RuntimeError.error("Value cannot be negative!")
    }
    return a + b
  }
}

```

HybridMath.kt

```codeBlockLines_AclH
class HybridMath : HybridMathSpec() {
  override fun add(a: Double, b: Double): Double {
    if (a < 0 || b < 0) {
      throw Error("Value cannot be negative!")
    }
    return a + b
  }
}

```

HybridMath.hpp

```codeBlockLines_AclH
class HybridMath: public HybridMathSpec {
  double add(double a, double b) override {
    if (a < 0 || b < 0) {
      throw std::runtime_error("Value cannot be negative!");
    }
    return a + b;
  }
};

```

Errors will be propagated upwards to JS and can be caught just like any other kind of error using `try`/ `catch`:

```codeBlockLines_AclH
`Math.add(...)`: Value cannot be negative!

```

### Promise rejections [​](https://nitro.margelo.com/docs/errors\#promise-rejections "Direct link to Promise rejections")

Promises can also be rejected using error throwing syntax on the native side:

- Swift
- Kotlin
- C++

HybridMath.swift

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  public func add(a: Double, b: Double) throws -> Promise<Double> {
    return Promise.async {
      if a < 0 || b < 0 {
        throw RuntimeError.error("Value cannot be negative!")
      }
      return a + b
    }
  }
}

```

HybridMath.kt

```codeBlockLines_AclH
class HybridMath : HybridMathSpec() {
  override fun add(a: Double, b: Double): Promise<Double> {
    return Promise.async {
      if (a < 0 || b < 0) {
        throw Error("Value cannot be negative!")
      }
      return@async a + b
    }
  }
}

```

HybridMath.hpp

```codeBlockLines_AclH
class HybridMath: public HybridMathSpec {
  std::shared_ptr<Promise<double>> add(double a, double b) override {
    return Promise<double>::async([=]() -> double {
      if (a < 0 || b < 0) {
        throw std::runtime_error("Value cannot be negative!");
      }
      return a + b;
    });
  }
};

```

Promise rejections are handled as usual using the `.catch`, or `await`/ `catch` syntax in JS:

```codeBlockLines_AclH
const math = // ...
try {
  await math.add(-5, -1)
} catch (error) {
  console.log(error)
}

```

- [Promise rejections](https://nitro.margelo.com/docs/errors#promise-rejections)

## Nitro Modules Installation
[Skip to main content](https://nitro.margelo.com/docs/for-users#__docusaurus_skipToContent_fallback)

If you are using a library that is built with Nitro, all you need to do is install the Nitro Modules core package:

- npm
- yarn
- pnpm
- bun

```codeBlockLines_AclH
npm i react-native-nitro-modules
cd ios && pod install

```

```codeBlockLines_AclH
yarn add react-native-nitro-modules
cd ios && pod install

```

```codeBlockLines_AclH
pnpm add react-native-nitro-modules
cd ios && pod install

```

```codeBlockLines_AclH
bun i react-native-nitro-modules
cd ios && pod install

```

Nitro Modules are lightweight, yet powerful native bindings to native code, so thank the library author for choosing Nitro to make your app faster! 😄

## Hybrid Objects Overview
[Skip to main content](https://nitro.margelo.com/docs/hybrid-objects#__docusaurus_skipToContent_fallback)

On this page

A **Hybrid Object** is a native object that can be used from JS like any other object.
They can have natively implemented methods, as well as properties (get + set).

Math.nitro.ts

```codeBlockLines_AclH
interface Math extends HybridObject {
  readonly pi: number
  add(a: number, b: number): number
}

```

HybridMath.swift

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  var pi: Double {
    return Double.pi
  }
  func add(a: Double, b: Double) -> Double {
    return a + b
  }
}

```

## Working with Hybrid Objects [​](https://nitro.margelo.com/docs/hybrid-objects\#working-with-hybrid-objects "Direct link to Working with Hybrid Objects")

If a Hybrid Object is _autolinked_ (see [" **Nitrogen**: 5\. Register the Hybrid Objects"](https://nitro.margelo.com/docs/nitrogen#5-register-the-hybrid-objects)), it can be created from JS via `createHybridObject<T>(..)`:

```codeBlockLines_AclH
const math = NitroModules.createHybridObject<Math>("Math")
const result = math.add(5, 7)

```

To enable the usage of `new` and `instanceof`, you can use the `getHybridObjectConstructor<T>(..)` helper method:

```codeBlockLines_AclH
const HybridMath = getHybridObjectConstructor<Math>("Math")
const math = new HybridMath()
const isMath = math instanceof HybridMath

```

A Hybrid Object can also create other Hybrid Objects:

Image.nitro.ts

```codeBlockLines_AclH
interface Image extends HybridObject {
  readonly width: number
  readonly height: number
  saveToFile(path: string): Promise<void>
}

interface ImageFactory extends HybridObject {
  loadImageFromWeb(path: string): Promise<Image>
  loadImageFromFile(path: string): Image
  loadImageFromResources(name: string): Image
}

```

## Base Methods [​](https://nitro.margelo.com/docs/hybrid-objects\#base-methods "Direct link to Base Methods")

Every Hybrid Object has base methods and properties, like `name`, `toString()` and `equals(..)`:

```codeBlockLines_AclH
const math = NitroModules.createHybridObject<Math>("Math")
const anotherMath = math

console.log(math.name) // "Math"
console.log(math.toString()) // "[HybridObject Math]"
console.log(math.equals(anotherMath)) // true

```

### `dispose()` [​](https://nitro.margelo.com/docs/hybrid-objects\#dispose "Direct link to dispose")

Additionally, every Hybrid Object has a `dispose()` method.
Usually, you should not need to manually dispose Hybrid Objects as the JS garbage collector will delete any unused objects anyways.
Also, most Hybrid Objects in Nitro are just statically exported singletons, in which case they should never be deleted throughout the app's lifetime.

In some rare, often performance-critical- cases it is beneficial to eagerly destroy any Hybrid Objects, which is why `dispose()` exists.
For example, [VisionCamera](https://github.com/mrousavy/react-native-vision-camera) uses `dispose()` to clean up already processed Frames to make room for new incoming Frames:

```codeBlockLines_AclH
const onFrameListener = (frame: Frame) => {
  doSomeProcessing(frame)
  frame.dispose()
}

```

## Implementation [​](https://nitro.margelo.com/docs/hybrid-objects\#implementation "Direct link to Implementation")

Hybrid Objects can be implemented in C++, Swift or Kotlin:

- With Nitrogen ✨
- Manually

Nitrogen will ✨ automagically ✨ generate native specifications for each Hybrid Object based on a given TypeScript definition:

Math.nitro.ts

```codeBlockLines_AclH
interface Math extends HybridObject<{ ios: 'swift', android: 'kotlin' }> {
  readonly pi: number
  add(a: number, b: number): number
}

```

Running [nitrogen](https://nitro.margelo.com/docs/nitrogen) will generate the native Swift and Kotlin protocol " `HybridMathSpec`", that now just needs to be implemented in a class:

- Swift
- Kotlin

HybridMath.swift

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  public var pi: Double {
    return Double.pi
  }
  public func add(a: Double, b: Double) throws -> Double {
    return a + b
  }
}

```

HybridMath.kt

```codeBlockLines_AclH
class HybridMath : HybridMathSpec() {
  override var pi: Double
    get() = Double.PI

  override fun add(a: Double, b: Double): Double {
    return a + b
  }
}

```

For more information, see the [Nitrogen documentation](https://nitro.margelo.com/docs/nitrogen).

To implement a Hybrid Object without nitrogen, you just need to create a C++ class that inherits from the [`HybridObject`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/cpp/core/HybridObject.hpp) base class, and override `loadHybridMethods()`:

HybridMath.hpp

```codeBlockLines_AclH
class HybridMath: public HybridObject {
public:
  HybridMath(): HybridObject(NAME) { }

public:
  double add(double a, double b);

protected:
  void loadHybridMethods() override;

private:
  static constexpr auto NAME = "Math";
};

```

HybridMath.cpp

```codeBlockLines_AclH
double HybridMath::add(double a, double b) {
  return a + b;
}

void HybridMath::loadHybridMethods() {
  // register base methods (toString, ...)
  HybridObject::loadHybridMethods();
  // register custom methods (add)
  registerHybrids(this, [](Prototype& proto) {
    proto.registerHybridMethod(
      "add",
      &HybridMath::add
    );
  });
}

```

A Hybrid Object should also override `getExternalMemorySize()` to properly reflect native memory size:

```codeBlockLines_AclH
class HybridMath: public HybridObject {
public:
  // ...
  size_t getExternalMemorySize() override {
    return sizeOfSomeImageWeAllocated;
  }
}

```

Optionally, you can also override `toString()` and `dispose()` for custom behaviour.

## Inheritance [​](https://nitro.margelo.com/docs/hybrid-objects\#inheritance "Direct link to Inheritance")

As the name suggests, Hybrid Objects are object-oriented, meaning they have full support for inheritance and abstraction.
A Hybrid Object can either inherit from other Hybrid Objects, or satisfy a common interface.

- With Nitrogen ✨
- Manually

### Inherit from other Hybrid Objects [​](https://nitro.margelo.com/docs/hybrid-objects\#inherit-from-other-hybrid-objects "Direct link to Inherit from other Hybrid Objects")

Each Hybrid Object has a proper JavaScript prototype chain, created automatically and lazily.
When a Hybrid Object inherits from another Hybrid Object, it extends the prototype chain:

```codeBlockLines_AclH
interface Media extends HybridObject {
  readonly width: number
  readonly height: number
  saveToFile(): Promise<void>
}

type ImageFormat = 'jpg' | 'png'
interface Image extends HybridObject, Media {
  readonly format: ImageFormat
}

const image1 = NitroModules.createHybridObject<Image>('Image')
const image2 = NitroModules.createHybridObject<Image>('Image')

```

HybridObject (4 props)

Media (3 props)

Image (1 prop)

const image1

const image2

### Inherit from a common interface [​](https://nitro.margelo.com/docs/hybrid-objects\#inherit-from-a-common-interface "Direct link to Inherit from a common interface")

With Nitrogen, you can define a common TypeScript interface that multiple Hybrid Objects inherit from.
This non-HybridObject interface ( `Media`) will not be a separate type on the native side, but all Hybrid Objects that extend from it will satisfy the TypeScript type:

```codeBlockLines_AclH
interface Media {
  readonly width: number
  readonly height: number
}

interface Image extends HybridObject, Media {}
interface Video extends HybridObject, Media {}

```

### Inherit from other Hybrid Objects [​](https://nitro.margelo.com/docs/hybrid-objects\#inherit-from-other-hybrid-objects-1 "Direct link to Inherit from other Hybrid Objects")

In C++, inheriting from a Hybrid Object is as simple as extending it, and adding the prototype in `loadHybridMethods()`:

HybridMath.hpp

```codeBlockLines_AclH
class HybridImage: public HybridMedia {
public:
  // Image specific methods
  ImageFormat getFormat();

  void loadHybridMethods() override {
    // register base prototype
    HybridMedia::loadHybridMethods();
    // register all methods we add here
    registerHybrids(this, [](Prototype& prototype) {
      prototype.registerHybridGetter("format", &HybridImage::getFormat);
    });
  }
};

```

### Override base methods/properties [​](https://nitro.margelo.com/docs/hybrid-objects\#override-base-methodsproperties "Direct link to Override base methods/properties")

In a C++ Hybrid Object, you can also override base methods and properties, even with different types:

HybridMath.hpp

```codeBlockLines_AclH
class HybridImage: public HybridMedia {
public:
  // Image specific methods
  std::string getSize();

  void loadHybridMethods() override {
    // register base protoype
    HybridMedia::loadHybridMethods();
    // HybridMedia already has .width, but it's a number.
    // We override it to be a string in HybridImage.
    registerHybrids(this, [](Prototype& prototype) {
      prototype.registerHybridGetter("width", &HybridImage::getSize);
    });
  }
}

```

The HybridImage's prototype's prototype (= HybridMedia's prototype) will still contain the original method/property.

## Memory Size ( `memorySize`) [​](https://nitro.margelo.com/docs/hybrid-objects\#memory-size-memorysize "Direct link to memory-size-memorysize")

Since it's implementation is in native code, the JavaScript runtime does not know the actual memory size of a Hybrid Object.
Nitro allows Hybrid Objects to declare their memory size via the `memorySize`/ `getExternalMemorySize()` accessors, which can account for any external heap allocations you perform:

```codeBlockLines_AclH
class HybridImage : HybridImageSpec {
  private var cgImage: CGImage
  public var memorySize: Int {
    let imageSize = cgImage.width * cgImage.height * cgImage.bytesPerPixel
    return imageSize
  }
}

```

Any unused `Image` objects can now be deleted sooner by the JS garbage collector, preventing memory pressures or frequent garbage collector calls.

tip

It is safe to return `0` here, but recommended to somewhat closely estimate the actual size of native object if possible.

### Raw JSI methods [​](https://nitro.margelo.com/docs/hybrid-objects\#raw-jsi-methods "Direct link to Raw JSI methods")

If for some reason Nitro's typing system is not sufficient in your case, you can also create a raw JSI method using `registerRawHybridMethod(...)` to directly work with the `jsi::Runtime` and `jsi::Value` types:

HybridMath.hpp

```codeBlockLines_AclH
class HybridMath: HybridMathSpec {
public:
  jsi::Value sayHello(jsi::Runtime& runtime,
                      const jsi::Value& thisValue,
                      const jsi::Value* args,
                      size_t count);

  void loadHybridMethods() override {
    // register base protoype
    HybridMathSpec::loadHybridMethods();
    // register all methods we override here
    registerHybrids(this, [](Prototype& prototype) {
      prototype.registerRawHybridMethod("sayHello", 0, &HybridMath::sayHello);
    });
  }
}

```

- [Working with Hybrid Objects](https://nitro.margelo.com/docs/hybrid-objects#working-with-hybrid-objects)
- [Base Methods](https://nitro.margelo.com/docs/hybrid-objects#base-methods)
  - [`dispose()`](https://nitro.margelo.com/docs/hybrid-objects#dispose)
- [Implementation](https://nitro.margelo.com/docs/hybrid-objects#implementation)
- [Inheritance](https://nitro.margelo.com/docs/hybrid-objects#inheritance)
  - [Inherit from other Hybrid Objects](https://nitro.margelo.com/docs/hybrid-objects#inherit-from-other-hybrid-objects)
  - [Inherit from a common interface](https://nitro.margelo.com/docs/hybrid-objects#inherit-from-a-common-interface)
  - [Inherit from other Hybrid Objects](https://nitro.margelo.com/docs/hybrid-objects#inherit-from-other-hybrid-objects-1)
  - [Override base methods/properties](https://nitro.margelo.com/docs/hybrid-objects#override-base-methodsproperties)
- [Memory Size ( `memorySize`)](https://nitro.margelo.com/docs/hybrid-objects#memory-size-memorysize)
  - [Raw JSI methods](https://nitro.margelo.com/docs/hybrid-objects#raw-jsi-methods)

## Nitro Minimum Requirements
[Skip to main content](https://nitro.margelo.com/docs/minimum-requirements#__docusaurus_skipToContent_fallback)

Nitro is a Framework built on top of newer APIs like `jsi::NativeState`.
To use Nitro, make sure your app meets the minimum requirements:

- iOS
- Android

- react-native 0.75 or higher
- Xcode 16 or higher

- react-native 0.75 or higher
- `compileSdkVersion` 34 or higher

## Nitro Modules Guide
[Skip to main content](https://nitro.margelo.com/docs/nitro-modules#__docusaurus_skipToContent_fallback)

On this page

A **Nitro Module** is a library built with Nitro. It may contain one or more [**Hybrid Objects**](https://nitro.margelo.com/docs/hybrid-objects).

## Structure [​](https://nitro.margelo.com/docs/nitro-modules\#structure "Direct link to Structure")

A Nitro Module contains the usual react-native library structure, with `ios/` and `android/` folders, a `package.json`, and a `*.podspec` file for iOS.
In addition to the base react-native library template, a Nitro Module also contains:

- A TypeScript setup
- A `nitro.json` configuration file

## Creating a Nitro Module [​](https://nitro.margelo.com/docs/nitro-modules\#creating-a-nitro-module "Direct link to Creating a Nitro Module")

### 1\. Initialize the template [​](https://nitro.margelo.com/docs/nitro-modules\#1-initialize-the-template "Direct link to 1. Initialize the template")

To create a new Nitro Module, simply run `nitro-codegen init <moduleName>`:

```codeBlockLines_AclH
npx nitro-codegen@latest init react-native-math

```

### 2\. Implement your Hybrid Objects [​](https://nitro.margelo.com/docs/nitro-modules\#2-implement-your-hybrid-objects "Direct link to 2. Implement your Hybrid Objects")

Once you set up the library, you can start implementing your Hybrid Objects!

- With Nitrogen ✨
- Manually

With [Nitrogen](https://nitro.margelo.com/docs/nitrogen) you can ✨ automagically ✨ generate all native interfaces from your TypeScript definitions.
After implementing the generated specs, register them using the `HybridObjectRegistry`.

See [Hybrid Objects (Implementation)](https://nitro.margelo.com/docs/hybrid-objects#implementation) for more information.

If you don't want to use Nitrogen, simply create your native C++ classes that inherit from `HybridObject`, and register them using the `HybridObjectRegistry`.

See [Hybrid Objects (Implementation)](https://nitro.margelo.com/docs/hybrid-objects#implementation) for more information.

### 3\. Set up an example app [​](https://nitro.margelo.com/docs/nitro-modules\#3-set-up-an-example-app "Direct link to 3. Set up an example app")

After creating a Nitro Module, it's time to set up an example app to test your library!

- Expo
- Bare RN

```codeBlockLines_AclH
npx create-expo-app@latest

```

```codeBlockLines_AclH
npx @react-native-community/cli@latest init NitroMathExample

```

tip

The Hybrid Objects from your Nitro Module will be registered in the `HybridObjectRegistry`. This registration process needs to be called from somewhere:

- In React Native, this happens in the `*Package.java` file which calls `.initializeNative()`.
- If you are not using React Native, you need to manually call `.initializeNative()` in your library's entry point.

- [Structure](https://nitro.margelo.com/docs/nitro-modules#structure)
- [Creating a Nitro Module](https://nitro.margelo.com/docs/nitro-modules#creating-a-nitro-module)
  - [1\. Initialize the template](https://nitro.margelo.com/docs/nitro-modules#1-initialize-the-template)
  - [2\. Implement your Hybrid Objects](https://nitro.margelo.com/docs/nitro-modules#2-implement-your-hybrid-objects)
  - [3\. Set up an example app](https://nitro.margelo.com/docs/nitro-modules#3-set-up-an-example-app)

## Nitrogen Code Generator
[Skip to main content](https://nitro.margelo.com/docs/nitrogen#__docusaurus_skipToContent_fallback)

On this page

**Nitrogen** is Nitro's code-generator. It parses TypeScript code using an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) parser to generate native interfaces from TypeScript definitions.

Math.nitro.ts

```codeBlockLines_AclH
interface Math extends HybridObject {
  readonly pi: number
  add(a: number, b: number): number
}

```

HybridMathSpec.swift (generated)

```codeBlockLines_AclH
protocol HybridMathSpec: HybridObject {
  var pi: Double { get }
  func add(a: Double, b: Double) -> Double
}

```

When `HybridMathSpec` is not implemented properly on the native side (e.g. if `add(..)` is missing, or if a type is incorrect), **the app will not compile**, which ensures full **type-safety** and **null-safety** at compile-time.

## Nitrogen is optional [​](https://nitro.margelo.com/docs/nitrogen\#nitrogen-is-optional "Direct link to Nitrogen is optional")

Nitrogen is a fully optional CLI that does some of the work for you.
You can also build Nitro Modules and create Hybrid Objects without nitrogen, by just calling the `registerHybrids` method yourself.

## Who uses Nitrogen? [​](https://nitro.margelo.com/docs/nitrogen\#who-uses-nitrogen "Direct link to Who uses Nitrogen?")

Nitrogen should be used by library-authors, and generated specs should be committed to the repository/package.

If you build an app that uses libraries built with Nitro, **you do not need to run nitrogen yourself**.

## Configuration [​](https://nitro.margelo.com/docs/nitrogen\#configuration "Direct link to Configuration")

Nitrogen should be installed as a dev-dependency in the Nitro Module (library).

- npm
- yarn
- pnpm
- bun

```codeBlockLines_AclH
npm i nitro-codegen --save-dev

```

```codeBlockLines_AclH
yarn add nitro-codegen -D

```

```codeBlockLines_AclH
pnpm add nitro-codegen -D

```

```codeBlockLines_AclH
bun i nitro-codegen -d

```

warning

Nitrogen is currently named `nitro-codegen` instead of `nitrogen` on npm.

Each Nitro Module needs to have a `nitro.json` configuration file.

Create a `nitro.json` file in the root directory of your Nitro Module (next to `package.json`), and add the following content:

nitro.json

```codeBlockLines_AclH
{
  "$schema": "https://nitro.margelo.com/nitro.schema.json",
  "cxxNamespace": ["math"],
  "ios": {
    "iosModuleName": "NitroMath"
  },
  "android": {
    "androidNamespace": ["math"],
    "androidCxxLibName": "NitroMath"
  },
  "autolinking": {}
}

```

Tweak your module name and namespaces as needed.

## Usage [​](https://nitro.margelo.com/docs/nitrogen\#usage "Direct link to Usage")

Nitrogen parses all TypeScript files that end in `.nitro.ts`.

### 1\. Write TypeScript specs [​](https://nitro.margelo.com/docs/nitrogen\#1-write-typescript-specs "Direct link to 1. Write TypeScript specs")

For example, let's create `Math.nitro.ts`:

Math.nitro.ts

```codeBlockLines_AclH
import { type HybridObject } from 'react-native-nitro-modules'

interface Math extends HybridObject<{ ios: 'swift', android: 'kotlin' }> {
  add(a: number, b: number): number
}

```

### 2\. Generate native specs [​](https://nitro.margelo.com/docs/nitrogen\#2-generate-native-specs "Direct link to 2. Generate native specs")

Now run nitrogen:

- npm
- yarn
- pnpm
- bun

```codeBlockLines_AclH
npx nitro-codegen

```

```codeBlockLines_AclH
yarn nitro-codegen

```

```codeBlockLines_AclH
pnpm nitro-codegen

```

```codeBlockLines_AclH
bun nitro-codegen

```

warning

Nitrogen is currently named `nitro-codegen` instead of `nitrogen` on npm.

This will always generate a shared C++ interface, and then optionall also Swift and Kotlin sub-classes. The specs go into `./nitrogen/generated/`:

```codeBlockLines_AclH
🔧  Loading nitro.json config...
🚀  Nitrogen runs at ~/Projects/nitro/example/dummy
    🔍  Nitrogen found 1 spec in ~/Projects/nitro/example/dummy
⏳  Parsing Math.nitro.ts...
    ⚙️  Generating specs for HybridObject "Math"...
        shared: Generating C++ code...
⛓️   Setting up build configs for autolinking...
🎉  Generated 1/1 HybridObject in 0.6s!
💡  Your code is in ./nitrogen/generated
‼️  Added 8 files - you need to run `pod install`/sync gradle to update files!

```

important

You should push the files in `./nitrogen/generated/` to git, and make sure those files are part of your npm package.
This way your library will always ship a working package as a whole (including generated interfaces), and the user does not need to do anything else than to install your package.

### 3\. Add generated sources to your library [​](https://nitro.margelo.com/docs/nitrogen\#3-add-generated-sources-to-your-library "Direct link to 3. Add generated sources to your library")

All the generated sources ( `./nitrogen/generated/`) need to be part of your library's code - so we need to add it to the iOS/Android build files.

- With the Nitro template
- Manually

If you created a library using the [Nitro Module template](https://github.com/mrousavy/nitro/tree/main/packages/template), your library already includes nitrogen's generated sources.

#### iOS [​](https://nitro.margelo.com/docs/nitrogen\#ios "Direct link to iOS")

On iOS, you need to call `add_nitrogen_files(...)` from your library's `.podspec`. Put this at the very end of your spec declaration:

```codeBlockLines_AclH
Pod::Spec.new do |s|
  # ...
  load 'nitrogen/generated/ios/NitroExample+autolinking.rb'
  add_nitrogen_files(s)
end

```

#### Android [​](https://nitro.margelo.com/docs/nitrogen\#android "Direct link to Android")

On Android, you first need to add the autogenerated Java/Kotlin sources to your `build.gradle`. Put this at the top of your `build.gradle`, right after any other `apply` calls:

```codeBlockLines_AclH
apply from: '../nitrogen/generated/android/NitroExample+autolinking.gradle'

```

Then, add the autogenerated C++ sources to your `CMakeLists.txt`. Put this somewhere **after** `add_library(...)`:

```codeBlockLines_AclH
include(${CMAKE_SOURCE_DIR}/../nitrogen/generated/android/NitroExample+autolinking.cmake)

```

tip

Replace `NitroExample` with your Nitro Module's name as defined in your `nitro.json`.

### 4\. Implement the Hybrid Objects [​](https://nitro.margelo.com/docs/nitrogen\#4-implement-the-hybrid-objects "Direct link to 4. Implement the Hybrid Objects")

To implement `Math` now, you just need to implement the spec:

- Swift
- Kotlin
- C++

HybridMath.swift

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  public func add(a: Double, b: Double) throws -> Double {
    return a + b
  }
}

```

HybridMath.kt

```codeBlockLines_AclH
class HybridMath : HybridMathSpec() {
  override fun add(a: Double, b: Double): Double {
    return a + b
  }
}

```

HybridMath.hpp

```codeBlockLines_AclH
class HybridMath: public HybridMathSpec {
public:
  HybridMath(): HybridObject(TAG) {}
public:
  double add(double a, double b) override;
};

```

HybridMath.cpp

```codeBlockLines_AclH
double HybridMath::add(double a, double b) {
  return a + b;
}

```

### 5\. Register the Hybrid Objects [​](https://nitro.margelo.com/docs/nitrogen\#5-register-the-hybrid-objects "Direct link to 5. Register the Hybrid Objects")

Nitro needs to be able to initialize an instance of your Hybrid Object - so we need to tell it how to do that.
In your `nitro.json`, register `HybridMath` in the `"autolinking"` section:

- Swift/Kotlin
- C++

```codeBlockLines_AclH
{
  ...
  "autolinking": {
    "Math": {
      "swift": "HybridMath",
      "kotlin": "HybridMath"
    }
  }
}

```

```codeBlockLines_AclH
{
  ...
  "autolinking": {
    "Math": {
      "cpp": "HybridMath"
    }
  }
}

```

Make sure `HybridMath` is default-constructible and scoped inside the correct namespace/package/file, **then run Nitrogen**.

#### 5.1. Initialize Android (C++) [​](https://nitro.margelo.com/docs/nitrogen\#51-initialize-android-c "Direct link to 5.1. Initialize Android (C++)")

- With the Nitro template
- Manually

If you created a library using the [Nitro Module template](https://github.com/mrousavy/nitro/tree/main/packages/template), your library already initializes the C++ autolinking process from your `*Package.java` and `OnLoad.cpp` files.

In your JNI OnLoad function ( `OnLoad.cpp` or `cpp-adapter.cpp`), initialize your module:

cpp-adapter.cpp

```codeBlockLines_AclH
#include <jni.h>
#include "NitroMathOnLoad.hpp"

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*) {
  return margelo::nitro::math::initialize(vm);
}

```

Then, to actually load and initialize the C++ part of your library (which calls `JNI_OnLoad` from above), call `initializeNative()` from your library's entry point ( `*Package.java`):

NitroMathPackage.java

```codeBlockLines_AclH
public class NitroMathPackage extends TurboReactPackage {
  // ...
  static {
    NitroMathOnLoad.initializeNative();
  }
}

```

#### 5.2. (Optional) ProGuard [​](https://nitro.margelo.com/docs/nitrogen\#52-optional-proguard "Direct link to 5.2. (Optional) ProGuard")

If you are using ProGuard on Android, make sure to add a `@DoNotStrip` annotation above your `HybridMath` class (and constructor) so Nitro can construct it from C++ in release builds.

### 6\. Initialize the Hybrid Objects [​](https://nitro.margelo.com/docs/nitrogen\#6-initialize-the-hybrid-objects "Direct link to 6. Initialize the Hybrid Objects")

And finally, to initialize `HybridMath` from JS you just need to call `createHybridObject`:

```codeBlockLines_AclH
export const MathModule = NitroModules.createHybridObject<Math>("Math")
const result = MathModule.add(5, 7)

```

- [Nitrogen is optional](https://nitro.margelo.com/docs/nitrogen#nitrogen-is-optional)
- [Who uses Nitrogen?](https://nitro.margelo.com/docs/nitrogen#who-uses-nitrogen)
- [Configuration](https://nitro.margelo.com/docs/nitrogen#configuration)
- [Usage](https://nitro.margelo.com/docs/nitrogen#usage)
  - [1\. Write TypeScript specs](https://nitro.margelo.com/docs/nitrogen#1-write-typescript-specs)
  - [2\. Generate native specs](https://nitro.margelo.com/docs/nitrogen#2-generate-native-specs)
  - [3\. Add generated sources to your library](https://nitro.margelo.com/docs/nitrogen#3-add-generated-sources-to-your-library)
  - [4\. Implement the Hybrid Objects](https://nitro.margelo.com/docs/nitrogen#4-implement-the-hybrid-objects)
  - [5\. Register the Hybrid Objects](https://nitro.margelo.com/docs/nitrogen#5-register-the-hybrid-objects)
  - [6\. Initialize the Hybrid Objects](https://nitro.margelo.com/docs/nitrogen#6-initialize-the-hybrid-objects)

## Nitro Performance Tips
[Skip to main content](https://nitro.margelo.com/docs/performance-tips#__docusaurus_skipToContent_fallback)

On this page

While Nitro is already insanely fast, there are some things you can do that affect the performance of your library.
Here are some tips to make your library even faster.

## Avoid dynamic types [​](https://nitro.margelo.com/docs/performance-tips\#avoid-dynamic-types "Direct link to Avoid dynamic types")

Any dynamic types require runtime type checking, and cannot be optimized as good as statically known types (compile-time).

### Untyped Maps [​](https://nitro.margelo.com/docs/performance-tips\#untyped-maps "Direct link to Untyped Maps")

An [untyped map](https://nitro.margelo.com/docs/types/untyped-maps) ( `AnyMap`) is not only untyped, but also in-efficient. If you can, avoid untyped maps:

Bad ❌

```codeBlockLines_AclH
interface BadDatabase extends HybridObject {
  getUser(): AnyMap
}

```

Good ✅

```codeBlockLines_AclH
interface User {
  name: string
  age: number
}
interface GoodDatabase extends HybridObject {
  getUser(): User
}

```

In some cases (e.g. network requests) you do not know the shape of your data, like in a JSON web-request.
In this case, it might make sense to use `ArrayBuffer` or `string`, and parse the data on the JS side using `JSON.parse` \- benchmark your code (before vs after) to see if this optimization makes sense for you.

### Variants [​](https://nitro.margelo.com/docs/performance-tips\#variants "Direct link to Variants")

[Variants](https://nitro.margelo.com/docs/types/variants) ( `A | B`) are dynamic types. Each time you pass a variant to native, Nitro has to check it's type at runtime - is it `A` or `B`?
Those type-checks are very efficient so this is considered a micro-optimization, but if you can, avoid variants like so:

Bad ❌

```codeBlockLines_AclH
interface BadDatabase extends HybridObject {
  set(value: number | string): void
}

```

Good ✅

```codeBlockLines_AclH
interface GoodDatabase extends HybridObject {
  setNumber(value: number): void
  setString(value: string): void
}

```

## Avoid unnecessary objects [​](https://nitro.margelo.com/docs/performance-tips\#avoid-unnecessary-objects "Direct link to Avoid unnecessary objects")

It is a common pattern to wrap everything in an object in JavaScript.
In Nitro, every object gets it's own struct and has to be allocated.
On iOS this performance impact is almost zero, but on Android the struct is a heap-allocation.

If you can, avoid unnecessarily wrapping everything in objects, and flatten the types out in the function signature:

Bad ❌

```codeBlockLines_AclH
interface SetPayload {
  key: string
  value: string
  onCompleted: () => void
}
interface BadDatabase extends HybridObject {
  set(payload: SetPayload): void
}

```

Good ✅

```codeBlockLines_AclH
interface GoodDatabase extends HybridObject {
  set(key: string,
      value: string,
      onCompleted: () => void): void
}

```

## Use Threading/Asynchronous Promises [​](https://nitro.margelo.com/docs/performance-tips\#use-threadingasynchronous-promises "Direct link to Use Threading/Asynchronous Promises")

By default, every function in Nitro is fully synchronous.
If your function takes long to execute, the JS Thread can not do any other work in the meantime.

In such cases, mark your function asynchronous by returning a [`Promise`](https://nitro.margelo.com/docs/types/promises), which you can then use to run the heavy processing code on a different thread:

Bad ❌

```codeBlockLines_AclH
interface BadDatabase extends HybridObject {
  writeLargeData(data: string): void
}

```

Good ✅

```codeBlockLines_AclH
interface GoodDatabase extends HybridObject {
  writeLargeData(data: string): Promise<void>
}

```

Keep in mind that switching to a different Thread on the native side introduces a small overhead by itself. This only benefits performance if the actual computation inside the function body takes longer than the thread-switch.

## Use `ArrayBuffer` for large data [​](https://nitro.margelo.com/docs/performance-tips\#use-arraybuffer-for-large-data "Direct link to use-arraybuffer-for-large-data")

For large data sets, conventional [arrays](https://nitro.margelo.com/docs/types/arrays) are in-efficient as each value has to be copied individually.
In contrast to conventional arrays, [Array Buffers](https://nitro.margelo.com/docs/types/array-buffers) are zero-copy, meaning native memory can be directly shared to JS without copying the data.

For example, to return a large list of numbers we could use [array buffers](https://nitro.margelo.com/docs/types/array-buffers) ( `Float64Array`) instead of [arrays](https://nitro.margelo.com/docs/types/arrays):

Bad ❌

```codeBlockLines_AclH
interface BadDatabase extends HybridObject {
  getAsBlob(): number[]
}

```

Good ✅

```codeBlockLines_AclH
interface GoodDatabase extends HybridObject {
  getAsBlob(): ArrayBuffer
}

```

## Use Hybrid Objects to implement proxy-results [​](https://nitro.margelo.com/docs/performance-tips\#use-hybrid-objects-to-implement-proxy-results "Direct link to Use Hybrid Objects to implement proxy-results")

If a function returns a large amount of data to JS, but only a sub-set of that data is used, we can implement it as a [Hybrid Object](https://nitro.margelo.com/docs/types/hybrid-objects) instead of a [struct](https://nitro.margelo.com/docs/types/custom-types).

This way data will be accessed lazily, and all the data that the user does not access will never be converted to JS, which means Nitro has to do less work:

Bad ❌

```codeBlockLines_AclH
interface AllData {
  rows: DataRow[]
}

interface BadDatabase extends HybridObject {
  getAllData(): AllData
}

const database = // ...
const data = database.getAllData()
const row = data.rows
  .find((r) => r.name === "Marc")

```

Good ✅

```codeBlockLines_AclH
interface AllData extends HybridObject {
  findRowWithName(name: string): DataRow
}

interface GoodDatabase extends HybridObject {
  getAllData(): AllData
}

const database = // ...
const data = database.getAllData()
const row = data.findRowWithName("Marc")

```

The **Bad** example is significantly slower than **Good**, because Nitro has to convert **all rows** to JS, and there could be thousands of rows - even if we only use the row with the `name` "Marc".

The **Good** example is significantly faster than **Bad** because the result of `getAllData()` is a [Hybrid Object](https://nitro.margelo.com/docs/types/hybrid-objects), and all the thousands of rows do not have to be converted to JS at all, instead they are simply held in native memory. The function `findRowWithName(...)` iterates through the list on the native side and finds the matching row - only this single row will then have to be converted to JS.

## Properly use `memorySize` [​](https://nitro.margelo.com/docs/performance-tips\#properly-use-memorysize "Direct link to properly-use-memorysize")

Since Hybrid Objects are implemented in native code, the JS runtime does not know the memory size of such objects.
To let the JavaScript runtime know about a Hybrid Object's actual size in memory, Nitro exposes a `memorySize` (or `getExternalMemoryPressure()`) API which you can use to give a rough estimation on the native object's memory size (including any heap allocations you perform):

```codeBlockLines_AclH
class HybridImage : HybridImageSpec {
  private var cgImage: CGImage
  public var memorySize: Int {
    let imageSize = cgImage.width * cgImage.height * cgImage.bytesPerPixel
    return imageSize
  }
}

```

That way the JS garbage collector knows how big an `Image` is exactly in memory, and can delete any unused `Image` objects sooner to free up the native memory ( `cgImage`), potentially avoiding memory warnings or garbage collector panics.

## Avoid too many native calls [​](https://nitro.margelo.com/docs/performance-tips\#avoid-too-many-native-calls "Direct link to Avoid too many native calls")

While Nitro is insanely fast, there is still an unavoidable overhead associated with calling native code from JS.
In general, it is a good practice to stay within one environment (here; JavaScript) as long as possible, and only call into native when really needed.

Some things (like the `Math.add(...)` function I often use) are faster in JavaScript, as the overhead of calling into native might be greater than the overall execution time of the function.

## Use C++ if possible [​](https://nitro.margelo.com/docs/performance-tips\#use-c-if-possible "Direct link to Use C++ if possible")

If possible, write Nitro Modules in C++. This is faster as bridging to Swift or Kotlin is not required.

## Avoid large arrays [​](https://nitro.margelo.com/docs/performance-tips\#avoid-large-arrays "Direct link to Avoid large arrays")

Large arrays have to be deep-copied, as they are immutable memory in JS. If possible, avoid sending large arrays back and forth - this is the same principle as ["Use Hybrid Objects to implement proxy-results"](https://nitro.margelo.com/docs/performance-tips#use-hybrid-objects-to-implement-proxy-results).

- [Avoid dynamic types](https://nitro.margelo.com/docs/performance-tips#avoid-dynamic-types)
  - [Untyped Maps](https://nitro.margelo.com/docs/performance-tips#untyped-maps)
  - [Variants](https://nitro.margelo.com/docs/performance-tips#variants)
- [Avoid unnecessary objects](https://nitro.margelo.com/docs/performance-tips#avoid-unnecessary-objects)
- [Use Threading/Asynchronous Promises](https://nitro.margelo.com/docs/performance-tips#use-threadingasynchronous-promises)
- [Use `ArrayBuffer` for large data](https://nitro.margelo.com/docs/performance-tips#use-arraybuffer-for-large-data)
- [Use Hybrid Objects to implement proxy-results](https://nitro.margelo.com/docs/performance-tips#use-hybrid-objects-to-implement-proxy-results)
- [Properly use `memorySize`](https://nitro.margelo.com/docs/performance-tips#properly-use-memorysize)
- [Avoid too many native calls](https://nitro.margelo.com/docs/performance-tips#avoid-too-many-native-calls)
- [Use C++ if possible](https://nitro.margelo.com/docs/performance-tips#use-c-if-possible)
- [Avoid large arrays](https://nitro.margelo.com/docs/performance-tips#avoid-large-arrays)

## Sync vs Async Methods
[Skip to main content](https://nitro.margelo.com/docs/sync-vs-async#__docusaurus_skipToContent_fallback)

On this page

By default, every method on a [Hybrid Object](https://nitro.margelo.com/docs/hybrid-objects) is synchronous and runs on the JS Thread.
This means, as long as your native method is executing, the JS Thread is blocked and can not do any other work (like state updates or view changes).

## Light Methods [​](https://nitro.margelo.com/docs/sync-vs-async\#light-methods "Direct link to Light Methods")

For small/light methods this is great because you can return results to the caller (JS) immediately without having to await a Promise.

For example, [react-native-mmkv](https://github.com/mrousavy/react-native-mmkv) allows you to _get_ values synchronously:

```codeBlockLines_AclH
function App() {
  const mmkv = new MMKV()
  const name = mmkv.getString('username') // --> Marc
}

```

If it would be async, it would be quite cumbersome to use in some contexts:

```codeBlockLines_AclH
function App() {
  const mmkv = new MMKV()
  const [name, setName] = useState(undefined)

  useEffect(() => {
    (async () => {
      const n = await mmkv.getString('username') // --> Marc
      setName(n)
    })()
  }, [])
}

```

## Heavy Methods [​](https://nitro.margelo.com/docs/sync-vs-async\#heavy-methods "Direct link to Heavy Methods")

For larger/heavy methods that take a while to execute this can be problematic, because the JS Thread will be blocked for a longer duration then.

To free up the JS Thread while the long-running method is executing, you can make it **asynchronous** by just returning a `Promise`:

MinerSpec.nitro.ts

```codeBlockLines_AclH
interface Miner extends HybridObject {
  mineOneBitcoin(): Promise<number>
}

```

On the native side you still start out with a synchronous method, but you can return a Promise:

- Swift
- Kotlin
- C++

HybridMiner.swift

```codeBlockLines_AclH
class HybridMiner : HybridMinerSpec {
  public func mineOneBitcoin() throws -> Promise<Double> {
    // 1. synchronous in here, JS Thread is still blocked
    //    useful e.g. for argument checking before starting async Thread
    return Promise.async {
      // 2. asynchronous in here, JS Thread is now free
      return computeBitcoin()
    }
  }
}

```

HybridMiner.kt

```codeBlockLines_AclH
class HybridMiner : HybridMinerSpec() {
  override fun mineOneBitcoin(): Promise<Double> {
    // 1. synchronous in here, JS Thread is still blocked
    //    useful e.g. for argument checking before starting async Thread
    return Promise.async {
      // 2. asynchronous in here, JS Thread is now free
      return computeBitcoin()
    }
  }
}

```

HybridMiner.hpp

```codeBlockLines_AclH
class HybridMiner: public HybridMinerSpec {
  std::shared_ptr<Promise<double>> mineOneBitcoin() override {
    // 1. synchronous in here, JS Thread is still blocked
    //    useful e.g. for argument checking before starting async Thread
    return Promise<double>::async([]() {
      // 2. asynchronous in here, JS Thread is now free
      return computeBitcoin();
    });
  }
};

```

## When should it be async? [​](https://nitro.margelo.com/docs/sync-vs-async\#when-should-it-be-async "Direct link to When should it be async?")

It's up to you to decide when to make a native method asynchronous.
Benchmark the total execution time of your method - a good rule of thumb is: _if it takes longer than 50ms, make it asynchronous_.

## Why isn't everything async? [​](https://nitro.margelo.com/docs/sync-vs-async\#why-isnt-everything-async "Direct link to Why isn't everything async?")

There's two reasons:

1. Jumping from one thread (JS) to another (background) introduces a tiny overhead. Sometimes the total execution time of the method itself is smaller than just the Thread-jump, so it would make more sense to just keep it synchronous right away.
2. For small/fast methods it's more ergonomic to keep them synchronous as the caller receives the return value right away - no awaiting or Promises.

- [Light Methods](https://nitro.margelo.com/docs/sync-vs-async#light-methods)
- [Heavy Methods](https://nitro.margelo.com/docs/sync-vs-async#heavy-methods)
- [When should it be async?](https://nitro.margelo.com/docs/sync-vs-async#when-should-it-be-async)
- [Why isn't everything async?](https://nitro.margelo.com/docs/sync-vs-async#why-isnt-everything-async)

## Nitro Troubleshooting Guide
[Skip to main content](https://nitro.margelo.com/docs/troubleshooting#__docusaurus_skipToContent_fallback)

On this page

This guide helps you troubleshoot issues in Nitro and should give you enough context to open a well-formed issue, even if you're not a native developer.

## Minimum requirements [​](https://nitro.margelo.com/docs/troubleshooting\#minimum-requirements "Direct link to Minimum requirements")

First, make sure you meet the [minimum requirements](https://nitro.margelo.com/docs/minimum-requirements) for Nitro.

## Ask for help [​](https://nitro.margelo.com/docs/troubleshooting\#ask-for-help "Direct link to Ask for help")

If you want to ask for help, join our [Margelo Community Discord](https://margelo.com/discord).

## Build error [​](https://nitro.margelo.com/docs/troubleshooting\#build-error "Direct link to Build error")

If your app fails to build after installing Nitro or a library powered by Nitro, make sure to post full build logs:

- iOS
- Android

1. Build the app with Xcode.

2. When the build fails in Xcode, open the "Report Navigator" tab from within the left sidebar:
![Report Navigator tab in Xcode](https://nitro.margelo.com/img/troubleshoot-xcode-1.png)
3. Then, find the most recent build attempt and click on "Build":
![Last build report in Xcode](https://nitro.margelo.com/img/troubleshoot-xcode-2.png)
4. Scroll through the build report and find the step(s) that failed to build. They usually have a ❌ icon on the left. Click on the parent item's hamburger menu on the right to open the full logs:
![Error line in the build report](https://nitro.margelo.com/img/troubleshoot-xcode-3.png)
5. Scroll down through the build logs (the long part is just the command invocation) to find the actual error messages:
![Bottom of error logs](https://nitro.margelo.com/img/troubleshoot-xcode-4.png)
6. Copy those bottom logs only (not the build command invocation above) and create a GitHub issue with that.


1. Build the app with Android Studio.

2. When the build fails in Android Studio, open the "Build" tab from within the bottom left sidebar:
![Build tab in Android Studio](https://nitro.margelo.com/img/troubleshoot-android-1.png)
3. Find the top-most entry in the Build window (which contains full unfiltered logs) and click it:
![Build tab in Android Studio](https://nitro.margelo.com/img/troubleshoot-android-2.png)
4. Copy those full logs and paste them in the GitHub issue (or serve via pastebin). Make sure they actually contain the **error** message and not just something like "BUILD FAILED in 7s" (which is what most people post):
![Build logs in Android Studio](https://nitro.margelo.com/img/troubleshoot-android-3.png)

## Runtime error [​](https://nitro.margelo.com/docs/troubleshooting\#runtime-error "Direct link to Runtime error")

If your app crashes at runtime, make sure to inspect the native logs.

- iOS
- Android

1. Run your app through Xcode

2. If the app hits an unhandled error, it should pause in Xcode. Share the line it stopped in, and also the call-stack (stacktrace) on the left side.

3. If the app didn't pause, then it might have been a handled error - in this case just check the Xcode logs at the bottom:
![Bottom of runtime logs](https://nitro.margelo.com/img/troubleshoot-xcode-logs.png)

1. Run your app through Android Studio by using the Debug button (🪲)

2. If the app hits an unhandled error, it should pause in Android Studio. Share the line it stopped in, and also the call-stack (stacktrace) on the bottom window.

3. If the app didn't pause, then it might have been a handled error - in this case just check the Android Logcat logs at the bottom:
![Bottom of runtime logs](https://nitro.margelo.com/img/troubleshoot-android-logs.png)

- [Minimum requirements](https://nitro.margelo.com/docs/troubleshooting#minimum-requirements)
- [Ask for help](https://nitro.margelo.com/docs/troubleshooting#ask-for-help)
- [Build error](https://nitro.margelo.com/docs/troubleshooting#build-error)
- [Runtime error](https://nitro.margelo.com/docs/troubleshooting#runtime-error)

## Nitro Type System
[Skip to main content](https://nitro.margelo.com/docs/types#__docusaurus_skipToContent_fallback)

On this page

Nitro uses an extensible typing system to efficiently convert between JS and C++ types - **statically defined** and fully **type-safe** and **null-safe at compile-time**.

For example, a JS `number` will always be a `double` on the native side:

Math.nitro.ts

```codeBlockLines_AclH
interface Math extends HybridObject {
  add(a: number, b: number): number
}

```

HybridMath.hpp

```codeBlockLines_AclH
class HybridMath : public HybridMathSpec {
  double add(double a, double b);
}

```

Nitro strictly enforces **type-safety** and **null-safety** \- both at compile-time and at runtime.
This prevents accidentally passing a wrong type to `add(..)` (for example, a `string`) and performs null-checks to prevent passing and returning `null`/ `undefined` values.

On the JS side (TypeScript), type- and null-safety is enforced via TypeScript - so use it!

## Nitrogen [​](https://nitro.margelo.com/docs/types\#nitrogen "Direct link to Nitrogen")

[Nitrogen](https://nitro.margelo.com/docs/nitrogen) ensures that TypeScript definitions are always in sync with native type definitions.
You can also use Nitro without nitrogen, in this case TypeScript definitions have to be written manually.

## Supported Types [​](https://nitro.margelo.com/docs/types\#supported-types "Direct link to Supported Types")

These are all the types Nitro supports out of the box:

| JS Type | C++ Type | Swift Type | Kotlin Type |
| --- | --- | --- | --- |
| `number` | `double` / `int` / `float` | `Double` | `Double` |
| `boolean` | `bool` | `Bool` | `Boolean` |
| `string` | `std::string` | `String` | `String` |
| `bigint` | `int64_t` / `uint64_t` | `Int64` | `Long` |
| `T[]` | `std::vector<T>` | `[T]` | `Array<T>` / `PrimitiveArray` |
| `T?` | `std::optional<T>` | `T?` | `T?` |
| `[A, B, ...]` | `std::tuple<A, B, ...>` | `(A, B)` 🟡  ( [#38](https://github.com/mrousavy/nitro/issues/38)) | ❌ |
| `A | B | ...` | `std::variant<A, B, ...>` | `Variant_A_B_C` | `Variant_A_B_C` |
| `(T...) => void` | `std::function<void (T...)>` | `@escaping (T...) -> Void` | `(T...) -> Unit` |
| `(T...) => R` | `std::function<std::shared_ptr<Promise<R>> (T...)>` | `@escaping (T...) -> Promise<R>` | `(T...) -> Promise<R>` |
| `Sync<(T...) => R>` | `std::function<R (T...)>` | `@escaping (T...) -> R` | `(T...) -> R` |
| `Record<string, T>` | `std::unordered_map<std::string, T>` | `Dictionary<String, T>` | `Map<String, T>` |
| `Error` | `std::exception_ptr` | `Error` | `Throwable` |
| `Promise<T>` | `std::shared_ptr<Promise<T>>` | `Promise<T>` | `Promise<T>` |
| `object` | `std::shared_ptr<AnyMap>` | `AnyMapHolder` | `AnyMap` |
| `ArrayBuffer` | `std::shared_ptr<ArrayBuffer>` | `ArrayBufferHolder` | `ArrayBuffer` |
| ..any `HybridObject` | `std::shared_ptr<HybridObject>` | `HybridObject` | `HybridObject` |
| ..any `interface` | `T` | `T` | `T` |
| ..any `enum` | `T` | `T` | `T` |
| ..any `union` | `T` | `T` | `T` |

- [Nitrogen](https://nitro.margelo.com/docs/types#nitrogen)
- [Supported Types](https://nitro.margelo.com/docs/types#supported-types)

## Array Buffers Overview
[Skip to main content](https://nitro.margelo.com/docs/types/array-buffers#__docusaurus_skipToContent_fallback)

On this page

Array Buffers allow highly efficient access to the same data from both JS and native.
Passing an `ArrayBuffer` from native to JS and back does not involve any copies, and is therefore the fastest way of passing around data in Nitro.

- TypeScript
- Swift
- Kotlin
- C++

```codeBlockLines_AclH
interface Image extends HybridObject {
  getData(): ArrayBuffer
}

```

```codeBlockLines_AclH
class HybridImage: HybridImageSpec {
  func getData() -> ArrayBufferHolder
}

```

```codeBlockLines_AclH
class HybridImage: HybridImageSpec() {
  fun getData(): ArrayBuffer
}

```

```codeBlockLines_AclH
class HybridImage: public HybridImageSpec {
  std::shared_ptr<ArrayBuffer> getData();
}

```

It is important to understand the ownership, and threading concerns around such shared memory access.

## Ownership [​](https://nitro.margelo.com/docs/types/array-buffers\#ownership "Direct link to Ownership")

There's two types of `ArrayBuffer` s, **owning** and **non-owning**:

### Owning [​](https://nitro.margelo.com/docs/types/array-buffers\#owning "Direct link to Owning")

An `ArrayBuffer` that was created on the native side is **owning**, which means you can safely access it's data as long as the `ArrayBuffer` reference is alive.
It can be safely held strong for longer, e.g. as a class property/member, and accessed from different Threads.

```codeBlockLines_AclH
func doSomething() -> ArrayBufferHolder {
  let buffer = ArrayBufferHolder.allocate(1024 * 10)
  let data = buffer.data   // <-- ✅ safe to do because we own it!
  self.buffer = buffer     // <-- ✅ safe to use it later!
  DispatchQueue.global().async {
    let data = buffer.data // <-- ✅ also safe because we own it!
  }
  return buffer
}

```

### Non-owning [​](https://nitro.margelo.com/docs/types/array-buffers\#non-owning "Direct link to Non-owning")

An `ArrayBuffer` that was received as a parameter from JS cannot be safely kept strong as the JS VM can delete it at any point, hence it is **non-owning**.
It's data can only be safely accessed before the synchronous function returned, as this will stay within the JS bounds.

```codeBlockLines_AclH
func doSomething(buffer: ArrayBufferHolder) {
  let data = buffer.data   // <-- ✅ safe to do because we're still sync
  DispatchQueue.global().async {
    let data = buffer.data // <-- ❌ NOT safe
  }
}

```

If you need a non-owning buffer's data for longer, **copy it first**:

```codeBlockLines_AclH
func doSomething(buffer: ArrayBufferHolder) {
  let copy = ArrayBufferHolder.copy(of: buffer)
  let data = copy.data   // <-- ✅ safe now because we have a owning copy
  DispatchQueue.global().async {
    let data = copy.data // <-- ✅ still safe now because we have a owning copy
  }
}

```

## Threading [​](https://nitro.margelo.com/docs/types/array-buffers\#threading "Direct link to Threading")

An `ArrayBuffer` can be accessed from both JS and native, and even from multiple Threads at once, but they are **not thread-safe**.
To prevent race conditions or garbage-data from being read, make sure to not read from- and write to- the `ArrayBuffer` at the same time.

## Creating Buffers [​](https://nitro.margelo.com/docs/types/array-buffers\#creating-buffers "Direct link to Creating Buffers")

Buffers can either be created from native ( **owning**), or from JS ( **non-owning**).

### From native [​](https://nitro.margelo.com/docs/types/array-buffers\#from-native "Direct link to From native")

On the native side, an **owning** `ArrayBuffer` can either **wrap-**, or **copy-** an existing buffer:

- Swift
- Kotlin
- C++

```codeBlockLines_AclH
let myData = UnsafeMutablePointer<UInt8>.allocate(capacity: 4096)

// wrap (no copy)
let wrappingArrayBuffer = ArrayBufferHolder.wrap(dataWithoutCopy: myData,
                                                 size: 4096,
                                                 onDelete: { myData.deallocate() })
// copy
let copiedArrayBuffer = ArrayBufferHolder.copy(of: wrappingArrayBuffer)
// new blank buffer
let newArrayBuffer = ArrayBufferHolder.allocate(size: 4096)

```

```codeBlockLines_AclH
val myData = ByteBuffer.allocateDirect(4096)

// wrap (no copy)
val wrappingArrayBuffer = ArrayBuffer.wrap(myData)

// copy
let copiedArrayBuffer = ArrayBuffer.copy(myData)
// new blank buffer
val newArrayBuffer = ArrayBuffer.allocate(4096)

```

```codeBlockLines_AclH
auto myData = new uint8_t[4096];

// wrap (no copy)
auto wrappingArrayBuffer = ArrayBuffer::wrap(myData, 4096, [=]() {
  delete[] myData;
});
// copy
auto copiedArrayBuffer = ArrayBuffer::copy(myData, 4096);
// new blank buffer
auto newArrayBuffer = ArrayBuffer::allocate(4096);

```

#### Language-native buffer types [​](https://nitro.margelo.com/docs/types/array-buffers\#language-native-buffer-types "Direct link to Language-native buffer types")

ArrayBuffers also provide helper and conversion methods for the language-native conventional buffer types:

- Swift
- Kotlin
- C++

Swift often uses [`Data`](https://developer.apple.com/documentation/foundation/data) to represent Data.

```codeBlockLines_AclH
let data = Data(capacity: 1024)
let buffer = ArrayBufferHolder.copy(data: data)
let dataAgain = buffer.toData(copyIfNeeded: true)

```

Kotlin often uses [`ByteBuffer`](https://developer.android.com/reference/java/nio/ByteBuffer) to represent Data.

```codeBlockLines_AclH
val data = ByteBuffer.allocateDirect(1024)
val buffer = ArrayBuffer.copy(data)
val dataAgain = buffer.getBuffer(copyIfNeeded = true)

```

C++ often uses [`std::vector<uint8_t>`](https://en.cppreference.com/w/cpp/container/vector) to represent Data.

```codeBlockLines_AclH
std::vector<uint8_t> data;
auto buffer = ArrayBuffer::copy(data);
/* convert back to vector would be a copy. */

```

### From JS [​](https://nitro.margelo.com/docs/types/array-buffers\#from-js "Direct link to From JS")

From JS, a **non-owning** `ArrayBuffer` can be created via the [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) web APIs, and viewed or edited using the typed array APIs (e.g. [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)).

```codeBlockLines_AclH
const arrayBuffer = new ArrayBuffer(4096)
const view = new Uint8Array(arrayBuffer)
view[0] = 64
view[1] = 128
view[2] = 255

```

- [Ownership](https://nitro.margelo.com/docs/types/array-buffers#ownership)
  - [Owning](https://nitro.margelo.com/docs/types/array-buffers#owning)
  - [Non-owning](https://nitro.margelo.com/docs/types/array-buffers#non-owning)
- [Threading](https://nitro.margelo.com/docs/types/array-buffers#threading)
- [Creating Buffers](https://nitro.margelo.com/docs/types/array-buffers#creating-buffers)
  - [From native](https://nitro.margelo.com/docs/types/array-buffers#from-native)
    - [Language-native buffer types](https://nitro.margelo.com/docs/types/array-buffers#language-native-buffer-types)
  - [From JS](https://nitro.margelo.com/docs/types/array-buffers#from-js)

## Efficient Array Structures
[Skip to main content](https://nitro.margelo.com/docs/types/arrays#__docusaurus_skipToContent_fallback)

On this page

Arrays of items are represented with the most common, and most efficient array datastructures in native languages, such as `std::vector<T>` or `Array<T>`.

- TypeScript
- Swift
- Kotlin
- C++

```codeBlockLines_AclH
interface Contacts extends HybridObject {
  getAllUsers(): User[]
}

```

```codeBlockLines_AclH
class HybridContacts: HybridContactsSpec {
  fun getAllUsers() -> Array<User>
}

```

```codeBlockLines_AclH
class HybridContacts: HybridContactsSpec() {
  fun getAllUsers(): Array<User>
}

```

```codeBlockLines_AclH
class HybridContacts : public HybridContactsSpec {
  std::vector<User> getAllUsers();
}

```

## Kotlin `PrimitiveArray` [​](https://nitro.margelo.com/docs/types/arrays\#kotlin-primitivearray "Direct link to kotlin-primitivearray")

As a performance improvement, the JNI (C++ -> Kotlin interface) provides **Primitive Array** datatypes which can avoid boxing primitives into `Object` s, and provides bulk copy methods.
This makes all array operations **a lot faster**, and Nitrogen is smart enough to ✨ **automagically** ✨ use Primitive Arrays whenever possible.
This will replace the following arrays:

- `Array<Double>` -\> [`DoubleArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/)
- `Array<Boolean>` -\> [`BooleanArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean-array/)
- `Array<Long>` -\> [`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/)

- [Kotlin `PrimitiveArray`](https://nitro.margelo.com/docs/types/arrays#kotlin-primitivearray)

## Nitro Callbacks Overview
[Skip to main content](https://nitro.margelo.com/docs/types/callbacks#__docusaurus_skipToContent_fallback)

On this page

Callbacks are functions created in one language and passed to another to provide a way to "call back" later.

Nitro has a clever reference counting system to allow users to use callbacks/functions from JS safely, and without any limitations.
Each callback holds a strong reference on the native side and can be called as often as needed.
Once the callback is no longer used, it will be safely deleted from memory.

- TypeScript
- Swift
- Kotlin
- C++

In TypeScript, a callback is represented as an anonymous function:

```codeBlockLines_AclH
interface Server extends HybridObject {
  start(onNewUserJoined: (user: User) => void): void
}

```

In Swift, a callback is represented as a closure:

```codeBlockLines_AclH
func start(onNewUserJoined: (User) -> Void) {
  onNewUserJoined(user)
}

```

In Kotlin, a callback is represented as a lambda:

```codeBlockLines_AclH
fun start(onNewUserJoined: (User) -> Unit) {
  onNewUserJoined(user)
}

```

In C++, a callback is represented as a function:

```codeBlockLines_AclH
void start(std::function<void(User)> onNewUserJoined) {
  onNewUserJoined(user);
}

```

## Events [​](https://nitro.margelo.com/docs/types/callbacks\#events "Direct link to Events")

Since callbacks can be safely kept in memory for longer and called multiple times, Nitro does not have a special type for an "event".
It is simply a function you store in memory and call later, just like in a normal JS class. ✨

- TypeScript
- Swift
- Kotlin
- C++

In TypeScript, a callback is represented as an anonymous function:

```codeBlockLines_AclH
type Orientation = "portrait" | "landscape"
interface DeviceInfo extends HybridObject {
  listenToOrientation(onChanged: (o: Orientation) => void): void
}

const deviceInfo = // ...
deviceInfo.listenToOrientation((o) => {
  console.log(`Orientation changed to ${o}!`)
})

```

In Swift, a callback is represented as a closure:

```codeBlockLines_AclH
func listenToOrientation(onChanged: (Orientation) -> Void) {
  self.listeners.append(onChanged)
}

func onRotate() {
  for listener in self.listeners {
    listener(newOrientation)
  }
}

```

In Kotlin, a callback is represented as a lambda:

```codeBlockLines_AclH
fun listenToOrientation(onChanged: (Orientation) -> Unit) {
  this.listeners.add(onChanged)
}

fun onRotate() {
  for (listener in this.listeners) {
    listener(newOrientation)
  }
}

```

In C++, a callback is represented as a function:

```codeBlockLines_AclH
void listenToOrientation(std::function<void(Orientation)> onChanged) {
  this->listeners.push_back(onChanged);
}

void onRotate() {
  for (const auto& listener: this->listeners) {
    listener(newOrientation);
  }
}

```

## Callbacks that return a value ( `(...) => T`) [​](https://nitro.margelo.com/docs/types/callbacks\#callbacks-that-return-a-value---t "Direct link to callbacks-that-return-a-value---t")

Since JS callbacks could theoretically be called from any native Thread,
Nitro safely wraps the result types of callbacks that return a value in **Promises which need to be awaited**.

Math.nitro.ts

```codeBlockLines_AclH
interface Math extends HybridObject {
  some(getValue: () => number): void
}

```

HybridMath.swift

```codeBlockLines_AclH
func some(getValue: () -> Promise<Double>) {
  Task {
    let promise = getValue()
    let valueFromJs = try await promise.await()
  }
}

```

## Synchronous Callbacks [​](https://nitro.margelo.com/docs/types/callbacks\#synchronous-callbacks "Direct link to Synchronous Callbacks")

By default, callback functions in Nitro are _asynchronous_. Their execution is scheduled on the JS Thread, and if they return a value they always return a `Promise<T>` wrapping the value.
This ensures that you can call the callback from any Thread, and it safely executes the actual JS function on the correct JS Thread.

In addition to that, Nitro also supports fully _synchronous_ callbacks. They are considered dangerous, as the caller is responsible for ensuring Thread safety.
To extend the previous example, we can make `getValue()` synchronous by wrapping it in the `Sync<T>` type provided by Nitro:

Math.nitro.ts

```codeBlockLines_AclH
interface Math extends HybridObject {
  some(getValue: Sync<() => number>): void
}

```

HybridMath.swift

```codeBlockLines_AclH
func some(getValue: () -> Double) {
  let valueFromJs = getValue()
}

```

warning

The `getValue()` callback can now only be called from the JS Thread.

## How was it before Nitro? [​](https://nitro.margelo.com/docs/types/callbacks\#how-was-it-before-nitro "Direct link to How was it before Nitro?")

Conventionally (in legacy React Native Native Modules), a native method could only have a maximum of two callbacks, one "success" and one "failure" callback.
Once one of these callbacks is called, both will be destroyed and can no longer be called later.
This is why React Native introduced "Events" as a way to call into JS more than just once.
This also meant that an asynchronous function could not have any callbacks, since a Promise's resolve and reject functions are already two callbacks.
For example, this was **not possible**:

```codeBlockLines_AclH
interface Camera {
  startRecording(onStatusUpdate: () => void,
                 onRecordingFailed: () => void,
                 onRecordingFinished: () => void): Promise<void>
}

```

Thanks to Nitro's clever reference system, functions can be safely held in memory and called as many times as you like, just like in a normal JS class.
This makes "Events" obsolete, and allows using as many callbacks per native method as required.

- [Events](https://nitro.margelo.com/docs/types/callbacks#events)
- [Callbacks that return a value ( `(...) => T`)](https://nitro.margelo.com/docs/types/callbacks#callbacks-that-return-a-value---t)
- [Synchronous Callbacks](https://nitro.margelo.com/docs/types/callbacks#synchronous-callbacks)
- [How was it before Nitro?](https://nitro.margelo.com/docs/types/callbacks#how-was-it-before-nitro)

## Custom Types in Nitrogen
[Skip to main content](https://nitro.margelo.com/docs/types/custom-types#__docusaurus_skipToContent_fallback)

On this page

- With Nitrogen ✨
- Manually

Nitrogen can ✨ **automagically** ✨ generate custom types and their respective bindings for any types used in your specs.

## Custom interfaces (structs) [​](https://nitro.margelo.com/docs/types/custom-types\#custom-interfaces-structs "Direct link to Custom interfaces (structs)")

Any custom `interface` or `type` will be represented as a fully type-safe `struct` in C++/Swift/Kotlin. Simply define the type in your `.nitro.ts` spec:

Nitro.nitro.ts

```codeBlockLines_AclH
interface Person {
  name: string
  age: number
}

interface Nitro extends HybridObject {
  getAuthor(): Person
}

```

HybridNitro.swift

```codeBlockLines_AclH
class HybridNitro: HybridNitroSpec {
  func getAuthor() -> Person {
    return Person(name: "Marc", age: 24)
  }
}

```

Nitro enforces full type-safety to avoid passing or returning wrong types.
Both `name` and `age` are always part of `Person`, they are never a different type than a `string`/ `number`, and never null or undefined.

This makes the TypeScript definition the **single source of truth**, allowing you to rely on types! 🤩

## Enums (TypeScript enum) [​](https://nitro.margelo.com/docs/types/custom-types\#enums-typescript-enum "Direct link to Enums (TypeScript enum)")

A [TypeScript enum](https://www.typescriptlang.org/docs/handbook/enums.html) is essentially just an object where each key has an incrementing integer value,
so Nitrogen will just generate a C++ enum natively, and bridges to JS using simple integers:

```codeBlockLines_AclH
enum Gender {
  MALE,
  FEMALE
}
interface Person extends HybridObject {
  getGender(): Gender
}

```

This is efficient because `MALE` is the number `0`, `FEMALE` is the number `1`, and all other values are invalid.

## Enums (TypeScript union) [​](https://nitro.margelo.com/docs/types/custom-types\#enums-typescript-union "Direct link to Enums (TypeScript union)")

A [TypeScript union](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types) is essentially just a string, which is only "typed" via TypeScript.

```codeBlockLines_AclH
type Gender = 'male' | 'female'
interface Person extends HybridObject {
  getGender(): Gender
}

```

Nitrogen statically generates hashes for the strings `"male"` and `"female"` at compile-time, allowing for very efficient conversions between JS `string` s and native `enum` s.

## Overloading a simple type [​](https://nitro.margelo.com/docs/types/custom-types\#overloading-a-simple-type "Direct link to Overloading a simple type")

The `JSIConverter<T>` is a template which can be extended with any custom type.

For example, if you want to use `float` directly you can tell Nitro how to convert a `jsi::Value` to `float` by implementing `JSIConverter<float>`:

JSIConverter+Float.hpp

```codeBlockLines_AclH
template <>
struct JSIConverter<float> final {
  static inline float fromJSI(jsi::Runtime&, const jsi::Value& arg) {
    return static_cast<float>(arg.asNumber());
  }
  static inline jsi::Value toJSI(jsi::Runtime&, float arg) {
    return jsi::Value(arg);
  }
  static inline bool canConvert(jsi::Runtime&, const jsi::Value& value) {
    return value.isNumber();
  }
};

```

Then just use it in your methods:

HybridMath.hpp

```codeBlockLines_AclH
class HybridMath : public HybridObject {
public:
  float add(float a, float b) {
    return a + b;
  }

  void loadHybridMethods() {
    HybridObject::loadHybridMethods();
    registerHybrids(this, [](Prototype& prototype) {
      prototype.registerHybridMethod("add", &HybridMath::add);
    });
  }
}

```

info

Make sure the compiler knows about `JSIConverter<float>` at the time when `HybridMath` is declared, so import your `JSIConverter+Float.hpp` in your Hybrid Object's header file as well!

## Complex types (e.g. `struct`) [​](https://nitro.margelo.com/docs/types/custom-types\#complex-types-eg-struct "Direct link to complex-types-eg-struct")

The same goes for any complex type, like a custom typed `struct`:

JSIConverter+Person.hpp

```codeBlockLines_AclH
struct Person {
  std::string name;
  double age;
};

template <>
struct JSIConverter<Person> {
  static Person fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
    jsi::Object obj = arg.asObject(runtime);
    return Person(
      JSIConverter<std::string>::fromJSI(runtime, obj.getProperty(runtime, "name")),
      JSIConverter<double>::fromJSI(runtime, obj.getProperty(runtime, "age"))
    );
  }
  static jsi::Value toJSI(jsi::Runtime& runtime, const Person& arg) {
    jsi::Object obj(runtime);
    obj.setProperty(runtime, "name", JSIConverter<std::string>::toJSI(runtime, arg.name));
    obj.setProperty(runtime, "age", JSIConverter<double>::toJSI(runtime, arg.age));
    return obj;
  }
  static bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
    if (!value.isObject())
      return false;
    jsi::Object obj = value.getObject(runtime);
    if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, "name")))
      return false;
    if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, "age")))
      return false;
    return true;
  }
};

```

..which can now safely be called with any JS value.
If the given JS value is not an object of exactly the shape of `Person` (that is, a `name: string` and an `age: number` values), Nitro will throw an error.

- [Custom interfaces (structs)](https://nitro.margelo.com/docs/types/custom-types#custom-interfaces-structs)
- [Enums (TypeScript enum)](https://nitro.margelo.com/docs/types/custom-types#enums-typescript-enum)
- [Enums (TypeScript union)](https://nitro.margelo.com/docs/types/custom-types#enums-typescript-union)
- [Overloading a simple type](https://nitro.margelo.com/docs/types/custom-types#overloading-a-simple-type)
- [Complex types (e.g. `struct`)](https://nitro.margelo.com/docs/types/custom-types#complex-types-eg-struct)

## Hybrid Objects Overview
[Skip to main content](https://nitro.margelo.com/docs/types/hybrid-objects#__docusaurus_skipToContent_fallback)

On this page

Since Nitro Modules are object-oriented, a `HybridObject` itself is a first-class citizen.
This means you can pass around instances of native `HybridObject` s between JS and native, allowing for safe interface-level abstractions:

Camera.nitro.ts

```codeBlockLines_AclH
interface Image extends HybridObject {
  readonly width: number
  readonly height: number
}

interface Camera extends HybridObject {
  takePhoto(): Image
}

```

HybridCamera.swift

```codeBlockLines_AclH
class HybridImage: HybridImageSpec {
  var width: Double { get }
  var height: Double { get }
}

class HybridCamera: HybridCameraSpec {
  func takePhoto() -> HybridImageSpec
}

```

## Interface-level abstraction [​](https://nitro.margelo.com/docs/types/hybrid-objects\#interface-level-abstraction "Direct link to Interface-level abstraction")

Since Hybrid Objects are declared as interfaces, `Image` could have different implementations...

```codeBlockLines_AclH
class HybridUIImage: HybridImageSpec {
  // ...
  var uiImage: UIImage
}
class HybridCGImage: HybridImageSpec {
  // ...
  var cgImage: CGImage
}
class HybridBufferImage: HybridImageSpec {
  // ...
  var gpuBuffer: CMSampleBuffer
}

```

...but still be used exactly the same in other places, as it is all a `HybridImageSpec`.
Even if they use different implementations under the hood, they all share a common interface with properties like `width`, `height` and more:

Cropper.nitro.ts

```codeBlockLines_AclH
interface Cropper extends HybridObject {
  crop(image: Image, size: Size): Image
}

```

Cropper.swift

```codeBlockLines_AclH
class HybridCropper: HybridCropperSpec {
  func crop(image: HybridImageSpec,
            size: Size) -> HybridImageSpec {
    let data = image.data
    let croppedData = cropFunc(data, size)
    return HybridCGImage(data: croppedData)
  }
}

```

- [Interface-level abstraction](https://nitro.margelo.com/docs/types/hybrid-objects#interface-level-abstraction)

## Optional Values in Programming
[Skip to main content](https://nitro.margelo.com/docs/types/optionals#__docusaurus_skipToContent_fallback)

Optional or nullable values can be declared either by using the questionmark operator ( `?`), or by adding an `undefined` variant:

- TypeScript
- Swift
- Kotlin
- C++

```codeBlockLines_AclH
interface Math extends HybridObject {
  a?: number
  b: number | undefined
}

```

```codeBlockLines_AclH
class HybridMath: HybridMathSpec {
  var a: Double?
  var b: Double?
}

```

```codeBlockLines_AclH
class HybridMath: HybridMathSpec() {
  override var a: Double?
  override var b: Double?
}

```

```codeBlockLines_AclH
class HybridMath: public HybridMathSpec {
  std::optional<double> a;
  std::optional<double> b;
};

```

In Kotlin/Java, nullables have to be boxed in object types.

## Primitive Datatypes Overview
[Skip to main content](https://nitro.margelo.com/docs/types/primitives#__docusaurus_skipToContent_fallback)

On this page

Primitive datatypes like `number`, `boolean` or `bigint` can use platform-native datatypes directly.
For example, a JS `number` is always a 64-bit `double` in C++, a `Double` in Swift, and a `Double` in Kotlin.

- TypeScript
- Swift
- Kotlin
- C++

```codeBlockLines_AclH
interface Math extends HybridObject {
  add(a: number, b: number): number
}

```

```codeBlockLines_AclH
class HybridMath: HybridMathSpec {
  func add(a: Double, b: Double) -> Double
}

```

```codeBlockLines_AclH
class HybridMath: HybridMathSpec() {
  fun add(a: Double, b: Double): Double
}

```

```codeBlockLines_AclH
class HybridMath : public HybridMathSpec {
  double add(double a, double b);
}

```

Primitives are very efficient and can be passed with little to no overhead, especially between C++ and Swift, and C++ and Kotlin.

## `bigint`'s actual type [​](https://nitro.margelo.com/docs/types/primitives\#bigints-actual-type "Direct link to bigints-actual-type")

A `bigint` is actually a variable-size type. While it is bridged to a 64-bit Integer (-263 … 263−1), it can theoretically be larger than that.

Since there is no built-in equivalent of `bigint` in C++/Swift/Kotlin, you'd need to stringify the `bigint` value on the JS side and parse it from a string to your big number library of choice on the native side again in cases where you really need big numbers.

- [`bigint`'s actual type](https://nitro.margelo.com/docs/types/primitives#bigints-actual-type)

## Using Promises in Programming
[Skip to main content](https://nitro.margelo.com/docs/types/promises#__docusaurus_skipToContent_fallback)

A function can be made asynchronous by returning a `Promise` to JS.
This allows your native code to perform heavy-, long-running tasks in parallel, while the JS thread can continue rendering and performing other business logic.

- TypeScript
- Swift
- Kotlin
- C++

In TypeScript, a `Promise<T>` is represented using the built-in `Promise<T>` type, which can be awaited:

```codeBlockLines_AclH
interface Math extends HybridObject {
  fibonacci(n: number): Promise<number>
}

const math = // ...
await math.fibonacci(13)

```

In Swift, a `Promise<T>` can be created via Nitro's [`Promise<T>`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/ios/core/Promise.swift) type - for example, to use Swift's new async/await syntax:

```codeBlockLines_AclH
func fibonacci(n: Double) -> Promise<Double> {
  return Promise.async {
    // This runs on a separate Thread, and can use `await` syntax!
    return try await calculateFibonacciSequence(n)
  }
}

```

In Kotlin, a `Promise<T>` can be created via Nitro's [`Promise<T>`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/core/Promise.kt) type - for example, to use Kotlin's coroutine syntax:

```codeBlockLines_AclH
fun fibonacci(n: Double): Promise<Double> {
  return Promise.async {
    // This runs on a separate Thread, and can use suspending coroutine functions!
    return calculateFibonacciSequence(n)
  }
}

```

In C++, a `Promise<T>` can be created via Nitro's [`Promise<T>`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/cpp/core/Promise.hpp) type - for example, to use an asynchronous Thread pool:

```codeBlockLines_AclH
std::shared_ptr<Promise<double>> fibonacci(double n) {
  return Promise<double>::async([=]() -> double {
    // This runs on a separate Thread!
    return calculateFibonacciSequence(n);
  });
}

```

Additionally, Nitro statically enforces that **Promises can never go stale**, preventing you from accidentally "forgetting" to resolve or reject a Promise:

HybridMath.swift

```codeBlockLines_AclH
func saveToFile(image: HybridImage) -> Promise<Void> {
  guard let data = image.data else { return }
                                     ^ // Error: Cannot return void!
  return Promise.async {
    try await data.writeToFile("file://tmp/img.png")
  }
}

```

## Understanding Tuples in TypeScript
[Skip to main content](https://nitro.margelo.com/docs/types/tuples#__docusaurus_skipToContent_fallback)

A Tuple is a fixed-length set of items of the given types. Example:

```codeBlockLines_AclH
type Point = [number, number]
interface Math extends HybridObject {
  distance(a: Point, b: Point): number
}

```

Tuples can also have different types per value:

Bad ❌

```codeBlockLines_AclH
type Values = (number | string | Person)[]
interface Math extends HybridObject {
  calculate(values: Values): void
}

```

The type in the **Bad ❌** example generates an [array](https://nitro.margelo.com/docs/types/arrays) of [variants](https://nitro.margelo.com/docs/types/variants), where it's size is unknown and each value could be a `number`, a `string` or a `Person`. It is less efficient than a **tuple** because of the variant allocation.

Good ✅

```codeBlockLines_AclH
type Values = [number, string, Person]
interface Math extends HybridObject {
  calculate(values: Values): void
}

```

The type in the **Good ✅** example generates a **tuple**, where it's size is guaranteed to be **3** and each value is known at compile-time: `values[0]: number`, `values[1]: string`, `values[2]: Person`.

## Typed Maps Overview
[Skip to main content](https://nitro.margelo.com/docs/types/typed-maps#__docusaurus_skipToContent_fallback)

A typed map is an object where each value is of the given type `T`.

For example, if your API returns a map of users with their ages, you _could_ use a `Record<string, number>`:

- TypeScript
- Swift
- Kotlin
- C++

```codeBlockLines_AclH
interface Database extends HybridObject {
  getAllUsers(): Record<string, number>
}

```

```codeBlockLines_AclH
class HybridDatabase: HybridDatabaseSpec {
  func getAllUsers() -> Dictionary<String, Double>
}

```

```codeBlockLines_AclH
class HybridDatabase: HybridDatabaseSpec() {
  fun getAllUsers(): Map<String, Double>
}

```

```codeBlockLines_AclH
class HybridDatabase: public HybridDatabaseSpec {
  std::unordered_map<std::string, double> getAllUsers();
}

```

tip

While typed maps are very efficient, Nitro cannot sufficiently optimize the object as keys are not known in advance.
If possible, **avoid typed maps** and use [arrays](https://nitro.margelo.com/docs/types/arrays) for unknown number of items, or [strongly typed objects](https://nitro.margelo.com/docs/types/custom-types) for known number of items instead.

## Untyped Maps Overview
[Skip to main content](https://nitro.margelo.com/docs/types/untyped-maps#__docusaurus_skipToContent_fallback)

An untyped map represents a JSON-like structure with a value that can either be a `number`, a `string`, a `boolean`, a `bigint`, a `null`, an array or an object.

- TypeScript
- Swift
- Kotlin
- C++

```codeBlockLines_AclH
interface Fetch extends HybridObject {
  get(url: string): AnyMap
}

```

```codeBlockLines_AclH
class HybridFetch: HybridFetchSpec {
  func get(url: String) -> AnyMapHolder
}

```

```codeBlockLines_AclH
class HybridFetch: HybridFetchSpec() {
  fun get(url: String): AnyMap
}

```

```codeBlockLines_AclH
class HybridFetch: public HybridFetchSpec {
  std::shared_ptr<AnyMap> get(const std::string& url);
}

```

tip

While untyped maps are implemented efficiently, Nitro cannot sufficiently optimize the object as keys and value-types are not known in advance.
If possible, **avoid untyped maps** and use [strongly typed objects](https://nitro.margelo.com/docs/types/custom-types) instead.

## Understanding Variants in Types
[Skip to main content](https://nitro.margelo.com/docs/types/variants#__docusaurus_skipToContent_fallback)

On this page

A Variant is a type of either one of the values defined in it's declaration. Example:

```codeBlockLines_AclH
interface Math extends HybridObject {
  distance(value: number | Point): number
}

```

tip

While variants are still very efficient, they need runtime-checks for type conversions,
which comes with a tiny overhead compared to all other statically defined types. If possible, **avoid variants**.

## Custom Alias Names [​](https://nitro.margelo.com/docs/types/variants\#custom-alias-names "Direct link to Custom Alias Names")

Each variant is a unique type in Swift/Kotlin - for example: `string | number` becomes `Variant_String_Double`.

Since the generated names are hard to read, it is recommended to declare type-aliases with custom names instead:

Bad ❌

```codeBlockLines_AclH
export interface Math extends HybridObject {
  calculate(): string | number
}

```

Good ✅

```codeBlockLines_AclH
export type MathOutput = string | number
export interface Math extends HybridObject {
  calculate(): MathOutput
}

```

This will then use the easier-to-read type-alias name instead of `Variant_String_Double`:

nitrogen/generated/ios/HybridMathSpec.swift

```codeBlockLines_AclH
public protocol HybridMathSpec: HybridObject {
  func calculate() -> Variant_String_Double
  func calculate() -> MathOutput
}

```

- [Custom Alias Names](https://nitro.margelo.com/docs/types/variants#custom-alias-names)

## Using Nitro in React Native
[Skip to main content](https://nitro.margelo.com/docs/using-nitro-in-a-library#__docusaurus_skipToContent_fallback)

On this page

Nitro can be used as a simple C++ library in your React Native library, which is very lightweight and simple.

## 1\. Create a Nitro Module [​](https://nitro.margelo.com/docs/using-nitro-in-a-library\#1-create-a-nitro-module "Direct link to 1. Create a Nitro Module")

First, you need to create a [Nitro Module](https://nitro.margelo.com/docs/nitro-modules) \- either by just using the [Nitro Modules template](https://github.com/mrousavy/nitro/tree/main/packages/template), or by just adding `react-native-nitro-modules` to your existing React Native library.

## 2\. Create Hybrid Objects [​](https://nitro.margelo.com/docs/using-nitro-in-a-library\#2-create-hybrid-objects "Direct link to 2. Create Hybrid Objects")

To actually use Nitro, you need to create [Hybrid Objects](https://nitro.margelo.com/docs/hybrid-objects) \- either by using Nitro's code-generator CLI “ [Nitrogen](https://nitro.margelo.com/docs/nitrogen)”, or by just manually extending the `HybridObject` base class in C++.

## 3\. Register Hybrid Objects [​](https://nitro.margelo.com/docs/using-nitro-in-a-library\#3-register-hybrid-objects "Direct link to 3. Register Hybrid Objects")

Each Hybrid Object you want to initialize from JS has to be registered in Nitro - either by autolinking them with Nitrogen (see [Configuration (Autolinking)](https://nitro.margelo.com/docs/configuration-nitro-json#autolinking)), or by manually registering the constructors in the [`HybridObjectRegistry`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/cpp/registry/HybridObjectRegistry.hpp).

## 4\. Use your Hybrid Objects in JS [​](https://nitro.margelo.com/docs/using-nitro-in-a-library\#4-use-your-hybrid-objects-in-js "Direct link to 4. Use your Hybrid Objects in JS")

Lastly, you can initialize and use the registered Hybrid Objects from JS. This is what this will ultimately look like:

```codeBlockLines_AclH
interface Math extends HybridObject {
  add(a: number, b: number): number
}

const math = NitroModules.createHybridObject<Math>("Math")
const value = math.add(5, 7) // --> 12

```

## 5\. Run it [​](https://nitro.margelo.com/docs/using-nitro-in-a-library\#5-run-it "Direct link to 5. Run it")

To test the library you just created, you now need to set up an example app for it.
There's multiple different ways to set up a react-native app nowadays, either via Expo, RN CLI, or bare brownfield iOS/Android apps.

For example, to create a new Expo app, run `create-expo-app`:

```codeBlockLines_AclH
npx create-expo-app@latest

```

Then add the Nitro Module you created in step 1 as a local library (aka _linking it_), and run it.

- [1\. Create a Nitro Module](https://nitro.margelo.com/docs/using-nitro-in-a-library#1-create-a-nitro-module)
- [2\. Create Hybrid Objects](https://nitro.margelo.com/docs/using-nitro-in-a-library#2-create-hybrid-objects)
- [3\. Register Hybrid Objects](https://nitro.margelo.com/docs/using-nitro-in-a-library#3-register-hybrid-objects)
- [4\. Use your Hybrid Objects in JS](https://nitro.margelo.com/docs/using-nitro-in-a-library#4-use-your-hybrid-objects-in-js)
- [5\. Run it](https://nitro.margelo.com/docs/using-nitro-in-a-library#5-run-it)

## Using Nitro in Apps
[Skip to main content](https://nitro.margelo.com/docs/using-nitro-in-your-app#__docusaurus_skipToContent_fallback)

On this page

While most libraries are built with Nitro and shipped over npm, you can also easily build a library with Nitro in your app - that's the "brownfield" way of doing things.

## Installing Nitro [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#installing-nitro "Direct link to Installing Nitro")

First, you need to install the Nitro Modules core package from npm:

- npm
- yarn
- pnpm
- bun

```codeBlockLines_AclH
npm i react-native-nitro-modules
cd ios && pod install

```

```codeBlockLines_AclH
yarn add react-native-nitro-modules
cd ios && pod install

```

```codeBlockLines_AclH
pnpm add react-native-nitro-modules
cd ios && pod install

```

```codeBlockLines_AclH
bun i react-native-nitro-modules
cd ios && pod install

```

## Creating a Hybrid Object [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#creating-a-hybrid-object "Direct link to Creating a Hybrid Object")

After installing Nitro, you can start creating your [Hybrid Objects](https://nitro.margelo.com/docs/hybrid-objects) \- either with [Nitrogen](https://nitro.margelo.com/docs/nitrogen), or manually:

- With Nitrogen ✨
- Manually

Nitrogen will ✨ automagically ✨ generate native specifications for each Hybrid Object based on a given TypeScript definition.

### 1\. Installing Nitrogen [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#1-installing-nitrogen "Direct link to 1. Installing Nitrogen")

First, install Nitrogen:

- npm
- yarn
- pnpm
- bun

```codeBlockLines_AclH
npm i nitro-codegen --save-dev

```

```codeBlockLines_AclH
yarn add nitro-codegen -D

```

```codeBlockLines_AclH
pnpm add nitro-codegen -D

```

```codeBlockLines_AclH
bun i nitro-codegen -d

```

warning

Nitrogen is currently named `nitro-codegen` instead of `nitrogen` on npm.

Then, create your `nitro.json` configuration in your app's root directory:

```codeBlockLines_AclH
{
  "$schema": "https://nitro.margelo.com/nitro.schema.json",
  "cxxNamespace": ["example"],
  "ios": {
    "iosModuleName": "NitroExample"
  },
  "android": {
    "androidNamespace": ["example"],
    "androidCxxLibName": "NitroExample"
  },
  "autolinking": {}
}

```

Note: Replace `Example` with your app's name.

### 2\. Creating Nitro specs [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#2-creating-nitro-specs "Direct link to 2. Creating Nitro specs")

Now it's time to create your first spec. Let's create `Math.nitro.ts`:

Math.nitro.ts

```codeBlockLines_AclH
interface Math extends HybridObject<{ ios: 'swift', android: 'kotlin' }> {
  readonly pi: number
  add(a: number, b: number): number
}

```

And now let's run Nitrogen:

```codeBlockLines_AclH
npx nitro-codegen

```

warning

Nitrogen is currently named `nitro-codegen` instead of `nitrogen` on npm.

This will generate the native Swift and Kotlin protocol " `HybridMathSpec`", as well as some helper classes for autolinking and bridging to C++.

### 3\. Adding the generated sources to your project [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#3-adding-the-generated-sources-to-your-project "Direct link to 3. Adding the generated sources to your project")

You now need to add the generated sources to your project - either by creating a sub-package that you will use in your app (e.g. in a monorepo), or by just manually adding the source files:

- Manually
- Via a subpackage

#### iOS [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#ios "Direct link to iOS")

On iOS, you just need to drag and drop the `nitrogen/generated/ios` and `nitrogen/generated/shared` folders into your Xcode project. That's it.

#### Android [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#android "Direct link to Android")

For Android, you need to add everything in `nitrogen/generated/android` and `nitrogen/generated/shared` to your build.gradle (Java/Kotlin source) and CMake (C++ sources) project.

##### Java/Kotlin sources ( `build.gradle`) [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#javakotlin-sources-buildgradle "Direct link to javakotlin-sources-buildgradle")

Add the Java/Kotlin sources to your Gradle project by including the generated autolinking gradle file. Simply add this to the top of your `app/build.gradle`:

```codeBlockLines_AclH
apply from: '../nitrogen/generated/android/NitroExample+autolinking.gradle'

```

##### C++ sources ( `CMakeLists.txt`) [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#c-sources-cmakeliststxt "Direct link to c-sources-cmakeliststxt")

Add the C++ sources to your CMake project by including the generated autolinking CMake file. If you do not have a CMake setup yet, make sure to configure CMake through `externalNativeBuild` in `build.gradle`. Simply add this to your `CMakeLists.txt`:

```codeBlockLines_AclH
include(${CMAKE_SOURCE_DIR}/../nitrogen/generated/android/NitroImage+autolinking.cmake)

```

#### iOS [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#ios-1 "Direct link to iOS")

On iOS, you need to create a local Podspec ( `$$iosModuleName$$.podspec`). In this local pod you need to include the autolinking code that has been generated by Nitrogen:

```codeBlockLines_AclH
load 'nitrogen/generated/ios/NitroExample+autolinking.rb'
add_nitrogen_files(s)

```

And then just add this local Pod to your `Podfile`:

```codeBlockLines_AclH
pod '$$iosModuleName$$', :path => '../'

```

#### Android [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#android-1 "Direct link to Android")

On Android, you need to create a local Android library ( `build.gradle`). This library also needs to set up a CMake build (via `externalNativeBuild`). See the template for an example.

Inside the local Android library's `build.gradle`, add the autogenerated Java/Kotlin sources:

```codeBlockLines_AclH
apply from: '../nitrogen/generated/android/NitroExample+autolinking.gradle'

```

Inside the local Android library's `CMakeLists.txt`, add the autogenerated C++ sources:

```codeBlockLines_AclH
include(${CMAKE_SOURCE_DIR}/../nitrogen/generated/android/NitroImage+autolinking.cmake)

```

And lastly, add this local Android library to your app's `build.gradle` using `dependencies`:

```codeBlockLines_AclH
// ...
dependencies {
  // ...
  implementation project(':your-local-library')
}

```

You might also need to include the local library in your app's `settings.gradle`:

```codeBlockLines_AclH
include ':your-local-library'

```

### 4\. Implement Hybrid Object Specs [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#4-implement-hybrid-object-specs "Direct link to 4. Implement Hybrid Object Specs")

After adding the generated sources to your project, you can start implementing the spec in a class:

- Swift
- Kotlin

HybridMath.swift

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  public var pi: Double {
    return Double.pi
  }
  public func add(a: Double, b: Double) throws -> Double {
    return a + b
  }
}

```

HybridMath.kt

```codeBlockLines_AclH
class HybridMath : HybridMathSpec() {
  override var pi: Double
    get() = Double.PI

  override fun add(a: Double, b: Double): Double {
    return a + b
  }
}

```

### 5\. Registering the Hybrid Objects [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#5-registering-the-hybrid-objects "Direct link to 5. Registering the Hybrid Objects")

Nitro needs to be able to initialize an instance of your Hybrid Object - so we need to tell it how to do that.
In your `nitro.json`, register `HybridMath` in the `"autolinking"` section:

- Swift/Kotlin
- C++

```codeBlockLines_AclH
{
  ...
  "autolinking": {
    "Math": {
      "swift": "HybridMath",
      "kotlin": "HybridMath"
    }
  }
}

```

warning

- Make sure `HybridMath` is default-constructible. That is, it has a public initializer that takes no arguments.
- Make sure the Java/Kotlin class `HybridMath` is inside the package/namespace `com.margelo.nitro.$$androidNamespace$$` (as configured in `nitro.json`).
- Make sure the Java/Kotlin class `HybridMath` is annotated with `@DoNotStrip` to avoid it from being compiled out in production builds.

```codeBlockLines_AclH
{
  ...
  "autolinking": {
    "Math": {
      "cpp": "HybridMath"
    }
  }
}

```

warning

- Make sure `HybridMath` is default-constructible. That is, it has a public constructor that takes no arguments.
- Make sure the `HybridMath` class is defined in a header named `HybridMath.hpp` \- this is what Nitro will import.
- Also make sure `HybridMath` is either in the global namespace, or in `margelo::nitro::<cxxNamespace>` (configured in `nitro.json`).

For more information, see the [Nitrogen documentation](https://nitro.margelo.com/docs/nitrogen).

Manually creating Hybrid Objects is quite easy, but since Nitro is a C++ library, you need to use C++.
You can bridge the implementations of those methods to Swift/Objective-C/Java/Kotlin/Rust yourself, but Nitrogen usually does all of that ✨ automagically ✨.

Simply create your C++ classes and inherit from `HybridObject`:

HybridMath.hpp

```codeBlockLines_AclH
class HybridMath: public HybridObject {
public:
  HybridMath(): HybridObject(NAME) { }

public:
  double add(double a, double b);

protected:
  void loadHybridMethods() override;

private:
  static constexpr auto NAME = "Math";
};

```

HybridMath.cpp

```codeBlockLines_AclH
double HybridMath::add(double a, double b) {
  return a + b;
}

void HybridMath::loadHybridMethods() {
  // register base methods (toString, ...)
  HybridObject::loadHybridMethods();
  // register custom methods (add)
  registerHybrids(this, [](Prototype& proto) {
    proto.registerHybridMethod(
      "add",
      &HybridMath::add
    );
  });
}

```

Then, register the Hybrid Object constructor somewhere on app startup - e.g. in `AppDelegate`'s `application:didFinishLaunchingWithOptions:`, or in your `cpp-adapter`'s JNI on load:

```codeBlockLines_AclH
HybridObjectRegistry::registerHybridObjectConstructor(
  "Math",
  []() -> std::shared_ptr<HybridObject> {
    return std::make_shared<HybridMath>();
  }
);

```

## Using your Hybrid Objects [​](https://nitro.margelo.com/docs/using-nitro-in-your-app\#using-your-hybrid-objects "Direct link to Using your Hybrid Objects")

And finally, to initialize `HybridMath` from JS you just need to call `createHybridObject`:

```codeBlockLines_AclH
export const MathModule = NitroModules.createHybridObject<Math>("Math")
const result = MathModule.add(5, 7)

```

note

If this call failed, you might have forgotten to register your Hybrid Object's constructor in the `HybridObjectRegistry`.

- [Installing Nitro](https://nitro.margelo.com/docs/using-nitro-in-your-app#installing-nitro)
- [Creating a Hybrid Object](https://nitro.margelo.com/docs/using-nitro-in-your-app#creating-a-hybrid-object)
  - [1\. Installing Nitrogen](https://nitro.margelo.com/docs/using-nitro-in-your-app#1-installing-nitrogen)
  - [2\. Creating Nitro specs](https://nitro.margelo.com/docs/using-nitro-in-your-app#2-creating-nitro-specs)
  - [3\. Adding the generated sources to your project](https://nitro.margelo.com/docs/using-nitro-in-your-app#3-adding-the-generated-sources-to-your-project)
  - [4\. Implement Hybrid Object Specs](https://nitro.margelo.com/docs/using-nitro-in-your-app#4-implement-hybrid-object-specs)
  - [5\. Registering the Hybrid Objects](https://nitro.margelo.com/docs/using-nitro-in-your-app#5-registering-the-hybrid-objects)
- [Using your Hybrid Objects](https://nitro.margelo.com/docs/using-nitro-in-your-app#using-your-hybrid-objects)

## Nitro View Components Guide
[Skip to main content](https://nitro.margelo.com/docs/view-components#__docusaurus_skipToContent_fallback)

On this page

Nitro provides first-class support for creating React Native Views.

Such views can be rendered within React Native apps using [Fabric](https://reactnative.dev/architecture/fabric-renderer), and are backed by a C++ ShadowNode.
The key difference to a Fabric view is that it uses Nitro for prop parsing, which is more lightweight, performant and flexible.

note

Nitro Views require **react-native 0.78.0** or higher, and require the new architecture.

## Create a Nitro View [​](https://nitro.margelo.com/docs/view-components\#create-a-nitro-view "Direct link to Create a Nitro View")

### 1\. Declaration [​](https://nitro.margelo.com/docs/view-components\#1-declaration "Direct link to 1. Declaration")

To create a new Nitro View, declare it's props and methods in a `*.nitro.ts` file, and create a type that specializes `HybridView<P, M>` \- here `CameraView`:

Camera.nitro.ts

```codeBlockLines_AclH
import type { HybridView, HybridViewProps, HybridViewMethods } from 'react-native-nitro-modules'

export interface CameraProps extends HybridViewProps {
  enableFlash: boolean
}
export interface CameraMethods extends HybridViewMethods { }

export type CameraView = HybridView<CameraProps, CameraMethods>

```

### 2\. Code Generation [​](https://nitro.margelo.com/docs/view-components\#2-code-generation "Direct link to 2. Code Generation")

Then, run [nitrogen](https://nitro.margelo.com/docs/nitrogen):

- npm
- yarn
- pnpm
- bun

```codeBlockLines_AclH
npx nitro-codegen

```

```codeBlockLines_AclH
yarn nitro-codegen

```

```codeBlockLines_AclH
pnpm nitro-codegen

```

```codeBlockLines_AclH
bun nitro-codegen

```

This will create a C++ ShadowNode, with an iOS (Swift) and Android (Kotlin) interface, just like any other [Hybrid Object](https://nitro.margelo.com/docs/hybrid-objects).
Additionally, a view config ( `CameraViewConfig.json`) will be generated - this is required by Fabric.

### 3\. Implementation [​](https://nitro.margelo.com/docs/view-components\#3-implementation "Direct link to 3. Implementation")

Now it's time to implement the View - simply create a new Swift/Kotlin class/file, extend from `HybridCameraViewSpec` and implement your `.enableFlash` property, as well as the common `.view` accessor:

- Swift
- Kotlin

HybridCameraView.swift

```codeBlockLines_AclH
class HybridCameraView : HybridCameraViewSpec {
  // Props
  var enableFlash: Bool = false

  // View
  var view: UIView = UIView()
}

```

HybridCameraView.kt

```codeBlockLines_AclH
class HybridCameraView(val context: ThemedReactContext) : HybridCameraViewSpec() {
  // Props
  override var enableFlash: Boolean = false

  // View
  override val view: View = View(context)
}

```

### 4\. Autolink [​](https://nitro.margelo.com/docs/view-components\#4-autolink "Direct link to 4. Autolink")

Just like any other Hybrid Object, add the Hybrid View to your `nitro.json`'s autolinking configuration:

nitro.json

```codeBlockLines_AclH
{
  // ...
  "autolinking": {
    "CameraView": {
      "swift": "HybridCameraView",
      "kotlin": "HybridCameraView"
    }
  }
}

```

Now run nitrogen again.

### 5\. Initialization [​](https://nitro.margelo.com/docs/view-components\#5-initialization "Direct link to 5. Initialization")

Then, to use the view in JavaScript, use `getHostComponent(..)`:

```codeBlockLines_AclH
import { getHostComponent } from 'react-native-nitro-modules'
import CameraViewConfig from '../nitrogen/generated/shared/json/CameraViewConfig.json'

export const Camera = getHostComponent<CameraProps, CameraMethods>(
  'Camera',
  () => CameraViewConfig
)

```

### 6\. Rendering [​](https://nitro.margelo.com/docs/view-components\#6-rendering "Direct link to 6. Rendering")

And finally, render it:

```codeBlockLines_AclH
function App() {
  return <Camera enableFlash={true} />
}

```

## Props [​](https://nitro.margelo.com/docs/view-components\#props "Direct link to Props")

Since every `HybridView` is also a `HybridObject`, you can use any type that Nitro supports as a property - including custom types ( `interface`), `ArrayBuffer`, and even other `HybridObject` s!

For example, a custom `<ImageView>` component can be used to render custom `Image` types:

Image.nitro.ts

```codeBlockLines_AclH
export interface Image extends HybridObject {
  readonly width: number
  readonly height: number
  save(): Promise<string>
}

```

ImageView.nitro.ts

```codeBlockLines_AclH
import { type Image } from './Image.nitro.ts'
export interface ImageProps extends HybridViewProps {
  image: Image
}
export type ImageView = HybridView<ImageProps>

```

Then;

```codeBlockLines_AclH
function App() {
  const image = await loadImage('https://...')
  return <ImageView image={image} />
}

```

### Threading [​](https://nitro.margelo.com/docs/view-components\#threading "Direct link to Threading")

Since Nitro bridges props directly to JS, you are responsible for ensuring thread-safety.

- If props are set normally via React, they will be set on the UI Thread.
- If the user sets props on the view `hybridRef` (e.g. also if the `HybridView` is passed to a `HybridObject` in native), props _could_ be set on a different Thread, like the JS Thread.

### Before/After update [​](https://nitro.margelo.com/docs/view-components\#beforeafter-update "Direct link to Before/After update")

To batch prop changes, you can override `beforeUpdate()` and `afterUpdate()` in your views:

- Swift
- Kotlin

HybridCameraView.swift

```codeBlockLines_AclH
class HybridCameraView : HybridCameraViewSpec {
  // View
  var view: UIView = UIView()

  func beforeUpdate() { }
  func afterUpdate() { }
}

```

HybridCameraView.kt

```codeBlockLines_AclH
class HybridCameraView : HybridCameraViewSpec() {
  // View
  override val view: View = View(NitroModules.applicationContext)

  override fun beforeUpdate() { }
  override fun afterUpdate() { }
}

```

### Callbacks have to be wrapped [​](https://nitro.margelo.com/docs/view-components\#callbacks-have-to-be-wrapped "Direct link to Callbacks have to be wrapped")

Whereas Nitro allows passing JS functions to native code directly, React Native core doesn't allow that. Instead, functions are wrapped in an event listener registry, and a simple boolean is passed to the native side.
Unfortunately React Native's renderer does not allow changing this behaviour, so functions cannot be passed directly to Nitro Views. As a workaround, Nitro requires you to wrap each function in an object, which bypasses React Native's conversion.

So every function ( `() => void`) has to be wrapped in an object with one key - `f` \- which holds the function: `{ f: () => void }`

```codeBlockLines_AclH
export interface CameraProps extends HybridViewProps {
  onCaptured: (image: Image) => void
}
export type CameraView = HybridView<CameraProps>

function App() {
  return <Camera onCaptured={(i) => console.log(i)} />
  return <Camera onCaptured={{ f: (i) => console.log(i) }} />
}

```

info

We are working on a fix here: [facebook/react #32119](https://github.com/facebook/react/pull/32119)

## Methods [​](https://nitro.margelo.com/docs/view-components\#methods "Direct link to Methods")

Since every `HybridView` is also a `HybridObject`, methods can be directly called on the object.
Assuming our `<Camera>` component has a `takePhoto()` function like so:

```codeBlockLines_AclH
export interface CameraProps extends HybridViewProps { ... }
export interface CameraMethods extends HybridViewMethods {
  takePhoto(): Promise<Image>
}

export type CameraView = HybridView<CameraProps, CameraMethods>

```

To call the function, you would need to get a reference to the `HybridObject` first using `hybridRef`:

```codeBlockLines_AclH
function App() {
  return (
    <Camera
      hybridRef={{
        f: (ref) => {
          const image = ref.takePhoto()
        }
      }}
    />
  )
}

```

> Note: If you're wondering about the `{ f: ... }` syntax, see ["Callbacks have to be wrapped"](https://nitro.margelo.com/docs/view-components#callbacks-have-to-be-wrapped).

The `ref` from within `hybridRef`'s callback is pointing to the `HybridObject` directly - you can also pass this around freely.

- [Create a Nitro View](https://nitro.margelo.com/docs/view-components#create-a-nitro-view)
  - [1\. Declaration](https://nitro.margelo.com/docs/view-components#1-declaration)
  - [2\. Code Generation](https://nitro.margelo.com/docs/view-components#2-code-generation)
  - [3\. Implementation](https://nitro.margelo.com/docs/view-components#3-implementation)
  - [4\. Autolink](https://nitro.margelo.com/docs/view-components#4-autolink)
  - [5\. Initialization](https://nitro.margelo.com/docs/view-components#5-initialization)
  - [6\. Rendering](https://nitro.margelo.com/docs/view-components#6-rendering)
- [Props](https://nitro.margelo.com/docs/view-components#props)
  - [Threading](https://nitro.margelo.com/docs/view-components#threading)
  - [Before/After update](https://nitro.margelo.com/docs/view-components#beforeafter-update)
  - [Callbacks have to be wrapped](https://nitro.margelo.com/docs/view-components#callbacks-have-to-be-wrapped)
- [Methods](https://nitro.margelo.com/docs/view-components#methods)

## Nitro Framework Overview
[Skip to main content](https://nitro.margelo.com/docs/what-is-nitro#__docusaurus_skipToContent_fallback)

On this page

Nitro is a framework for building powerful and fast native modules for JS.
Put simply, a JS object can be implemented in C++, Swift or Kotlin instead of JS by using Nitro.

While Nitro's primary environment is React Native, it also works in any other environment that uses JSI.

- A [**Nitro Module**](https://nitro.margelo.com/docs/nitro-modules) is a library built with Nitro. It contains one or more **Hybrid Objects**.
- A [**Hybrid Object**](https://nitro.margelo.com/docs/hybrid-objects) is a native object in Nitro, implemented in either C++, Swift or Kotlin.
- [**Nitrogen**](https://nitro.margelo.com/docs/nitrogen) is a code-generator a library author can use to generate native bindings from a custom TypeScript interface.

Math.nitro.ts

```codeBlockLines_AclH
interface Math extends HybridObject {
  readonly pi: number
  add(a: number, b: number): number
}

```

HybridMath.swift

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  var pi: Double {
    return Double.pi
  }
  func add(a: Double, b: Double) -> Double {
    return a + b
  }
}

```

This Hybrid Object can then be accessed directly from JS:

```codeBlockLines_AclH
const math = NitroModules.createHybridObject<Math>('Math')
const result = math.add(5, 7)

```

## Performance [​](https://nitro.margelo.com/docs/what-is-nitro\#performance "Direct link to Performance")

Nitro is all about **performance**. [This benchmark](https://github.com/mrousavy/NitroBenchmarks) compares the total execution time when calling a single native method 100.000 times:

|  | ExpoModules | TurboModules | NitroModules |
| --- | --- | --- | --- |
| 100.000x `addNumbers(...)` | 434.85ms | 115.86ms | **7.27ms** |
| 100.000x `addStrings(...)` | 429.53ms | 179.02ms | **29.94ms** |

Note: These benchmarks only compare native method throughput in extreme cases, and do not necessarily reflect real world use-cases. In a real-world app, results may vary. See [NitroBenchmarks](https://github.com/mrousavy/NitroBenchmarks) for full context.

### Lightweight layer [​](https://nitro.margelo.com/docs/what-is-nitro\#lightweight-layer "Direct link to Lightweight layer")

While Nitro is built on top of JSI, the layer is very lightweight and efficient.
Many things like type-checking is compile-time only, and built with C++ templates or `constexpr` which introduces zero runtime overhead.

### Direct Swift <> C++ interop [​](https://nitro.margelo.com/docs/what-is-nitro\#direct-swift--c-interop "Direct link to Direct Swift <> C++ interop")

Unlike Turbo- or Expo-Modules, Nitro-Modules does not use Objective-C at all.
Nitro is built using the new [Swift <> C++ interop](https://www.swift.org/documentation/cxx-interop/), which is close to zero-overhead.

### Uses `jsi::NativeState` [​](https://nitro.margelo.com/docs/what-is-nitro\#uses-jsinativestate "Direct link to uses-jsinativestate")

Hybrid Objects in Nitro are built on top of `jsi::NativeState`, which is more efficient than `jsi::HostObject`. Such objects have proper native prototypes, and their native memory size is known, which allows the garbage collector to properly clean up unused objects.

## Type Safety [​](https://nitro.margelo.com/docs/what-is-nitro\#type-safety "Direct link to Type Safety")

Nitro Modules are **type-safe** and **null-safe**. By using Nitro's code-generator, [nitrogen](https://nitro.margelo.com/docs/nitrogen), TypeScript specs are the single source of truth as generated native interfaces have to exactly represent the declared types.
If a function declares a `number`, you can only implement it on the native side as a `Double`, otherwise the app will not compile.

Math.nitro.ts

```codeBlockLines_AclH
interface Math extends HybridObject {
  add(a: number, b: number): number
}

```

HybridMath.swift

```codeBlockLines_AclH
class HybridMath : HybridMathSpec {
  func add(a: Double, b: Double) -> String {
//  Compile-error: Expected Double! ^
    return a + b
  }
}

```

### Null-safety [​](https://nitro.margelo.com/docs/what-is-nitro\#null-safety "Direct link to Null-safety")

There is no way for a Nitro Module to return a type that is not expected in TypeScript, which also guarantees null-safety.

```codeBlockLines_AclH
interface Math extends HybridObject {
  getValue(): number
  getValueOrNull(): number | undefined
}

```

## Object-Oriented approach [​](https://nitro.margelo.com/docs/what-is-nitro\#object-oriented-approach "Direct link to Object-Oriented approach")

Every Hybrid Object in Nitro is a native object, which can be created, passed around, and destroyed.

```codeBlockLines_AclH
interface Image extends HybridObject {
  readonly width: number
  readonly height: number
  saveToFile(path: string): Promise<void>
}

interface ImageEditor extends HybridObject {
  loadImage(path: string): Promise<Image>
  crop(image: Image, size: Size): Image
}

```

Functions (or "callbacks") are also first-class citizens of Nitro, which means they can safely be kept in memory, called as often as needed, and will automatically be cleaned up when no longer needed.
This is somewhat similar to how other frameworks (like Turbo-Modules) implement "events".

## Modern Languages [​](https://nitro.margelo.com/docs/what-is-nitro\#modern-languages "Direct link to Modern Languages")

Nitro is a modern framework, built on top of modern languages like Swift and Kotlin.
It has first-class support for modern language features.

### Swift [​](https://nitro.margelo.com/docs/what-is-nitro\#swift "Direct link to Swift")

Nitro bridges to Swift directly using the new highly efficient [Swift <> C++ interop](https://www.swift.org/documentation/cxx-interop/).

- **Protocols**: Every Hybrid Object's generated specification is a [Swift protocol](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols/).
- **Properties**: A getter (and setter) property can be implemented using [Swift properties](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties/).
- **Async**/ **Await**: Asynchronous functions can use Swift's new [async/await syntax](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/) using the `Promise.async` API.
- **No Objective-C**: Instead of bridging through Objective-C interfaces, Nitro bridges to Swift directly from C++.

### Kotlin [​](https://nitro.margelo.com/docs/what-is-nitro\#kotlin "Direct link to Kotlin")

Nitro bridges to Kotlin directly using [fbjni](https://github.com/facebookincubator/fbjni).

- **Interfaces**: Every Hybrid Object's generated specification is a [Kotlin interface](https://kotlinlang.org/docs/interfaces.html).
- **Properties**: A getter (and setter) property can be implemented using [Kotlin properties](https://kotlinlang.org/docs/properties.html).
- **Coroutines**: Asynchronous functions can use Kotlin's [coroutine syntax](https://kotlinlang.org/docs/coroutines-overview.html) using the `Promise.async` API.
- **No Java**: Instead of requiring Java classes, Nitro bridges to Kotlin directly.

- [Performance](https://nitro.margelo.com/docs/what-is-nitro#performance)
  - [Lightweight layer](https://nitro.margelo.com/docs/what-is-nitro#lightweight-layer)
  - [Direct Swift <> C++ interop](https://nitro.margelo.com/docs/what-is-nitro#direct-swift--c-interop)
  - [Uses `jsi::NativeState`](https://nitro.margelo.com/docs/what-is-nitro#uses-jsinativestate)
- [Type Safety](https://nitro.margelo.com/docs/what-is-nitro#type-safety)
  - [Null-safety](https://nitro.margelo.com/docs/what-is-nitro#null-safety)
- [Object-Oriented approach](https://nitro.margelo.com/docs/what-is-nitro#object-oriented-approach)
- [Modern Languages](https://nitro.margelo.com/docs/what-is-nitro#modern-languages)
  - [Swift](https://nitro.margelo.com/docs/what-is-nitro#swift)
  - [Kotlin](https://nitro.margelo.com/docs/what-is-nitro#kotlin)

## Nitro Worklets Guide
[Skip to main content](https://nitro.margelo.com/docs/worklets#__docusaurus_skipToContent_fallback)

On this page

Nitro itself is fully runtime-agnostic, which means every [Hybrid Object](https://nitro.margelo.com/docs/hybrid-objects) can be used from any JS Runtime or Worklet Context.

This allows the caller to call into native Nitro Modules from libraries like [react-native-worklets-core](https://github.com/margelo/react-native-worklets-core), or [react-native-reanimated](https://github.com/software-mansion/react-native-reanimated).
You can use a Nitro [Hybrid Object](https://nitro.margelo.com/docs/hybrid-objects) on the default React JS context, on the UI context, or on any other background worklet context.

- Worklets Core
- Reanimated

```codeBlockLines_AclH
const math = NitroModules.createHybridObject<Math>('Math')
const boxed = NitroModules.box(math)

const context = Worklets.createContext('DummyContext')
context.runAsync(() => {
  'worklet'
  const unboxed = boxed.unbox()
  console.log(unboxed.add(5, 3)) // --> 8
})

```

```codeBlockLines_AclH
const math = NitroModules.createHybridObject<Math>('Math')
const boxed = NitroModules.box(math)

runOnUI(() => {
  'worklet'
  const unboxed = boxed.unbox()
  console.log(unboxed.add(5, 3)) // --> 8
})()

```

## Boxing [​](https://nitro.margelo.com/docs/worklets\#boxing "Direct link to Boxing")

Since Nitro uses newer JSI APIs like `jsi::NativeState` \- which current worklet libraries (like [react-native-worklets-core](https://github.com/margelo/react-native-worklets-core) or [react-native-reanimated](https://github.com/software-mansion/react-native-reanimated)) do not yet fully support - Hybrid Objects cannot yet be _directly_ used in worklet contexts - they have to be _boxed_.

A _boxed_ Hybrid Object is a native `jsi::HostObject`, which is supported by worklet libraries. The process is as following:

1. In the runtime your `HybridObject` was created in (probably the default runtime), call `NitroModules.box(...)` to box it.
2. The boxed result can be shared in any (worklet-)runtime if needed.
3. To use the original `HybridObject`, simply call `.unbox()` on it in the desired (worklet-)runtime.
4. The result of `.unbox()` is the original `HybridObject` \- you can now call any methods on it as usual.

In future versions of [react-native-worklets-core](https://github.com/margelo/react-native-worklets-core) or [react-native-reanimated](https://github.com/software-mansion/react-native-reanimated) we expect fullly automatic `jsi::NativeState` support, which will make boxing obsolete.

## Dispatcher [​](https://nitro.margelo.com/docs/worklets\#dispatcher "Direct link to Dispatcher")

All synchronous APIs of Nitro work ✨ automagically ✨ on any runtime, but asynchronous APIs (Promises and callbacks) require a `Dispatcher`.
If you call an asynchronous API on a runtime that Nitro doesn't know, it likely doesn't have a `Dispatcher`, so it doesn't know how to call back to the JS Thread after the asynchronous operation has finished (Promise resolve or callback call).

If **you** created that `jsi::Runtime`, you need to create a `Dispatcher` for it and implement `runSync` and `runAsync`:

```codeBlockLines_AclH
#include <NitroModules/Dispatcher.hpp>
using namespace margelo::nitro;

class MyRuntimeDispatcher: public Dispatcher {
public:
  void runSync(std::function<void()>&& function) override;
  void runAsync(std::function<void()>&& function) override;
};

```

Then, simply install this `Dispatcher` into your runtime so Nitro can use it:

```codeBlockLines_AclH
auto myDispatcher = std::make_shared<MyRuntimeDispatcher>();
Dispatcher::installRuntimeGlobalDispatcher(myRuntime, myDispatcher);

```

This needs to be done once, ideally immediately as soon as possible after creating the `jsi::Runtime`.

Your `runSync` and `runAsync` implementations must run the given `function` on the same Thread that the `jsi::Runtime` was created on - see [`CallInvokerDispatcher.hpp`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/cpp/threading/CallInvokerDispatcher.hpp) for an example.

- [Boxing](https://nitro.margelo.com/docs/worklets#boxing)
- [Dispatcher](https://nitro.margelo.com/docs/worklets#dispatcher)


