---
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Using Nitro in a library

Nitro can be used as a simple lightweight C++/Swift/Kotlin dependency in your React Native library.

## 1. Create a Nitro Module

First, you need to create a [Nitro Module](nitro-modules) - either by bootstrapping a template using [nitrogen](nitrogen) or [react-native-builder-bob](https://github.com/callstack/react-native-builder-bob), or by manually adding Nitro to your existing library/app.

<Tabs groupId="template-bootstrap-cli">
  <TabItem value="nitrogen" label="nitrogen" default>
    ```sh
    npx nitro-codegen@latest init
    ```
  </TabItem>
  <TabItem value="bob" label="react-native-builder-bob">
    ```sh
    npx create-react-native-library@latest
    ```
  </TabItem>
  <TabItem value="manually" label="Manually">

    ### 1.1. Install Nitro and Nitrogen

    In your existing react-native library, install nitro and nitrogen as dev dependencies:
    ```sh
    npm install react-native-nitro-modules --save-dev
    npm install nitro-codegen --save-dev
    ```

    Then, you need to decide if you want to use Nitro's C++ library directly, or use [nitrogen](nitrogen) to generate specs:

    <Tabs groupId="no-nitro-at-all">
      <TabItem value="with-nitrogen" label="I will use Nitrogen later on" default>

        ### 1.2. Create a `nitro.json` file

        Then, create a `nitro.json` file. See [Configuration (`nitro.json`)](configuration-nitro-json) for a full guide.

        ### 1.3. Run nitrogen once

        To initialize the project (and add all files required for autolinking), run nitrogen once:

        ```sh
        npx nitro-codegen
        ```

        ### 1.4. Add nitro's generated autolinking files to your project

        #### iOS

        In your iOS `.podspec`, you need to load the `+autolinking.rb` file that was generated by nitrogen:
        ```ruby
        Pod::Spec.new do |s|
          // ...
          s.source_files = [ ... ]
          // diff-add
          load 'nitrogen/generated/ios/NitroExample+autolinking.rb'
          // diff-add
          add_nitrogen_files(s)
        ```

        #### Android

        In your Android's `build.gradle`, load the `+autolinking.gradle` file at top-level (after any `apply plugin` calls) to set up the Kotlin files for autolinking:

        ```groovy
        // ...
        apply plugin: 'com.android.library'
        apply plugin: 'org.jetbrains.kotlin.android'
        // diff-add
        apply from: '../nitrogen/generated/android/$$androidCxxLibName$$+autolinking.gradle'
        ```

        And also add the `+autolinking.cmake` file to your `CMakeLists.txt` to set up the C++/JNI autolinking:

        ```cmake
        add_library($$androidCxxLibName$$ SHARED
          ...
        )
        // diff-add
        include(${CMAKE_SOURCE_DIR}/../nitrogen/generated/android/$$androidCxxLibName$$+autolinking.cmake)
        ```

        And lastly, call the C++/JNI `initialize` function inside your library's `JNI_OnLoad(...)` entry point (often in `cpp-adapter.cpp`):

        ```cpp
        #include "$$androidCxxLibName$$OnLoad.hpp"

        JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*) {
          // diff-add
          return margelo::nitro::$$cxxNamespace$$::initialize(vm);
        }
        ```
      </TabItem>
      <TabItem value="without-nitrogen-at-all" label="I will not use Nitrogen">

        When you use Nitro's C++ library directly, you do not need to set up any autolinking files since you will be responsible for exposing your `HybridObject`s to JS.

      </TabItem>
    </Tabs>
  </TabItem>
</Tabs>

## 2. Create Hybrid Object specs

To actually use Nitro, you need to create [Hybrid Objects](hybrid-objects) - either by using Nitro's code-generator CLI “[Nitrogen](nitrogen)”, or by just manually extending the `HybridObject` base class in C++.

<Tabs groupId="nitrogen-or-not">
  <TabItem value="nitrogen" label="With Nitrogen ✨" default>

    ### 2.1. Write the HybridObject specs

    A spec is just a `*.nitro.ts` file that exports an interface, which extends `HybridObject`:

    ```ts title="Math.nitro.ts"
    export interface Math extends HybridObject {
      add(a: number, b: number): number
    }
    ```

    ### 2.2. Run nitrogen

    After writing specs, re-generate the generated code by running [nitrogen](nitrogen):

    ```sh
    npx nitro-codegen
    ```

    This then will generate a native specs which you can implement - in C++, that'd be `HybridMathSpec.hpp`.

    ### 2.3. Implement the generated native specs

    <Tabs groupId="native-language">
      <TabItem value="swift" label="Swift" default>
        ```swift title="HybridMath.swift"
        class HybridMath : HybridMathSpec {
          public func add(a: Double, b: Double) throws -> Double {
            return a + b
          }
        }
        ```
      </TabItem>
      <TabItem value="kotlin" label="Kotlin">
        ```kotlin title="HybridMath.kt"
        class HybridMath : HybridMathSpec() {
          override fun add(a: Double, b: Double): Double {
            return a + b
          }
        }
        ```
      </TabItem>
      <TabItem value="cpp" label="C++">
        ```kotlin title="HybridMath.hpp"
        class HybridMath: public HybridMathSpec {
        public:
          double add(double a, double b) override {
            return a + b;
          }
        }
        ```
      </TabItem>
    </Tabs>


  </TabItem>
  <TabItem value="manually" label="Manually">

    If you don't want to use nitrogen, you

    ```cpp title="HybridMath.hpp"
    #pragma once
    #include "JSIConverter+Float.hpp"
    // ...
    class HybridMath : public HybridObject {
    public:
      float add(float a, float b) {
        return a + b;
      }

      void loadHybridMethods() {
        HybridObject::loadHybridMethods();
        registerHybrids(this, [](Prototype& prototype) {
          prototype.registerHybridMethod("add", &HybridMath::add);
        });
      }
    }
    ```

    :::info
    Make sure the compiler knows about `JSIConverter<float>` at the time when `HybridMath` is declared, so import your `JSIConverter+Float.hpp` in your Hybrid Object's header file as well!
    :::

  </TabItem>
</Tabs>

## 3. Register Hybrid Objects

Each Hybrid Object you want to initialize from JS has to be registered in Nitro - either by autolinking them with Nitrogen (see [Configuration (Autolinking)](configuration-nitro-json#autolinking)), or by manually registering the constructors in the [`HybridObjectRegistry`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-modules/cpp/registry/HybridObjectRegistry.hpp).

## 4. Use your Hybrid Objects in JS

Lastly, you can initialize and use the registered Hybrid Objects from JS. This is what this will ultimately look like:

```ts
interface Math extends HybridObject {
  add(a: number, b: number): number
}

const math = NitroModules.createHybridObject<Math>("Math")
const value = math.add(5, 7) // --> 12
```

## 5. Run it

To test the library you just created, you now need to set up an example app for it.
There's multiple different ways to set up a react-native app nowadays, either via Expo, RN CLI, or bare brownfield iOS/Android apps.

For example, to create a new Expo app, run `create-expo-app`:

```sh
npx create-expo-app@latest
```

Then add the Nitro Module you created in step 1 as a local library (aka _linking it_), and run it.
