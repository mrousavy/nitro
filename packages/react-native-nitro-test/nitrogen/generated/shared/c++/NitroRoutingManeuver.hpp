///
/// NitroRoutingManeuver.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/JSIConverter.hpp>)
#include <NitroModules/JSIConverter.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/NitroDefines.hpp>)
#include <NitroModules/NitroDefines.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/JSIHelpers.hpp>)
#include <NitroModules/JSIHelpers.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/PropNameIDCache.hpp>)
#include <NitroModules/PropNameIDCache.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `NitroAttributedString` to properly resolve imports.
namespace margelo::nitro::test { struct NitroAttributedString; }
// Forward declaration of `AssetImage` to properly resolve imports.
namespace margelo::nitro::test { struct AssetImage; }
// Forward declaration of `GlyphImage` to properly resolve imports.
namespace margelo::nitro::test { struct GlyphImage; }
// Forward declaration of `TurnType` to properly resolve imports.
namespace margelo::nitro::test { enum class TurnType; }
// Forward declaration of `OffRampType` to properly resolve imports.
namespace margelo::nitro::test { enum class OffRampType; }
// Forward declaration of `OnRampType` to properly resolve imports.
namespace margelo::nitro::test { enum class OnRampType; }
// Forward declaration of `ForkType` to properly resolve imports.
namespace margelo::nitro::test { enum class ForkType; }
// Forward declaration of `KeepType` to properly resolve imports.
namespace margelo::nitro::test { enum class KeepType; }
// Forward declaration of `LaneGuidance` to properly resolve imports.
namespace margelo::nitro::test { struct LaneGuidance; }
// Forward declaration of `NitroColor` to properly resolve imports.
namespace margelo::nitro::test { struct NitroColor; }
// Forward declaration of `TravelEstimates` to properly resolve imports.
namespace margelo::nitro::test { struct TravelEstimates; }
// Forward declaration of `TrafficSide` to properly resolve imports.
namespace margelo::nitro::test { enum class TrafficSide; }
// Forward declaration of `ManeuverType` to properly resolve imports.
namespace margelo::nitro::test { enum class ManeuverType; }

#include "NitroAttributedString.hpp"
#include <vector>
#include "AssetImage.hpp"
#include "GlyphImage.hpp"
#include <variant>
#include <optional>
#include "TurnType.hpp"
#include "OffRampType.hpp"
#include "OnRampType.hpp"
#include "ForkType.hpp"
#include "KeepType.hpp"
#include "LaneGuidance.hpp"
#include "NitroColor.hpp"
#include <string>
#include "TravelEstimates.hpp"
#include "TrafficSide.hpp"
#include "ManeuverType.hpp"

namespace margelo::nitro::test {

  /**
   * A struct which can be represented as a JavaScript object (NitroRoutingManeuver).
   */
  struct NitroRoutingManeuver final {
  public:
    std::vector<NitroAttributedString> attributedInstructionVariants     SWIFT_PRIVATE;
    std::variant<AssetImage, GlyphImage> symbolImage     SWIFT_PRIVATE;
    std::optional<std::variant<AssetImage, GlyphImage>> junctionImage     SWIFT_PRIVATE;
    std::optional<TurnType> turnType     SWIFT_PRIVATE;
    std::optional<double> angle     SWIFT_PRIVATE;
    std::optional<std::vector<double>> elementAngles     SWIFT_PRIVATE;
    std::optional<double> exitNumber     SWIFT_PRIVATE;
    std::optional<OffRampType> offRampType     SWIFT_PRIVATE;
    std::optional<OnRampType> onRampType     SWIFT_PRIVATE;
    std::optional<ForkType> forkType     SWIFT_PRIVATE;
    std::optional<KeepType> keepType     SWIFT_PRIVATE;
    std::optional<LaneGuidance> linkedLaneGuidance     SWIFT_PRIVATE;
    NitroColor cardBackgroundColor     SWIFT_PRIVATE;
    std::string id     SWIFT_PRIVATE;
    TravelEstimates travelEstimates     SWIFT_PRIVATE;
    TrafficSide trafficSide     SWIFT_PRIVATE;
    ManeuverType maneuverType     SWIFT_PRIVATE;
    std::optional<std::vector<std::string>> roadName     SWIFT_PRIVATE;
    std::optional<std::string> highwayExitLabel     SWIFT_PRIVATE;

  public:
    NitroRoutingManeuver() = default;
    explicit NitroRoutingManeuver(std::vector<NitroAttributedString> attributedInstructionVariants, std::variant<AssetImage, GlyphImage> symbolImage, std::optional<std::variant<AssetImage, GlyphImage>> junctionImage, std::optional<TurnType> turnType, std::optional<double> angle, std::optional<std::vector<double>> elementAngles, std::optional<double> exitNumber, std::optional<OffRampType> offRampType, std::optional<OnRampType> onRampType, std::optional<ForkType> forkType, std::optional<KeepType> keepType, std::optional<LaneGuidance> linkedLaneGuidance, NitroColor cardBackgroundColor, std::string id, TravelEstimates travelEstimates, TrafficSide trafficSide, ManeuverType maneuverType, std::optional<std::vector<std::string>> roadName, std::optional<std::string> highwayExitLabel): attributedInstructionVariants(attributedInstructionVariants), symbolImage(symbolImage), junctionImage(junctionImage), turnType(turnType), angle(angle), elementAngles(elementAngles), exitNumber(exitNumber), offRampType(offRampType), onRampType(onRampType), forkType(forkType), keepType(keepType), linkedLaneGuidance(linkedLaneGuidance), cardBackgroundColor(cardBackgroundColor), id(id), travelEstimates(travelEstimates), trafficSide(trafficSide), maneuverType(maneuverType), roadName(roadName), highwayExitLabel(highwayExitLabel) {}

  public:
    // NitroRoutingManeuver is not equatable because these properties are not equatable: travelEstimates
  };

} // namespace margelo::nitro::test

namespace margelo::nitro {

  // C++ NitroRoutingManeuver <> JS NitroRoutingManeuver (object)
  template <>
  struct JSIConverter<margelo::nitro::test::NitroRoutingManeuver> final {
    static inline margelo::nitro::test::NitroRoutingManeuver fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
      jsi::Object obj = arg.asObject(runtime);
      return margelo::nitro::test::NitroRoutingManeuver(
        JSIConverter<std::vector<margelo::nitro::test::NitroAttributedString>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "attributedInstructionVariants"))),
        JSIConverter<std::variant<margelo::nitro::test::AssetImage, margelo::nitro::test::GlyphImage>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "symbolImage"))),
        JSIConverter<std::optional<std::variant<margelo::nitro::test::AssetImage, margelo::nitro::test::GlyphImage>>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "junctionImage"))),
        JSIConverter<std::optional<margelo::nitro::test::TurnType>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "turnType"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "angle"))),
        JSIConverter<std::optional<std::vector<double>>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "elementAngles"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "exitNumber"))),
        JSIConverter<std::optional<margelo::nitro::test::OffRampType>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "offRampType"))),
        JSIConverter<std::optional<margelo::nitro::test::OnRampType>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "onRampType"))),
        JSIConverter<std::optional<margelo::nitro::test::ForkType>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "forkType"))),
        JSIConverter<std::optional<margelo::nitro::test::KeepType>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "keepType"))),
        JSIConverter<std::optional<margelo::nitro::test::LaneGuidance>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "linkedLaneGuidance"))),
        JSIConverter<margelo::nitro::test::NitroColor>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cardBackgroundColor"))),
        JSIConverter<std::string>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "id"))),
        JSIConverter<margelo::nitro::test::TravelEstimates>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "travelEstimates"))),
        JSIConverter<margelo::nitro::test::TrafficSide>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "trafficSide"))),
        JSIConverter<margelo::nitro::test::ManeuverType>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "maneuverType"))),
        JSIConverter<std::optional<std::vector<std::string>>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "roadName"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "highwayExitLabel")))
      );
    }
    static inline jsi::Value toJSI(jsi::Runtime& runtime, const margelo::nitro::test::NitroRoutingManeuver& arg) {
      jsi::Object obj(runtime);
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "attributedInstructionVariants"), JSIConverter<std::vector<margelo::nitro::test::NitroAttributedString>>::toJSI(runtime, arg.attributedInstructionVariants));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "symbolImage"), JSIConverter<std::variant<margelo::nitro::test::AssetImage, margelo::nitro::test::GlyphImage>>::toJSI(runtime, arg.symbolImage));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "junctionImage"), JSIConverter<std::optional<std::variant<margelo::nitro::test::AssetImage, margelo::nitro::test::GlyphImage>>>::toJSI(runtime, arg.junctionImage));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "turnType"), JSIConverter<std::optional<margelo::nitro::test::TurnType>>::toJSI(runtime, arg.turnType));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "angle"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.angle));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "elementAngles"), JSIConverter<std::optional<std::vector<double>>>::toJSI(runtime, arg.elementAngles));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "exitNumber"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.exitNumber));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "offRampType"), JSIConverter<std::optional<margelo::nitro::test::OffRampType>>::toJSI(runtime, arg.offRampType));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "onRampType"), JSIConverter<std::optional<margelo::nitro::test::OnRampType>>::toJSI(runtime, arg.onRampType));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "forkType"), JSIConverter<std::optional<margelo::nitro::test::ForkType>>::toJSI(runtime, arg.forkType));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "keepType"), JSIConverter<std::optional<margelo::nitro::test::KeepType>>::toJSI(runtime, arg.keepType));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "linkedLaneGuidance"), JSIConverter<std::optional<margelo::nitro::test::LaneGuidance>>::toJSI(runtime, arg.linkedLaneGuidance));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "cardBackgroundColor"), JSIConverter<margelo::nitro::test::NitroColor>::toJSI(runtime, arg.cardBackgroundColor));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "id"), JSIConverter<std::string>::toJSI(runtime, arg.id));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "travelEstimates"), JSIConverter<margelo::nitro::test::TravelEstimates>::toJSI(runtime, arg.travelEstimates));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "trafficSide"), JSIConverter<margelo::nitro::test::TrafficSide>::toJSI(runtime, arg.trafficSide));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "maneuverType"), JSIConverter<margelo::nitro::test::ManeuverType>::toJSI(runtime, arg.maneuverType));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "roadName"), JSIConverter<std::optional<std::vector<std::string>>>::toJSI(runtime, arg.roadName));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "highwayExitLabel"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.highwayExitLabel));
      return obj;
    }
    static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
      if (!value.isObject()) {
        return false;
      }
      jsi::Object obj = value.getObject(runtime);
      if (!nitro::isPlainObject(runtime, obj)) {
        return false;
      }
      if (!JSIConverter<std::vector<margelo::nitro::test::NitroAttributedString>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "attributedInstructionVariants")))) return false;
      if (!JSIConverter<std::variant<margelo::nitro::test::AssetImage, margelo::nitro::test::GlyphImage>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "symbolImage")))) return false;
      if (!JSIConverter<std::optional<std::variant<margelo::nitro::test::AssetImage, margelo::nitro::test::GlyphImage>>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "junctionImage")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::test::TurnType>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "turnType")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "angle")))) return false;
      if (!JSIConverter<std::optional<std::vector<double>>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "elementAngles")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "exitNumber")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::test::OffRampType>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "offRampType")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::test::OnRampType>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "onRampType")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::test::ForkType>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "forkType")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::test::KeepType>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "keepType")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::test::LaneGuidance>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "linkedLaneGuidance")))) return false;
      if (!JSIConverter<margelo::nitro::test::NitroColor>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cardBackgroundColor")))) return false;
      if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "id")))) return false;
      if (!JSIConverter<margelo::nitro::test::TravelEstimates>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "travelEstimates")))) return false;
      if (!JSIConverter<margelo::nitro::test::TrafficSide>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "trafficSide")))) return false;
      if (!JSIConverter<margelo::nitro::test::ManeuverType>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "maneuverType")))) return false;
      if (!JSIConverter<std::optional<std::vector<std::string>>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "roadName")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "highwayExitLabel")))) return false;
      return true;
    }
  };

} // namespace margelo::nitro
