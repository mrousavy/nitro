///
/// HybridTestObjectRustSpecRust.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

#include <stdexcept>
#include "HybridTestObjectRustSpec.hpp"

#include <memory>
#include "HybridTestObjectRustSpec.hpp"
#include <optional>
#include <string>
#include <NitroModules/Null.hpp>
#include <variant>
#include <vector>
#include "Powertrain.hpp"
#include "OldEnum.hpp"
#include <functional>
#include "Person.hpp"
#include "PartialPerson.hpp"
#include "Car.hpp"
#include "HybridChildSpec.hpp"
#include <NitroModules/AnyMap.hpp>
#include <NitroModules/Promise.hpp>
#include <NitroModules/ArrayBuffer.hpp>
#include <unordered_map>
#include "MapWrapper.hpp"
#include <exception>
#include <chrono>
#include "JsStyleStruct.hpp"
#include "WrappedJsStruct.hpp"
#include "OptionalWrapper.hpp"
#include "OptionalCallback.hpp"
#include "WeirdNumbersEnum.hpp"
#include "HybridBaseSpec.hpp"
#include "HybridTestViewSpec.hpp"
#include <NitroTestExternal/HybridSomeExternalObjectSpec.hpp>
#include "ExternalObjectStruct.hpp"

// FFI result structs for error propagation from Rust
struct __FfiResult_bool { uint8_t is_ok; char* error; bool value; };
struct __FfiResult_cstr { uint8_t is_ok; char* error; const char* value; };
struct __FfiResult_f64 { uint8_t is_ok; char* error; double value; };
struct __FfiResult_i64 { uint8_t is_ok; char* error; int64_t value; };
struct __FfiResult_ptr { uint8_t is_ok; char* error; void* value; };
struct __FfiResult_u64 { uint8_t is_ok; char* error; uint64_t value; };
struct __FfiResult_void { uint8_t is_ok; char* error; };

// Forward declarations for Rust FFI functions
extern "C" {
  __FfiResult_ptr HybridTestObjectRustSpec_get_this_object(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_get_optional_hybrid(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_optional_hybrid(void* rustPtr, void* value);
  __FfiResult_f64 HybridTestObjectRustSpec_get_number_value(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_number_value(void* rustPtr, double value);
  __FfiResult_bool HybridTestObjectRustSpec_get_bool_value(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_bool_value(void* rustPtr, bool value);
  __FfiResult_cstr HybridTestObjectRustSpec_get_string_value(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_string_value(void* rustPtr, const char* value);
  __FfiResult_i64 HybridTestObjectRustSpec_get_int64_value(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_int64_value(void* rustPtr, int64_t value);
  __FfiResult_u64 HybridTestObjectRustSpec_get_uint64_value(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_uint64_value(void* rustPtr, uint64_t value);
  __FfiResult_void HybridTestObjectRustSpec_get_null_value(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_null_value(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_get_optional_string(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_optional_string(void* rustPtr, void* value);
  __FfiResult_ptr HybridTestObjectRustSpec_get_string_or_undefined(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_string_or_undefined(void* rustPtr, void* value);
  __FfiResult_ptr HybridTestObjectRustSpec_get_string_or_null(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_string_or_null(void* rustPtr, void* value);
  __FfiResult_ptr HybridTestObjectRustSpec_get_optional_array(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_optional_array(void* rustPtr, void* value);
  __FfiResult_ptr HybridTestObjectRustSpec_get_optional_enum(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_optional_enum(void* rustPtr, void* value);
  __FfiResult_ptr HybridTestObjectRustSpec_get_optional_old_enum(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_optional_old_enum(void* rustPtr, void* value);
  __FfiResult_ptr HybridTestObjectRustSpec_get_optional_callback(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_optional_callback(void* rustPtr, void* value);
  __FfiResult_ptr HybridTestObjectRustSpec_get_some_variant(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_set_some_variant(void* rustPtr, void* value);
  __FfiResult_ptr HybridTestObjectRustSpec_new_test_object(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_get_variant_hybrid(void* rustPtr, void* variant);
  __FfiResult_void HybridTestObjectRustSpec_simple_func(void* rustPtr);
  __FfiResult_f64 HybridTestObjectRustSpec_add_numbers(void* rustPtr, double a, double b);
  __FfiResult_cstr HybridTestObjectRustSpec_add_strings(void* rustPtr, const char* a, const char* b);
  __FfiResult_void HybridTestObjectRustSpec_multiple_arguments(void* rustPtr, double num, const char* str, bool boo);
  __FfiResult_void HybridTestObjectRustSpec_bounce_null(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_strings(void* rustPtr, void* array);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_numbers(void* rustPtr, void* array);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_structs(void* rustPtr, void* array);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_partial_struct(void* rustPtr, void* person);
  __FfiResult_cstr HybridTestObjectRustSpec_sum_up_all_passengers(void* rustPtr, void* cars);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_enums(void* rustPtr, void* array);
  __FfiResult_void HybridTestObjectRustSpec_complex_enum_callback(void* rustPtr, void* array, void* callback);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_hybrid_objects(void* rustPtr, void* array);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_functions(void* rustPtr, void* functions);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_maps(void* rustPtr, void* maps);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_promises(void* rustPtr, void* promises);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_array_buffers(void* rustPtr, void* arrayBuffers);
  __FfiResult_ptr HybridTestObjectRustSpec_create_map(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_map_roundtrip(void* rustPtr, void* map);
  __FfiResult_ptr HybridTestObjectRustSpec_get_map_keys(void* rustPtr, void* map);
  __FfiResult_ptr HybridTestObjectRustSpec_merge_maps(void* rustPtr, void* a, void* b);
  __FfiResult_ptr HybridTestObjectRustSpec_copy_any_map(void* rustPtr, void* map);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_map(void* rustPtr, void* map);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_simple_map(void* rustPtr, void* map);
  __FfiResult_ptr HybridTestObjectRustSpec_extract_map(void* rustPtr, void* mapWrapper);
  __FfiResult_f64 HybridTestObjectRustSpec_func_that_throws(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_func_that_throws_before_promise(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_throw_error(void* rustPtr, const char* error);
  __FfiResult_cstr HybridTestObjectRustSpec_try_optional_params(void* rustPtr, double num, bool boo, void* str);
  __FfiResult_cstr HybridTestObjectRustSpec_try_middle_param(void* rustPtr, double num, void* boo, const char* str);
  __FfiResult_ptr HybridTestObjectRustSpec_try_optional_enum(void* rustPtr, void* value);
  __FfiResult_bool HybridTestObjectRustSpec_try_trailing_optional(void* rustPtr, double num, const char* str, void* boo);
  __FfiResult_f64 HybridTestObjectRustSpec_add1_hour(void* rustPtr, double date);
  __FfiResult_f64 HybridTestObjectRustSpec_current_date(void* rustPtr);
  __FfiResult_i64 HybridTestObjectRustSpec_calculate_fibonacci_sync(void* rustPtr, double value);
  __FfiResult_i64 HybridTestObjectRustSpec_calculate_fibonacci_async(void* rustPtr, double value);
  __FfiResult_void HybridTestObjectRustSpec_wait(void* rustPtr, double seconds);
  __FfiResult_void HybridTestObjectRustSpec_promise_throws(void* rustPtr);
  __FfiResult_f64 HybridTestObjectRustSpec_promise_returns_instantly(void* rustPtr);
  __FfiResult_f64 HybridTestObjectRustSpec_promise_returns_instantly_async(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_promise_that_resolves_void_instantly(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_promise_that_resolves_to_undefined(void* rustPtr);
  __FfiResult_f64 HybridTestObjectRustSpec_await_and_get_promise(void* rustPtr, void* promise);
  __FfiResult_ptr HybridTestObjectRustSpec_await_and_get_complex_promise(void* rustPtr, void* promise);
  __FfiResult_void HybridTestObjectRustSpec_await_promise(void* rustPtr, void* promise);
  __FfiResult_void HybridTestObjectRustSpec_call_callback(void* rustPtr, void* callback);
  __FfiResult_void HybridTestObjectRustSpec_call_callback_that_returns_promise_void(void* rustPtr, void* callback);
  __FfiResult_void HybridTestObjectRustSpec_call_all(void* rustPtr, void* first, void* second, void* third);
  __FfiResult_void HybridTestObjectRustSpec_call_with_optional(void* rustPtr, void* value, void* callback);
  __FfiResult_f64 HybridTestObjectRustSpec_call_sum_up_n_times(void* rustPtr, void* callback, double n);
  __FfiResult_f64 HybridTestObjectRustSpec_callback_async_promise(void* rustPtr, void* callback);
  __FfiResult_ptr HybridTestObjectRustSpec_callback_async_promise_buffer(void* rustPtr, void* callback);
  __FfiResult_ptr HybridTestObjectRustSpec_get_complex_callback(void* rustPtr);
  __FfiResult_void HybridTestObjectRustSpec_two_optional_callbacks(void* rustPtr, double value, void* first, void* second);
  __FfiResult_void HybridTestObjectRustSpec_error_callback(void* rustPtr, void* onError);
  __FfiResult_ptr HybridTestObjectRustSpec_create_native_callback(void* rustPtr, void* wrappingJsCallback);
  __FfiResult_f64 HybridTestObjectRustSpec_get_value_from_js_callback_and_wait(void* rustPtr, void* getValue);
  __FfiResult_void HybridTestObjectRustSpec_get_value_from_js_callback(void* rustPtr, void* callback, void* andThenCall);
  __FfiResult_ptr HybridTestObjectRustSpec_get_car(void* rustPtr);
  __FfiResult_bool HybridTestObjectRustSpec_is_car_electric(void* rustPtr, void* car);
  __FfiResult_ptr HybridTestObjectRustSpec_get_driver(void* rustPtr, void* car);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_car(void* rustPtr, void* car);
  __FfiResult_void HybridTestObjectRustSpec_js_style_object_as_parameters(void* rustPtr, void* params);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_wrapped_js_style_struct(void* rustPtr, void* value);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_optional_wrapper(void* rustPtr, void* wrapper);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_optional_callback(void* rustPtr, void* value);
  __FfiResult_ptr HybridTestObjectRustSpec_create_array_buffer(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_create_array_buffer_from_native_buffer(void* rustPtr, bool copy);
  __FfiResult_ptr HybridTestObjectRustSpec_copy_buffer(void* rustPtr, void* buffer);
  __FfiResult_f64 HybridTestObjectRustSpec_get_buffer_last_item(void* rustPtr, void* buffer);
  __FfiResult_void HybridTestObjectRustSpec_set_all_values_to(void* rustPtr, void* buffer, double value);
  __FfiResult_ptr HybridTestObjectRustSpec_create_array_buffer_async(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_array_buffer(void* rustPtr, void* buffer);
  __FfiResult_ptr HybridTestObjectRustSpec_pass_variant(void* rustPtr, void* either);
  __FfiResult_ptr HybridTestObjectRustSpec_get_variant_enum(void* rustPtr, void* variant);
  __FfiResult_ptr HybridTestObjectRustSpec_get_variant_weird_numbers_enum(void* rustPtr, void* variant);
  __FfiResult_ptr HybridTestObjectRustSpec_get_variant_objects(void* rustPtr, void* variant);
  __FfiResult_ptr HybridTestObjectRustSpec_pass_named_variant(void* rustPtr, void* variant);
  __FfiResult_ptr HybridTestObjectRustSpec_pass_all_empty_object_variant(void* rustPtr, void* variant);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_complex_variant(void* rustPtr, void* variant);
  __FfiResult_ptr HybridTestObjectRustSpec_create_child(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_create_base(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_create_base_actual_child(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_child(void* rustPtr, void* child);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_base(void* rustPtr, void* base);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_child_base(void* rustPtr, void* child);
  __FfiResult_ptr HybridTestObjectRustSpec_cast_base(void* rustPtr, void* base);
  __FfiResult_f64 HybridTestObjectRustSpec_callback_sync(void* rustPtr, void* callback);
  __FfiResult_bool HybridTestObjectRustSpec_get_is_view_blue(void* rustPtr, void* view);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_external_hybrid(void* rustPtr, void* externalObject);
  __FfiResult_ptr HybridTestObjectRustSpec_create_internal_object(void* rustPtr);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_external_struct(void* rustPtr, void* externalStruct);
  __FfiResult_ptr HybridTestObjectRustSpec_bounce_external_variant(void* rustPtr, void* variant);
  __FfiResult_ptr HybridTestObjectRustSpec_create_external_variant_from_func(void* rustPtr, void* factory);
  size_t HybridTestObjectRustSpec_memory_size(void* rustPtr);
  void HybridTestObjectRustSpec_destroy(void* rustPtr);
  void __nitrogen_free_cstring(char* ptr);
}

namespace margelo::nitro::test {

  /**
   * C++ bridge class that forwards HybridObject calls to a Rust implementation via extern "C" FFI.
   */
  class HybridTestObjectRustSpecRust: public virtual HybridTestObjectRustSpec {
  public:
    explicit HybridTestObjectRustSpecRust(void* rustPtr):
      HybridObject(HybridTestObjectRustSpec::TAG),
      _rustPtr(rustPtr) { }

    ~HybridTestObjectRustSpecRust() override {
      HybridTestObjectRustSpec_destroy(_rustPtr);
    }

  public:
    // Properties
    inline std::shared_ptr<HybridTestObjectRustSpec> getThisObject() override { auto __ffi = HybridTestObjectRustSpec_get_this_object(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::optional<std::shared_ptr<HybridTestObjectRustSpec>> getOptionalHybrid() override { auto __ffi = HybridTestObjectRustSpec_get_optional_hybrid(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::optional<std::shared_ptr<HybridTestObjectRustSpec>> { struct __Opt { uint8_t has_value; void* value; }; auto __s = static_cast<__Opt*>(__ffi.value); std::optional<std::shared_ptr<HybridTestObjectRustSpec>> __r; if (__s->has_value) { __r = __s->value; } delete __s; return __r; }(); }
    inline void setOptionalHybrid(const std::optional<std::shared_ptr<HybridTestObjectRustSpec>>& optionalHybrid) override { auto __ffi = HybridTestObjectRustSpec_set_optional_hybrid(_rustPtr, [&]() -> void* { struct __Opt { uint8_t has_value; void* value; }; auto __opt = new __Opt(); if (optionalHybrid.has_value()) { const auto& __inner = optionalHybrid.value(); __opt->has_value = 1; __opt->value = static_cast<void*>(new std::shared_ptr<HybridTestObjectRustSpec>(__inner)); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline double getNumberValue() override { auto __ffi = HybridTestObjectRustSpec_get_number_value(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline void setNumberValue(double numberValue) override { auto __ffi = HybridTestObjectRustSpec_set_number_value(_rustPtr, numberValue); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline bool getBoolValue() override { auto __ffi = HybridTestObjectRustSpec_get_bool_value(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline void setBoolValue(bool boolValue) override { auto __ffi = HybridTestObjectRustSpec_set_bool_value(_rustPtr, boolValue); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::string getStringValue() override { auto __ffi = HybridTestObjectRustSpec_get_string_value(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return ([](const char* __p) -> std::string { std::string __s(__p); __nitrogen_free_cstring(const_cast<char*>(__p)); return __s; })(__ffi.value); }
    inline void setStringValue(const std::string& stringValue) override { auto __ffi = HybridTestObjectRustSpec_set_string_value(_rustPtr, stringValue.c_str()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline int64_t getInt64Value() override { auto __ffi = HybridTestObjectRustSpec_get_int64_value(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline void setInt64Value(int64_t int64Value) override { auto __ffi = HybridTestObjectRustSpec_set_int64_value(_rustPtr, int64Value); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline uint64_t getUint64Value() override { auto __ffi = HybridTestObjectRustSpec_get_uint64_value(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline void setUint64Value(uint64_t uint64Value) override { auto __ffi = HybridTestObjectRustSpec_set_uint64_value(_rustPtr, uint64Value); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline nitro::NullType getNullValue() override { auto __ffi = HybridTestObjectRustSpec_get_null_value(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline void setNullValue(nitro::NullType nullValue) override { auto __ffi = HybridTestObjectRustSpec_set_null_value(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::optional<std::string> getOptionalString() override { auto __ffi = HybridTestObjectRustSpec_get_optional_string(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::optional<std::string> { struct __Opt { uint8_t has_value; const char* value; }; auto __s = static_cast<__Opt*>(__ffi.value); std::optional<std::string> __r; if (__s->has_value) { __r = ([](const char* __p) -> std::string { std::string __s(__p); __nitrogen_free_cstring(const_cast<char*>(__p)); return __s; })(__s->value); } delete __s; return __r; }(); }
    inline void setOptionalString(const std::optional<std::string>& optionalString) override { auto __ffi = HybridTestObjectRustSpec_set_optional_string(_rustPtr, [&]() -> void* { struct __Opt { uint8_t has_value; const char* value; }; auto __opt = new __Opt(); if (optionalString.has_value()) { const auto& __inner = optionalString.value(); __opt->has_value = 1; __opt->value = __inner.c_str(); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::optional<std::string> getStringOrUndefined() override { auto __ffi = HybridTestObjectRustSpec_get_string_or_undefined(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::optional<std::string> { struct __Opt { uint8_t has_value; const char* value; }; auto __s = static_cast<__Opt*>(__ffi.value); std::optional<std::string> __r; if (__s->has_value) { __r = ([](const char* __p) -> std::string { std::string __s(__p); __nitrogen_free_cstring(const_cast<char*>(__p)); return __s; })(__s->value); } delete __s; return __r; }(); }
    inline void setStringOrUndefined(const std::optional<std::string>& stringOrUndefined) override { auto __ffi = HybridTestObjectRustSpec_set_string_or_undefined(_rustPtr, [&]() -> void* { struct __Opt { uint8_t has_value; const char* value; }; auto __opt = new __Opt(); if (stringOrUndefined.has_value()) { const auto& __inner = stringOrUndefined.value(); __opt->has_value = 1; __opt->value = __inner.c_str(); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::variant<nitro::NullType, std::string> getStringOrNull() override { auto __ffi = HybridTestObjectRustSpec_get_string_or_null(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<nitro::NullType, std::string>*>(__ffi.value)); }
    inline void setStringOrNull(const std::variant<nitro::NullType, std::string>& stringOrNull) override { auto __ffi = HybridTestObjectRustSpec_set_string_or_null(_rustPtr, static_cast<void*>(new std::variant<nitro::NullType, std::string>(std::move(stringOrNull)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::optional<std::vector<std::string>> getOptionalArray() override { auto __ffi = HybridTestObjectRustSpec_get_optional_array(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::optional<std::vector<std::string>> { struct __Opt { uint8_t has_value; void* value; }; auto __s = static_cast<__Opt*>(__ffi.value); std::optional<std::vector<std::string>> __r; if (__s->has_value) { __r = std::move(*static_cast<std::vector<std::string>*>(__s->value)); } delete __s; return __r; }(); }
    inline void setOptionalArray(const std::optional<std::vector<std::string>>& optionalArray) override { auto __ffi = HybridTestObjectRustSpec_set_optional_array(_rustPtr, [&]() -> void* { struct __Opt { uint8_t has_value; void* value; }; auto __opt = new __Opt(); if (optionalArray.has_value()) { const auto& __inner = optionalArray.value(); __opt->has_value = 1; __opt->value = static_cast<void*>(new std::vector<std::string>(std::move(__inner))); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::optional<Powertrain> getOptionalEnum() override { auto __ffi = HybridTestObjectRustSpec_get_optional_enum(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::optional<Powertrain> { struct __Opt { uint8_t has_value; int32_t value; }; auto __s = static_cast<__Opt*>(__ffi.value); std::optional<Powertrain> __r; if (__s->has_value) { __r = static_cast<Powertrain>(__s->value); } delete __s; return __r; }(); }
    inline void setOptionalEnum(std::optional<Powertrain> optionalEnum) override { auto __ffi = HybridTestObjectRustSpec_set_optional_enum(_rustPtr, [&]() -> void* { struct __Opt { uint8_t has_value; int32_t value; }; auto __opt = new __Opt(); if (optionalEnum.has_value()) { const auto& __inner = optionalEnum.value(); __opt->has_value = 1; __opt->value = static_cast<int32_t>(__inner); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::optional<OldEnum> getOptionalOldEnum() override { auto __ffi = HybridTestObjectRustSpec_get_optional_old_enum(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::optional<OldEnum> { struct __Opt { uint8_t has_value; int32_t value; }; auto __s = static_cast<__Opt*>(__ffi.value); std::optional<OldEnum> __r; if (__s->has_value) { __r = static_cast<OldEnum>(__s->value); } delete __s; return __r; }(); }
    inline void setOptionalOldEnum(std::optional<OldEnum> optionalOldEnum) override { auto __ffi = HybridTestObjectRustSpec_set_optional_old_enum(_rustPtr, [&]() -> void* { struct __Opt { uint8_t has_value; int32_t value; }; auto __opt = new __Opt(); if (optionalOldEnum.has_value()) { const auto& __inner = optionalOldEnum.value(); __opt->has_value = 1; __opt->value = static_cast<int32_t>(__inner); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::optional<std::function<void(double /* value */)>> getOptionalCallback() override { auto __ffi = HybridTestObjectRustSpec_get_optional_callback(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::optional<std::function<void(double /* value */)>> { struct __Opt { uint8_t has_value; void* value; }; auto __s = static_cast<__Opt*>(__ffi.value); std::optional<std::function<void(double /* value */)>> __r; if (__s->has_value) { __r = std::move(*static_cast<std::function<void(double /* value */)>*>(__s->value)); } delete __s; return __r; }(); }
    inline void setOptionalCallback(const std::optional<std::function<void(double /* value */)>>& optionalCallback) override { auto __ffi = HybridTestObjectRustSpec_set_optional_callback(_rustPtr, [&]() -> void* { struct __Opt { uint8_t has_value; void* value; }; auto __opt = new __Opt(); if (optionalCallback.has_value()) { const auto& __inner = optionalCallback.value(); __opt->has_value = 1; __opt->value = [&]() -> void* { struct __W { void(*fn_ptr)(void*, double); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, double __a0) { (*static_cast<std::function<void(double /* value */)>*>(__ud))(__a0); }, static_cast<void*>(new std::function<void(double /* value */)>(std::move(__inner))), [](void* __ud) { delete static_cast<std::function<void(double /* value */)>*>(__ud); } }); }(); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::variant<std::string, double> getSomeVariant() override { auto __ffi = HybridTestObjectRustSpec_get_some_variant(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<std::string, double>*>(__ffi.value)); }
    inline void setSomeVariant(const std::variant<std::string, double>& someVariant) override { auto __ffi = HybridTestObjectRustSpec_set_some_variant(_rustPtr, static_cast<void*>(new std::variant<std::string, double>(std::move(someVariant)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }

  public:
    // Methods
    inline std::shared_ptr<HybridTestObjectRustSpec> newTestObject() override { auto __ffi = HybridTestObjectRustSpec_new_test_object(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::variant<std::shared_ptr<HybridTestObjectRustSpec>, Person> getVariantHybrid(const std::variant<std::shared_ptr<HybridTestObjectRustSpec>, Person>& variant) override { auto __ffi = HybridTestObjectRustSpec_get_variant_hybrid(_rustPtr, static_cast<void*>(new std::variant<std::shared_ptr<HybridTestObjectRustSpec>, Person>(std::move(variant)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<std::shared_ptr<HybridTestObjectRustSpec>, Person>*>(__ffi.value)); }
    inline void simpleFunc() override { auto __ffi = HybridTestObjectRustSpec_simple_func(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline double addNumbers(double a, double b) override { auto __ffi = HybridTestObjectRustSpec_add_numbers(_rustPtr, a, b); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::string addStrings(const std::string& a, const std::string& b) override { auto __ffi = HybridTestObjectRustSpec_add_strings(_rustPtr, a.c_str(), b.c_str()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return ([](const char* __p) -> std::string { std::string __s(__p); __nitrogen_free_cstring(const_cast<char*>(__p)); return __s; })(__ffi.value); }
    inline void multipleArguments(double num, const std::string& str, bool boo) override { auto __ffi = HybridTestObjectRustSpec_multiple_arguments(_rustPtr, num, str.c_str(), boo); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline nitro::NullType bounceNull() override { auto __ffi = HybridTestObjectRustSpec_bounce_null(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::vector<std::string> bounceStrings(const std::vector<std::string>& array) override { auto __ffi = HybridTestObjectRustSpec_bounce_strings(_rustPtr, static_cast<void*>(new std::vector<std::string>(std::move(array)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::vector<std::string>*>(__ffi.value)); }
    inline std::vector<double> bounceNumbers(const std::vector<double>& array) override { auto __ffi = HybridTestObjectRustSpec_bounce_numbers(_rustPtr, static_cast<void*>(new std::vector<double>(std::move(array)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::vector<double>*>(__ffi.value)); }
    inline std::vector<Person> bounceStructs(const std::vector<Person>& array) override { auto __ffi = HybridTestObjectRustSpec_bounce_structs(_rustPtr, static_cast<void*>(new std::vector<Person>(std::move(array)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::vector<Person>*>(__ffi.value)); }
    inline PartialPerson bouncePartialStruct(const PartialPerson& person) override { auto __ffi = HybridTestObjectRustSpec_bounce_partial_struct(_rustPtr, static_cast<void*>(new PartialPerson(person))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return *static_cast<PartialPerson*>(__ffi.value); }
    inline std::string sumUpAllPassengers(const std::vector<Car>& cars) override { auto __ffi = HybridTestObjectRustSpec_sum_up_all_passengers(_rustPtr, static_cast<void*>(new std::vector<Car>(std::move(cars)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return ([](const char* __p) -> std::string { std::string __s(__p); __nitrogen_free_cstring(const_cast<char*>(__p)); return __s; })(__ffi.value); }
    inline std::vector<Powertrain> bounceEnums(const std::vector<Powertrain>& array) override { auto __ffi = HybridTestObjectRustSpec_bounce_enums(_rustPtr, static_cast<void*>(new std::vector<Powertrain>(std::move(array)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::vector<Powertrain>*>(__ffi.value)); }
    inline void complexEnumCallback(const std::vector<Powertrain>& array, const std::function<void(const std::vector<Powertrain>& /* array */)>& callback) override { auto __ffi = HybridTestObjectRustSpec_complex_enum_callback(_rustPtr, static_cast<void*>(new std::vector<Powertrain>(std::move(array))), [&]() -> void* { struct __W { void(*fn_ptr)(void*, void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, void* __a0) { (*static_cast<std::function<void(const std::vector<Powertrain>& /* array */)>*>(__ud))(std::move(*static_cast<std::vector<Powertrain>*>(__a0))); }, static_cast<void*>(new std::function<void(const std::vector<Powertrain>& /* array */)>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<void(const std::vector<Powertrain>& /* array */)>*>(__ud); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::vector<std::shared_ptr<HybridChildSpec>> bounceHybridObjects(const std::vector<std::shared_ptr<HybridChildSpec>>& array) override { auto __ffi = HybridTestObjectRustSpec_bounce_hybrid_objects(_rustPtr, static_cast<void*>(new std::vector<std::shared_ptr<HybridChildSpec>>(std::move(array)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::vector<std::shared_ptr<HybridChildSpec>>*>(__ffi.value)); }
    inline std::vector<std::function<void()>> bounceFunctions(const std::vector<std::function<void()>>& functions) override { auto __ffi = HybridTestObjectRustSpec_bounce_functions(_rustPtr, static_cast<void*>(new std::vector<std::function<void()>>(std::move(functions)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::vector<std::function<void()>>*>(__ffi.value)); }
    inline std::vector<std::shared_ptr<AnyMap>> bounceMaps(const std::vector<std::shared_ptr<AnyMap>>& maps) override { auto __ffi = HybridTestObjectRustSpec_bounce_maps(_rustPtr, static_cast<void*>(new std::vector<std::shared_ptr<AnyMap>>(std::move(maps)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::vector<std::shared_ptr<AnyMap>>*>(__ffi.value)); }
    inline std::vector<std::shared_ptr<Promise<double>>> bouncePromises(const std::vector<std::shared_ptr<Promise<double>>>& promises) override { auto __ffi = HybridTestObjectRustSpec_bounce_promises(_rustPtr, static_cast<void*>(new std::vector<std::shared_ptr<Promise<double>>>(std::move(promises)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::vector<std::shared_ptr<Promise<double>>>*>(__ffi.value)); }
    inline std::vector<std::shared_ptr<ArrayBuffer>> bounceArrayBuffers(const std::vector<std::shared_ptr<ArrayBuffer>>& arrayBuffers) override { auto __ffi = HybridTestObjectRustSpec_bounce_array_buffers(_rustPtr, static_cast<void*>(new std::vector<std::shared_ptr<ArrayBuffer>>(std::move(arrayBuffers)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::vector<std::shared_ptr<ArrayBuffer>>*>(__ffi.value)); }
    inline std::shared_ptr<AnyMap> createMap() override { auto __ffi = HybridTestObjectRustSpec_create_map(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::shared_ptr<AnyMap>*>(__ffi.value)); }
    inline std::shared_ptr<AnyMap> mapRoundtrip(const std::shared_ptr<AnyMap>& map) override { auto __ffi = HybridTestObjectRustSpec_map_roundtrip(_rustPtr, static_cast<void*>(new std::shared_ptr<AnyMap>(std::move(map)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::shared_ptr<AnyMap>*>(__ffi.value)); }
    inline std::vector<std::string> getMapKeys(const std::shared_ptr<AnyMap>& map) override { auto __ffi = HybridTestObjectRustSpec_get_map_keys(_rustPtr, static_cast<void*>(new std::shared_ptr<AnyMap>(std::move(map)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::vector<std::string>*>(__ffi.value)); }
    inline std::shared_ptr<AnyMap> mergeMaps(const std::shared_ptr<AnyMap>& a, const std::shared_ptr<AnyMap>& b) override { auto __ffi = HybridTestObjectRustSpec_merge_maps(_rustPtr, static_cast<void*>(new std::shared_ptr<AnyMap>(std::move(a))), static_cast<void*>(new std::shared_ptr<AnyMap>(std::move(b)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::shared_ptr<AnyMap>*>(__ffi.value)); }
    inline std::shared_ptr<AnyMap> copyAnyMap(const std::shared_ptr<AnyMap>& map) override { auto __ffi = HybridTestObjectRustSpec_copy_any_map(_rustPtr, static_cast<void*>(new std::shared_ptr<AnyMap>(std::move(map)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::shared_ptr<AnyMap>*>(__ffi.value)); }
    inline std::unordered_map<std::string, std::variant<bool, double>> bounceMap(const std::unordered_map<std::string, std::variant<bool, double>>& map) override { auto __ffi = HybridTestObjectRustSpec_bounce_map(_rustPtr, static_cast<void*>(new std::unordered_map<std::string, std::variant<bool, double>>(std::move(map)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::unordered_map<std::string, std::variant<bool, double>>*>(__ffi.value)); }
    inline std::unordered_map<std::string, double> bounceSimpleMap(const std::unordered_map<std::string, double>& map) override { auto __ffi = HybridTestObjectRustSpec_bounce_simple_map(_rustPtr, static_cast<void*>(new std::unordered_map<std::string, double>(std::move(map)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::unordered_map<std::string, double>*>(__ffi.value)); }
    inline std::unordered_map<std::string, std::string> extractMap(const MapWrapper& mapWrapper) override { auto __ffi = HybridTestObjectRustSpec_extract_map(_rustPtr, static_cast<void*>(new MapWrapper(mapWrapper))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::unordered_map<std::string, std::string>*>(__ffi.value)); }
    inline double funcThatThrows() override { auto __ffi = HybridTestObjectRustSpec_func_that_throws(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::shared_ptr<Promise<void>> funcThatThrowsBeforePromise() override {
          return Promise<void>::async([=]() {
            auto __ffi = HybridTestObjectRustSpec_func_that_throws_before_promise(_rustPtr);
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
          });
        }
    inline void throwError(const std::exception_ptr& error) override { auto __ffi = HybridTestObjectRustSpec_throw_error(_rustPtr, [&]() -> const char* { try { std::rethrow_exception(error); } catch (const std::exception& e) { return e.what(); } catch (...) { return "unknown error"; } }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::string tryOptionalParams(double num, bool boo, const std::optional<std::string>& str) override { auto __ffi = HybridTestObjectRustSpec_try_optional_params(_rustPtr, num, boo, [&]() -> void* { struct __Opt { uint8_t has_value; const char* value; }; auto __opt = new __Opt(); if (str.has_value()) { const auto& __inner = str.value(); __opt->has_value = 1; __opt->value = __inner.c_str(); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return ([](const char* __p) -> std::string { std::string __s(__p); __nitrogen_free_cstring(const_cast<char*>(__p)); return __s; })(__ffi.value); }
    inline std::string tryMiddleParam(double num, std::optional<bool> boo, const std::string& str) override { auto __ffi = HybridTestObjectRustSpec_try_middle_param(_rustPtr, num, [&]() -> void* { struct __Opt { uint8_t has_value; bool value; }; auto __opt = new __Opt(); if (boo.has_value()) { __opt->has_value = 1; __opt->value = static_cast<bool>(boo.value()); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }(), str.c_str()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return ([](const char* __p) -> std::string { std::string __s(__p); __nitrogen_free_cstring(const_cast<char*>(__p)); return __s; })(__ffi.value); }
    inline std::optional<Powertrain> tryOptionalEnum(std::optional<Powertrain> value) override { auto __ffi = HybridTestObjectRustSpec_try_optional_enum(_rustPtr, [&]() -> void* { struct __Opt { uint8_t has_value; int32_t value; }; auto __opt = new __Opt(); if (value.has_value()) { const auto& __inner = value.value(); __opt->has_value = 1; __opt->value = static_cast<int32_t>(__inner); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::optional<Powertrain> { struct __Opt { uint8_t has_value; int32_t value; }; auto __s = static_cast<__Opt*>(__ffi.value); std::optional<Powertrain> __r; if (__s->has_value) { __r = static_cast<Powertrain>(__s->value); } delete __s; return __r; }(); }
    inline bool tryTrailingOptional(double num, const std::string& str, std::optional<bool> boo) override { auto __ffi = HybridTestObjectRustSpec_try_trailing_optional(_rustPtr, num, str.c_str(), [&]() -> void* { struct __Opt { uint8_t has_value; bool value; }; auto __opt = new __Opt(); if (boo.has_value()) { __opt->has_value = 1; __opt->value = static_cast<bool>(boo.value()); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::chrono::system_clock::time_point add1Hour(std::chrono::system_clock::time_point date) override { auto __ffi = HybridTestObjectRustSpec_add1_hour(_rustPtr, std::chrono::duration<double, std::milli>(date.time_since_epoch()).count()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::chrono::system_clock::time_point(std::chrono::duration_cast<std::chrono::system_clock::duration>(std::chrono::duration<double, std::milli>(__ffi.value))); }
    inline std::chrono::system_clock::time_point currentDate() override { auto __ffi = HybridTestObjectRustSpec_current_date(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::chrono::system_clock::time_point(std::chrono::duration_cast<std::chrono::system_clock::duration>(std::chrono::duration<double, std::milli>(__ffi.value))); }
    inline int64_t calculateFibonacciSync(double value) override { auto __ffi = HybridTestObjectRustSpec_calculate_fibonacci_sync(_rustPtr, value); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::shared_ptr<Promise<int64_t>> calculateFibonacciAsync(double value) override {
          return Promise<int64_t>::async([=]() -> int64_t {
            auto __ffi = HybridTestObjectRustSpec_calculate_fibonacci_async(_rustPtr, value);
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return __ffi.value;
          });
        }
    inline std::shared_ptr<Promise<void>> wait(double seconds) override {
          return Promise<void>::async([=]() {
            auto __ffi = HybridTestObjectRustSpec_wait(_rustPtr, seconds);
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
          });
        }
    inline std::shared_ptr<Promise<void>> promiseThrows() override {
          return Promise<void>::async([=]() {
            auto __ffi = HybridTestObjectRustSpec_promise_throws(_rustPtr);
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
          });
        }
    inline std::shared_ptr<Promise<double>> promiseReturnsInstantly() override {
          return Promise<double>::async([=]() -> double {
            auto __ffi = HybridTestObjectRustSpec_promise_returns_instantly(_rustPtr);
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return __ffi.value;
          });
        }
    inline std::shared_ptr<Promise<double>> promiseReturnsInstantlyAsync() override {
          return Promise<double>::async([=]() -> double {
            auto __ffi = HybridTestObjectRustSpec_promise_returns_instantly_async(_rustPtr);
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return __ffi.value;
          });
        }
    inline std::shared_ptr<Promise<void>> promiseThatResolvesVoidInstantly() override {
          return Promise<void>::async([=]() {
            auto __ffi = HybridTestObjectRustSpec_promise_that_resolves_void_instantly(_rustPtr);
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
          });
        }
    inline std::shared_ptr<Promise<std::optional<double>>> promiseThatResolvesToUndefined() override {
          return Promise<std::optional<double>>::async([=]() -> std::optional<double> {
            auto __ffi = HybridTestObjectRustSpec_promise_that_resolves_to_undefined(_rustPtr);
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return [&]() -> std::optional<double> { struct __Opt { uint8_t has_value; double value; }; auto __s = static_cast<__Opt*>(__ffi.value); std::optional<double> __r; if (__s->has_value) { __r = static_cast<double>(__s->value); } delete __s; return __r; }();
          });
        }
    inline std::shared_ptr<Promise<double>> awaitAndGetPromise(const std::shared_ptr<Promise<double>>& promise) override {
          return Promise<double>::async([=]() -> double {
            auto __ffi = HybridTestObjectRustSpec_await_and_get_promise(_rustPtr, static_cast<void*>(new std::shared_ptr<Promise<double>>(std::move(promise))));
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return __ffi.value;
          });
        }
    inline std::shared_ptr<Promise<Car>> awaitAndGetComplexPromise(const std::shared_ptr<Promise<Car>>& promise) override {
          return Promise<Car>::async([=]() -> Car {
            auto __ffi = HybridTestObjectRustSpec_await_and_get_complex_promise(_rustPtr, static_cast<void*>(new std::shared_ptr<Promise<Car>>(std::move(promise))));
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return *static_cast<Car*>(__ffi.value);
          });
        }
    inline std::shared_ptr<Promise<void>> awaitPromise(const std::shared_ptr<Promise<void>>& promise) override {
          return Promise<void>::async([=]() {
            auto __ffi = HybridTestObjectRustSpec_await_promise(_rustPtr, static_cast<void*>(new std::shared_ptr<Promise<void>>(std::move(promise))));
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
          });
        }
    inline void callCallback(const std::function<void()>& callback) override { auto __ffi = HybridTestObjectRustSpec_call_callback(_rustPtr, [&]() -> void* { struct __W { void(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) { (*static_cast<std::function<void()>*>(__ud))(); }, static_cast<void*>(new std::function<void()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<void()>*>(__ud); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::shared_ptr<Promise<void>> callCallbackThatReturnsPromiseVoid(const std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>()>& callback) override {
          return Promise<void>::async([=]() {
            auto __ffi = HybridTestObjectRustSpec_call_callback_that_returns_promise_void(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>()>*>(__ud); } }); }());
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
          });
        }
    inline void callAll(const std::function<void()>& first, const std::function<void()>& second, const std::function<void()>& third) override { auto __ffi = HybridTestObjectRustSpec_call_all(_rustPtr, [&]() -> void* { struct __W { void(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) { (*static_cast<std::function<void()>*>(__ud))(); }, static_cast<void*>(new std::function<void()>(std::move(first))), [](void* __ud) { delete static_cast<std::function<void()>*>(__ud); } }); }(), [&]() -> void* { struct __W { void(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) { (*static_cast<std::function<void()>*>(__ud))(); }, static_cast<void*>(new std::function<void()>(std::move(second))), [](void* __ud) { delete static_cast<std::function<void()>*>(__ud); } }); }(), [&]() -> void* { struct __W { void(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) { (*static_cast<std::function<void()>*>(__ud))(); }, static_cast<void*>(new std::function<void()>(std::move(third))), [](void* __ud) { delete static_cast<std::function<void()>*>(__ud); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline void callWithOptional(std::optional<double> value, const std::function<void(std::optional<double> /* maybe */)>& callback) override { auto __ffi = HybridTestObjectRustSpec_call_with_optional(_rustPtr, [&]() -> void* { struct __Opt { uint8_t has_value; double value; }; auto __opt = new __Opt(); if (value.has_value()) { __opt->has_value = 1; __opt->value = static_cast<double>(value.value()); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }(), [&]() -> void* { struct __W { void(*fn_ptr)(void*, void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, void* __a0) { (*static_cast<std::function<void(std::optional<double> /* maybe */)>*>(__ud))([&]() -> std::optional<double> { struct __Opt { uint8_t has_value; double value; }; auto __s = static_cast<__Opt*>(__a0); std::optional<double> __r; if (__s->has_value) { __r = static_cast<double>(__s->value); } delete __s; return __r; }()); }, static_cast<void*>(new std::function<void(std::optional<double> /* maybe */)>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<void(std::optional<double> /* maybe */)>*>(__ud); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::shared_ptr<Promise<double>> callSumUpNTimes(const std::function<std::shared_ptr<Promise<double>>()>& callback, double n) override {
          return Promise<double>::async([=]() -> double {
            auto __ffi = HybridTestObjectRustSpec_call_sum_up_n_times(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<double>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<double>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<double>>()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<double>>()>*>(__ud); } }); }(), n);
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return __ffi.value;
          });
        }
    inline std::shared_ptr<Promise<double>> callbackAsyncPromise(const std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>()>& callback) override {
          return Promise<double>::async([=]() -> double {
            auto __ffi = HybridTestObjectRustSpec_callback_async_promise(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>()>*>(__ud); } }); }());
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return __ffi.value;
          });
        }
    inline std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>> callbackAsyncPromiseBuffer(const std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>()>& callback) override {
          return Promise<std::shared_ptr<ArrayBuffer>>::async([=]() -> std::shared_ptr<ArrayBuffer> {
            auto __ffi = HybridTestObjectRustSpec_callback_async_promise_buffer(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>()>*>(__ud); } }); }());
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__ffi.value); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }();
          });
        }
    inline std::function<void(double /* value */)> getComplexCallback() override { auto __ffi = HybridTestObjectRustSpec_get_complex_callback(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::function<void(double /* value */)>*>(__ffi.value)); }
    inline void twoOptionalCallbacks(double value, const std::optional<std::function<void(double /* value */)>>& first, const std::optional<std::function<void(const std::string& /* value */)>>& second) override { auto __ffi = HybridTestObjectRustSpec_two_optional_callbacks(_rustPtr, value, [&]() -> void* { struct __Opt { uint8_t has_value; void* value; }; auto __opt = new __Opt(); if (first.has_value()) { const auto& __inner = first.value(); __opt->has_value = 1; __opt->value = [&]() -> void* { struct __W { void(*fn_ptr)(void*, double); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, double __a0) { (*static_cast<std::function<void(double /* value */)>*>(__ud))(__a0); }, static_cast<void*>(new std::function<void(double /* value */)>(std::move(__inner))), [](void* __ud) { delete static_cast<std::function<void(double /* value */)>*>(__ud); } }); }(); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }(), [&]() -> void* { struct __Opt { uint8_t has_value; void* value; }; auto __opt = new __Opt(); if (second.has_value()) { const auto& __inner = second.value(); __opt->has_value = 1; __opt->value = [&]() -> void* { struct __W { void(*fn_ptr)(void*, const char*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, const char* __a0) { (*static_cast<std::function<void(const std::string& /* value */)>*>(__ud))(([](const char* __p) -> std::string { std::string __s(__p); __nitrogen_free_cstring(const_cast<char*>(__p)); return __s; })(__a0)); }, static_cast<void*>(new std::function<void(const std::string& /* value */)>(std::move(__inner))), [](void* __ud) { delete static_cast<std::function<void(const std::string& /* value */)>*>(__ud); } }); }(); } else { __opt->has_value = 0; __opt->value = {}; } return static_cast<void*>(__opt); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline void errorCallback(const std::function<void(const std::exception_ptr& /* error */)>& onError) override { auto __ffi = HybridTestObjectRustSpec_error_callback(_rustPtr, [&]() -> void* { struct __W { void(*fn_ptr)(void*, const char*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, const char* __a0) { (*static_cast<std::function<void(const std::exception_ptr& /* error */)>*>(__ud))(([](const char* __p) -> std::exception_ptr { auto __e = std::make_exception_ptr(std::runtime_error(__p)); __nitrogen_free_cstring(const_cast<char*>(__p)); return __e; })(__a0)); }, static_cast<void*>(new std::function<void(const std::exception_ptr& /* error */)>(std::move(onError))), [](void* __ud) { delete static_cast<std::function<void(const std::exception_ptr& /* error */)>*>(__ud); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::function<void(double /* num */)> createNativeCallback(const std::function<void(double /* num */)>& wrappingJsCallback) override { auto __ffi = HybridTestObjectRustSpec_create_native_callback(_rustPtr, [&]() -> void* { struct __W { void(*fn_ptr)(void*, double); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, double __a0) { (*static_cast<std::function<void(double /* num */)>*>(__ud))(__a0); }, static_cast<void*>(new std::function<void(double /* num */)>(std::move(wrappingJsCallback))), [](void* __ud) { delete static_cast<std::function<void(double /* num */)>*>(__ud); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::function<void(double /* num */)>*>(__ffi.value)); }
    inline std::shared_ptr<Promise<double>> getValueFromJSCallbackAndWait(const std::function<std::shared_ptr<Promise<double>>()>& getValue) override {
          return Promise<double>::async([=]() -> double {
            auto __ffi = HybridTestObjectRustSpec_get_value_from_js_callback_and_wait(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<double>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<double>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<double>>()>(std::move(getValue))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<double>>()>*>(__ud); } }); }());
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return __ffi.value;
          });
        }
    inline std::shared_ptr<Promise<void>> getValueFromJsCallback(const std::function<std::shared_ptr<Promise<std::string>>()>& callback, const std::function<void(const std::string& /* valueFromJs */)>& andThenCall) override {
          return Promise<void>::async([=]() {
            auto __ffi = HybridTestObjectRustSpec_get_value_from_js_callback(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<std::string>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<std::string>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<std::string>>()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<std::string>>()>*>(__ud); } }); }(), [&]() -> void* { struct __W { void(*fn_ptr)(void*, const char*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, const char* __a0) { (*static_cast<std::function<void(const std::string& /* valueFromJs */)>*>(__ud))(([](const char* __p) -> std::string { std::string __s(__p); __nitrogen_free_cstring(const_cast<char*>(__p)); return __s; })(__a0)); }, static_cast<void*>(new std::function<void(const std::string& /* valueFromJs */)>(std::move(andThenCall))), [](void* __ud) { delete static_cast<std::function<void(const std::string& /* valueFromJs */)>*>(__ud); } }); }());
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
          });
        }
    inline Car getCar() override { auto __ffi = HybridTestObjectRustSpec_get_car(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return *static_cast<Car*>(__ffi.value); }
    inline bool isCarElectric(const Car& car) override { auto __ffi = HybridTestObjectRustSpec_is_car_electric(_rustPtr, static_cast<void*>(new Car(car))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::optional<Person> getDriver(const Car& car) override { auto __ffi = HybridTestObjectRustSpec_get_driver(_rustPtr, static_cast<void*>(new Car(car))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::optional<Person> { struct __Opt { uint8_t has_value; void* value; }; auto __s = static_cast<__Opt*>(__ffi.value); std::optional<Person> __r; if (__s->has_value) { __r = *static_cast<Person*>(__s->value); } delete __s; return __r; }(); }
    inline Car bounceCar(const Car& car) override { auto __ffi = HybridTestObjectRustSpec_bounce_car(_rustPtr, static_cast<void*>(new Car(car))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return *static_cast<Car*>(__ffi.value); }
    inline void jsStyleObjectAsParameters(const JsStyleStruct& params) override { auto __ffi = HybridTestObjectRustSpec_js_style_object_as_parameters(_rustPtr, static_cast<void*>(new JsStyleStruct(params))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline WrappedJsStruct bounceWrappedJsStyleStruct(const WrappedJsStruct& value) override { auto __ffi = HybridTestObjectRustSpec_bounce_wrapped_js_style_struct(_rustPtr, static_cast<void*>(new WrappedJsStruct(value))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return *static_cast<WrappedJsStruct*>(__ffi.value); }
    inline OptionalWrapper bounceOptionalWrapper(const OptionalWrapper& wrapper) override { auto __ffi = HybridTestObjectRustSpec_bounce_optional_wrapper(_rustPtr, static_cast<void*>(new OptionalWrapper(wrapper))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return *static_cast<OptionalWrapper*>(__ffi.value); }
    inline OptionalCallback bounceOptionalCallback(const OptionalCallback& value) override { auto __ffi = HybridTestObjectRustSpec_bounce_optional_callback(_rustPtr, static_cast<void*>(new OptionalCallback(value))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return *static_cast<OptionalCallback*>(__ffi.value); }
    inline std::shared_ptr<ArrayBuffer> createArrayBuffer() override { auto __ffi = HybridTestObjectRustSpec_create_array_buffer(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__ffi.value); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }(); }
    inline std::shared_ptr<ArrayBuffer> createArrayBufferFromNativeBuffer(bool copy) override { auto __ffi = HybridTestObjectRustSpec_create_array_buffer_from_native_buffer(_rustPtr, copy); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__ffi.value); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }(); }
    inline std::shared_ptr<ArrayBuffer> copyBuffer(const std::shared_ptr<ArrayBuffer>& buffer) override { auto __ffi = HybridTestObjectRustSpec_copy_buffer(_rustPtr, [&]() -> void* { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __sp = new std::shared_ptr<ArrayBuffer>(std::move(buffer)); return static_cast<void*>(new __NB { (*__sp)->data(), (*__sp)->size(), static_cast<void*>(__sp), [](void* __h) { delete static_cast<std::shared_ptr<ArrayBuffer>*>(__h); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__ffi.value); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }(); }
    inline double getBufferLastItem(const std::shared_ptr<ArrayBuffer>& buffer) override { auto __ffi = HybridTestObjectRustSpec_get_buffer_last_item(_rustPtr, [&]() -> void* { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __sp = new std::shared_ptr<ArrayBuffer>(std::move(buffer)); return static_cast<void*>(new __NB { (*__sp)->data(), (*__sp)->size(), static_cast<void*>(__sp), [](void* __h) { delete static_cast<std::shared_ptr<ArrayBuffer>*>(__h); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline void setAllValuesTo(const std::shared_ptr<ArrayBuffer>& buffer, double value) override { auto __ffi = HybridTestObjectRustSpec_set_all_values_to(_rustPtr, [&]() -> void* { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __sp = new std::shared_ptr<ArrayBuffer>(std::move(buffer)); return static_cast<void*>(new __NB { (*__sp)->data(), (*__sp)->size(), static_cast<void*>(__sp), [](void* __h) { delete static_cast<std::shared_ptr<ArrayBuffer>*>(__h); } }); }(), value); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } }
    inline std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>> createArrayBufferAsync() override {
          return Promise<std::shared_ptr<ArrayBuffer>>::async([=]() -> std::shared_ptr<ArrayBuffer> {
            auto __ffi = HybridTestObjectRustSpec_create_array_buffer_async(_rustPtr);
            if (!__ffi.is_ok) { __throwRustError(__ffi.error); }
            return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__ffi.value); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }();
          });
        }
    inline std::shared_ptr<ArrayBuffer> bounceArrayBuffer(const std::shared_ptr<ArrayBuffer>& buffer) override { auto __ffi = HybridTestObjectRustSpec_bounce_array_buffer(_rustPtr, [&]() -> void* { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __sp = new std::shared_ptr<ArrayBuffer>(std::move(buffer)); return static_cast<void*>(new __NB { (*__sp)->data(), (*__sp)->size(), static_cast<void*>(__sp), [](void* __h) { delete static_cast<std::shared_ptr<ArrayBuffer>*>(__h); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__ffi.value); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }(); }
    inline std::variant<std::string, double> passVariant(const std::variant<bool, std::vector<double>, std::vector<std::string>, std::string, double>& either) override { auto __ffi = HybridTestObjectRustSpec_pass_variant(_rustPtr, static_cast<void*>(new std::variant<bool, std::vector<double>, std::vector<std::string>, std::string, double>(std::move(either)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<std::string, double>*>(__ffi.value)); }
    inline std::variant<bool, OldEnum> getVariantEnum(const std::variant<bool, OldEnum>& variant) override { auto __ffi = HybridTestObjectRustSpec_get_variant_enum(_rustPtr, static_cast<void*>(new std::variant<bool, OldEnum>(std::move(variant)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<bool, OldEnum>*>(__ffi.value)); }
    inline std::variant<bool, WeirdNumbersEnum> getVariantWeirdNumbersEnum(const std::variant<bool, WeirdNumbersEnum>& variant) override { auto __ffi = HybridTestObjectRustSpec_get_variant_weird_numbers_enum(_rustPtr, static_cast<void*>(new std::variant<bool, WeirdNumbersEnum>(std::move(variant)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<bool, WeirdNumbersEnum>*>(__ffi.value)); }
    inline std::variant<Car, Person> getVariantObjects(const std::variant<Car, Person>& variant) override { auto __ffi = HybridTestObjectRustSpec_get_variant_objects(_rustPtr, static_cast<void*>(new std::variant<Car, Person>(std::move(variant)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<Car, Person>*>(__ffi.value)); }
    inline std::variant<std::string, Car> passNamedVariant(const std::variant<std::string, Car>& variant) override { auto __ffi = HybridTestObjectRustSpec_pass_named_variant(_rustPtr, static_cast<void*>(new std::variant<std::string, Car>(std::move(variant)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<std::string, Car>*>(__ffi.value)); }
    inline std::variant<std::shared_ptr<HybridBaseSpec>, OptionalWrapper> passAllEmptyObjectVariant(const std::variant<std::shared_ptr<HybridBaseSpec>, OptionalWrapper>& variant) override { auto __ffi = HybridTestObjectRustSpec_pass_all_empty_object_variant(_rustPtr, static_cast<void*>(new std::variant<std::shared_ptr<HybridBaseSpec>, OptionalWrapper>(std::move(variant)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<std::shared_ptr<HybridBaseSpec>, OptionalWrapper>*>(__ffi.value)); }
    inline std::variant<std::shared_ptr<ArrayBuffer>, std::function<void(double /* value */)>, WrappedJsStruct, std::shared_ptr<Promise<double>>, std::chrono::system_clock::time_point, std::shared_ptr<AnyMap>> bounceComplexVariant(const std::variant<std::shared_ptr<ArrayBuffer>, std::function<void(double /* value */)>, WrappedJsStruct, std::shared_ptr<Promise<double>>, std::chrono::system_clock::time_point, std::shared_ptr<AnyMap>>& variant) override { auto __ffi = HybridTestObjectRustSpec_bounce_complex_variant(_rustPtr, static_cast<void*>(new std::variant<std::shared_ptr<ArrayBuffer>, std::function<void(double /* value */)>, WrappedJsStruct, std::shared_ptr<Promise<double>>, std::chrono::system_clock::time_point, std::shared_ptr<AnyMap>>(std::move(variant)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<std::shared_ptr<ArrayBuffer>, std::function<void(double /* value */)>, WrappedJsStruct, std::shared_ptr<Promise<double>>, std::chrono::system_clock::time_point, std::shared_ptr<AnyMap>>*>(__ffi.value)); }
    inline std::shared_ptr<HybridChildSpec> createChild() override { auto __ffi = HybridTestObjectRustSpec_create_child(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::shared_ptr<HybridBaseSpec> createBase() override { auto __ffi = HybridTestObjectRustSpec_create_base(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::shared_ptr<HybridBaseSpec> createBaseActualChild() override { auto __ffi = HybridTestObjectRustSpec_create_base_actual_child(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::shared_ptr<HybridChildSpec> bounceChild(const std::shared_ptr<HybridChildSpec>& child) override { auto __ffi = HybridTestObjectRustSpec_bounce_child(_rustPtr, static_cast<void*>(new std::shared_ptr<HybridChildSpec>(child))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::shared_ptr<HybridBaseSpec> bounceBase(const std::shared_ptr<HybridBaseSpec>& base) override { auto __ffi = HybridTestObjectRustSpec_bounce_base(_rustPtr, static_cast<void*>(new std::shared_ptr<HybridBaseSpec>(base))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::shared_ptr<HybridBaseSpec> bounceChildBase(const std::shared_ptr<HybridChildSpec>& child) override { auto __ffi = HybridTestObjectRustSpec_bounce_child_base(_rustPtr, static_cast<void*>(new std::shared_ptr<HybridChildSpec>(child))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::shared_ptr<HybridChildSpec> castBase(const std::shared_ptr<HybridBaseSpec>& base) override { auto __ffi = HybridTestObjectRustSpec_cast_base(_rustPtr, static_cast<void*>(new std::shared_ptr<HybridBaseSpec>(base))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline double callbackSync(const std::function<double()>& callback) override { auto __ffi = HybridTestObjectRustSpec_callback_sync(_rustPtr, [&]() -> void* { struct __W { double(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> double { return (*static_cast<std::function<double()>*>(__ud))(); }, static_cast<void*>(new std::function<double()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<double()>*>(__ud); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline bool getIsViewBlue(const std::shared_ptr<HybridTestViewSpec>& view) override { auto __ffi = HybridTestObjectRustSpec_get_is_view_blue(_rustPtr, static_cast<void*>(new std::shared_ptr<HybridTestViewSpec>(view))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec> bounceExternalHybrid(const std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>& externalObject) override { auto __ffi = HybridTestObjectRustSpec_bounce_external_hybrid(_rustPtr, static_cast<void*>(new std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>(externalObject))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec> createInternalObject() override { auto __ffi = HybridTestObjectRustSpec_create_internal_object(_rustPtr); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }
    inline ExternalObjectStruct bounceExternalStruct(const ExternalObjectStruct& externalStruct) override { auto __ffi = HybridTestObjectRustSpec_bounce_external_struct(_rustPtr, static_cast<void*>(new ExternalObjectStruct(externalStruct))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return *static_cast<ExternalObjectStruct*>(__ffi.value); }
    inline std::variant<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>, std::string> bounceExternalVariant(const std::variant<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>, std::string>& variant) override { auto __ffi = HybridTestObjectRustSpec_bounce_external_variant(_rustPtr, static_cast<void*>(new std::variant<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>, std::string>(std::move(variant)))); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return std::move(*static_cast<std::variant<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>, std::string>*>(__ffi.value)); }
    inline std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec> createExternalVariantFromFunc(const std::function<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>()>& factory) override { auto __ffi = HybridTestObjectRustSpec_create_external_variant_from_func(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>(__r)); }, static_cast<void*>(new std::function<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>()>(std::move(factory))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>()>*>(__ud); } }); }()); if (!__ffi.is_ok) { __throwRustError(__ffi.error); } return __ffi.value; }

  public:
    inline size_t getExternalMemorySize() noexcept override {
      return HybridTestObjectRustSpec_memory_size(_rustPtr);
    }

  private:
    [[noreturn]] static void __throwRustError(char* error) {
      std::string msg(error);
      __nitrogen_free_cstring(error);
      throw std::runtime_error(msg);
    }

  private:
    void* _rustPtr;
  };

} // namespace margelo::nitro::test
