///
/// HybridTestObjectRustSpecRust.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

#include "HybridTestObjectRustSpec.hpp"

#include <memory>
#include "HybridTestObjectRustSpec.hpp"
#include <optional>
#include <string>
#include <NitroModules/Null.hpp>
#include <variant>
#include <vector>
#include "Powertrain.hpp"
#include "OldEnum.hpp"
#include <functional>
#include "Person.hpp"
#include "PartialPerson.hpp"
#include "Car.hpp"
#include "HybridChildSpec.hpp"
#include <NitroModules/AnyMap.hpp>
#include <NitroModules/Promise.hpp>
#include <NitroModules/ArrayBuffer.hpp>
#include <unordered_map>
#include "MapWrapper.hpp"
#include <exception>
#include <chrono>
#include "JsStyleStruct.hpp"
#include "WrappedJsStruct.hpp"
#include "OptionalWrapper.hpp"
#include "OptionalCallback.hpp"
#include "WeirdNumbersEnum.hpp"
#include "HybridBaseSpec.hpp"
#include "HybridTestViewSpec.hpp"
#include <NitroTestExternal/HybridSomeExternalObjectSpec.hpp>
#include "ExternalObjectStruct.hpp"

// Forward declarations for Rust FFI functions
extern "C" {
  void* HybridTestObjectRustSpec_get_this_object(void* rustPtr);
  void* HybridTestObjectRustSpec_get_optional_hybrid(void* rustPtr);
  void HybridTestObjectRustSpec_set_optional_hybrid(void* rustPtr, void* value);
  double HybridTestObjectRustSpec_get_number_value(void* rustPtr);
  void HybridTestObjectRustSpec_set_number_value(void* rustPtr, double value);
  bool HybridTestObjectRustSpec_get_bool_value(void* rustPtr);
  void HybridTestObjectRustSpec_set_bool_value(void* rustPtr, bool value);
  const char* HybridTestObjectRustSpec_get_string_value(void* rustPtr);
  void HybridTestObjectRustSpec_set_string_value(void* rustPtr, const char* value);
  int64_t HybridTestObjectRustSpec_get_int64_value(void* rustPtr);
  void HybridTestObjectRustSpec_set_int64_value(void* rustPtr, int64_t value);
  uint64_t HybridTestObjectRustSpec_get_uint64_value(void* rustPtr);
  void HybridTestObjectRustSpec_set_uint64_value(void* rustPtr, uint64_t value);
  void HybridTestObjectRustSpec_get_null_value(void* rustPtr);
  void HybridTestObjectRustSpec_set_null_value(void* rustPtr, void value);
  void* HybridTestObjectRustSpec_get_optional_string(void* rustPtr);
  void HybridTestObjectRustSpec_set_optional_string(void* rustPtr, void* value);
  void* HybridTestObjectRustSpec_get_string_or_undefined(void* rustPtr);
  void HybridTestObjectRustSpec_set_string_or_undefined(void* rustPtr, void* value);
  void* HybridTestObjectRustSpec_get_string_or_null(void* rustPtr);
  void HybridTestObjectRustSpec_set_string_or_null(void* rustPtr, void* value);
  void* HybridTestObjectRustSpec_get_optional_array(void* rustPtr);
  void HybridTestObjectRustSpec_set_optional_array(void* rustPtr, void* value);
  void* HybridTestObjectRustSpec_get_optional_enum(void* rustPtr);
  void HybridTestObjectRustSpec_set_optional_enum(void* rustPtr, void* value);
  void* HybridTestObjectRustSpec_get_optional_old_enum(void* rustPtr);
  void HybridTestObjectRustSpec_set_optional_old_enum(void* rustPtr, void* value);
  void* HybridTestObjectRustSpec_get_optional_callback(void* rustPtr);
  void HybridTestObjectRustSpec_set_optional_callback(void* rustPtr, void* value);
  void* HybridTestObjectRustSpec_get_some_variant(void* rustPtr);
  void HybridTestObjectRustSpec_set_some_variant(void* rustPtr, void* value);
  void* HybridTestObjectRustSpec_new_test_object(void* rustPtr);
  void* HybridTestObjectRustSpec_get_variant_hybrid(void* rustPtr, void* variant);
  void HybridTestObjectRustSpec_simple_func(void* rustPtr);
  double HybridTestObjectRustSpec_add_numbers(void* rustPtr, double a, double b);
  const char* HybridTestObjectRustSpec_add_strings(void* rustPtr, const char* a, const char* b);
  void HybridTestObjectRustSpec_multiple_arguments(void* rustPtr, double num, const char* str, bool boo);
  void HybridTestObjectRustSpec_bounce_null(void* rustPtr, void value);
  void* HybridTestObjectRustSpec_bounce_strings(void* rustPtr, void* array);
  void* HybridTestObjectRustSpec_bounce_numbers(void* rustPtr, void* array);
  void* HybridTestObjectRustSpec_bounce_structs(void* rustPtr, void* array);
  void* HybridTestObjectRustSpec_bounce_partial_struct(void* rustPtr, void* person);
  const char* HybridTestObjectRustSpec_sum_up_all_passengers(void* rustPtr, void* cars);
  void* HybridTestObjectRustSpec_bounce_enums(void* rustPtr, void* array);
  void HybridTestObjectRustSpec_complex_enum_callback(void* rustPtr, void* array, void* callback);
  void* HybridTestObjectRustSpec_bounce_hybrid_objects(void* rustPtr, void* array);
  void* HybridTestObjectRustSpec_bounce_functions(void* rustPtr, void* functions);
  void* HybridTestObjectRustSpec_bounce_maps(void* rustPtr, void* maps);
  void* HybridTestObjectRustSpec_bounce_promises(void* rustPtr, void* promises);
  void* HybridTestObjectRustSpec_bounce_array_buffers(void* rustPtr, void* arrayBuffers);
  void* HybridTestObjectRustSpec_create_map(void* rustPtr);
  void* HybridTestObjectRustSpec_map_roundtrip(void* rustPtr, void* map);
  void* HybridTestObjectRustSpec_get_map_keys(void* rustPtr, void* map);
  void* HybridTestObjectRustSpec_merge_maps(void* rustPtr, void* a, void* b);
  void* HybridTestObjectRustSpec_copy_any_map(void* rustPtr, void* map);
  void* HybridTestObjectRustSpec_bounce_map(void* rustPtr, void* map);
  void* HybridTestObjectRustSpec_bounce_simple_map(void* rustPtr, void* map);
  void* HybridTestObjectRustSpec_extract_map(void* rustPtr, void* mapWrapper);
  double HybridTestObjectRustSpec_func_that_throws(void* rustPtr);
  void HybridTestObjectRustSpec_func_that_throws_before_promise(void* rustPtr);
  void HybridTestObjectRustSpec_throw_error(void* rustPtr, const char* error);
  const char* HybridTestObjectRustSpec_try_optional_params(void* rustPtr, double num, bool boo, void* str);
  const char* HybridTestObjectRustSpec_try_middle_param(void* rustPtr, double num, void* boo, const char* str);
  void* HybridTestObjectRustSpec_try_optional_enum(void* rustPtr, void* value);
  bool HybridTestObjectRustSpec_try_trailing_optional(void* rustPtr, double num, const char* str, void* boo);
  double HybridTestObjectRustSpec_add1_hour(void* rustPtr, double date);
  double HybridTestObjectRustSpec_current_date(void* rustPtr);
  int64_t HybridTestObjectRustSpec_calculate_fibonacci_sync(void* rustPtr, double value);
  int64_t HybridTestObjectRustSpec_calculate_fibonacci_async(void* rustPtr, double value);
  void HybridTestObjectRustSpec_wait(void* rustPtr, double seconds);
  void HybridTestObjectRustSpec_promise_throws(void* rustPtr);
  double HybridTestObjectRustSpec_promise_returns_instantly(void* rustPtr);
  double HybridTestObjectRustSpec_promise_returns_instantly_async(void* rustPtr);
  void HybridTestObjectRustSpec_promise_that_resolves_void_instantly(void* rustPtr);
  void* HybridTestObjectRustSpec_promise_that_resolves_to_undefined(void* rustPtr);
  double HybridTestObjectRustSpec_await_and_get_promise(void* rustPtr, void* promise);
  void* HybridTestObjectRustSpec_await_and_get_complex_promise(void* rustPtr, void* promise);
  void HybridTestObjectRustSpec_await_promise(void* rustPtr, void* promise);
  void HybridTestObjectRustSpec_call_callback(void* rustPtr, void* callback);
  void HybridTestObjectRustSpec_call_callback_that_returns_promise_void(void* rustPtr, void* callback);
  void HybridTestObjectRustSpec_call_all(void* rustPtr, void* first, void* second, void* third);
  void HybridTestObjectRustSpec_call_with_optional(void* rustPtr, void* value, void* callback);
  double HybridTestObjectRustSpec_call_sum_up_n_times(void* rustPtr, void* callback, double n);
  double HybridTestObjectRustSpec_callback_async_promise(void* rustPtr, void* callback);
  void* HybridTestObjectRustSpec_callback_async_promise_buffer(void* rustPtr, void* callback);
  void* HybridTestObjectRustSpec_get_complex_callback(void* rustPtr);
  void HybridTestObjectRustSpec_two_optional_callbacks(void* rustPtr, double value, void* first, void* second);
  void HybridTestObjectRustSpec_error_callback(void* rustPtr, void* onError);
  void* HybridTestObjectRustSpec_create_native_callback(void* rustPtr, void* wrappingJsCallback);
  double HybridTestObjectRustSpec_get_value_from_j_s_callback_and_wait(void* rustPtr, void* getValue);
  void HybridTestObjectRustSpec_get_value_from_js_callback(void* rustPtr, void* callback, void* andThenCall);
  void* HybridTestObjectRustSpec_get_car(void* rustPtr);
  bool HybridTestObjectRustSpec_is_car_electric(void* rustPtr, void* car);
  void* HybridTestObjectRustSpec_get_driver(void* rustPtr, void* car);
  void* HybridTestObjectRustSpec_bounce_car(void* rustPtr, void* car);
  void HybridTestObjectRustSpec_js_style_object_as_parameters(void* rustPtr, void* params);
  void* HybridTestObjectRustSpec_bounce_wrapped_js_style_struct(void* rustPtr, void* value);
  void* HybridTestObjectRustSpec_bounce_optional_wrapper(void* rustPtr, void* wrapper);
  void* HybridTestObjectRustSpec_bounce_optional_callback(void* rustPtr, void* value);
  void* HybridTestObjectRustSpec_create_array_buffer(void* rustPtr);
  void* HybridTestObjectRustSpec_create_array_buffer_from_native_buffer(void* rustPtr, bool copy);
  void* HybridTestObjectRustSpec_copy_buffer(void* rustPtr, void* buffer);
  double HybridTestObjectRustSpec_get_buffer_last_item(void* rustPtr, void* buffer);
  void HybridTestObjectRustSpec_set_all_values_to(void* rustPtr, void* buffer, double value);
  void* HybridTestObjectRustSpec_create_array_buffer_async(void* rustPtr);
  void* HybridTestObjectRustSpec_bounce_array_buffer(void* rustPtr, void* buffer);
  void* HybridTestObjectRustSpec_pass_variant(void* rustPtr, void* either);
  void* HybridTestObjectRustSpec_get_variant_enum(void* rustPtr, void* variant);
  void* HybridTestObjectRustSpec_get_variant_weird_numbers_enum(void* rustPtr, void* variant);
  void* HybridTestObjectRustSpec_get_variant_objects(void* rustPtr, void* variant);
  void* HybridTestObjectRustSpec_pass_named_variant(void* rustPtr, void* variant);
  void* HybridTestObjectRustSpec_pass_all_empty_object_variant(void* rustPtr, void* variant);
  void* HybridTestObjectRustSpec_bounce_complex_variant(void* rustPtr, void* variant);
  void* HybridTestObjectRustSpec_create_child(void* rustPtr);
  void* HybridTestObjectRustSpec_create_base(void* rustPtr);
  void* HybridTestObjectRustSpec_create_base_actual_child(void* rustPtr);
  void* HybridTestObjectRustSpec_bounce_child(void* rustPtr, void* child);
  void* HybridTestObjectRustSpec_bounce_base(void* rustPtr, void* base);
  void* HybridTestObjectRustSpec_bounce_child_base(void* rustPtr, void* child);
  void* HybridTestObjectRustSpec_cast_base(void* rustPtr, void* base);
  double HybridTestObjectRustSpec_callback_sync(void* rustPtr, void* callback);
  bool HybridTestObjectRustSpec_get_is_view_blue(void* rustPtr, void* view);
  void* HybridTestObjectRustSpec_bounce_external_hybrid(void* rustPtr, void* externalObject);
  void* HybridTestObjectRustSpec_create_internal_object(void* rustPtr);
  void* HybridTestObjectRustSpec_bounce_external_struct(void* rustPtr, void* externalStruct);
  void* HybridTestObjectRustSpec_bounce_external_variant(void* rustPtr, void* variant);
  void* HybridTestObjectRustSpec_create_external_variant_from_func(void* rustPtr, void* factory);
  size_t HybridTestObjectRustSpec_memory_size(void* rustPtr);
  void HybridTestObjectRustSpec_destroy(void* rustPtr);
}

namespace margelo::nitro::test {

  /**
   * C++ bridge class that forwards HybridObject calls to a Rust implementation via extern "C" FFI.
   */
  class HybridTestObjectRustSpecRust: public virtual HybridTestObjectRustSpec {
  public:
    explicit HybridTestObjectRustSpecRust(void* rustPtr):
      HybridObject(HybridTestObjectRustSpec::TAG),
      _rustPtr(rustPtr) { }

    ~HybridTestObjectRustSpecRust() override {
      HybridTestObjectRustSpec_destroy(_rustPtr);
    }

  public:
    // Properties
    inline std::shared_ptr<HybridTestObjectRustSpec> getThisObject() override { return HybridTestObjectRustSpec_get_this_object(_rustPtr); }
    inline std::optional<std::shared_ptr<HybridTestObjectRustSpec>> getOptionalHybrid() override { return std::move(*static_cast<std::optional<std::shared_ptr<HybridTestObjectRustSpec>>*>(HybridTestObjectRustSpec_get_optional_hybrid(_rustPtr))); }
    inline void setOptionalHybrid(const std::optional<std::shared_ptr<HybridTestObjectRustSpec>>& optionalHybrid) override { HybridTestObjectRustSpec_set_optional_hybrid(_rustPtr, static_cast<void*>(new std::optional<std::shared_ptr<HybridTestObjectRustSpec>>(std::move(optionalHybrid)))); }
    inline double getNumberValue() override { return HybridTestObjectRustSpec_get_number_value(_rustPtr); }
    inline void setNumberValue(double numberValue) override { HybridTestObjectRustSpec_set_number_value(_rustPtr, numberValue); }
    inline bool getBoolValue() override { return HybridTestObjectRustSpec_get_bool_value(_rustPtr); }
    inline void setBoolValue(bool boolValue) override { HybridTestObjectRustSpec_set_bool_value(_rustPtr, boolValue); }
    inline std::string getStringValue() override { return std::string(HybridTestObjectRustSpec_get_string_value(_rustPtr)); }
    inline void setStringValue(const std::string& stringValue) override { HybridTestObjectRustSpec_set_string_value(_rustPtr, stringValue.c_str()); }
    inline int64_t getInt64Value() override { return HybridTestObjectRustSpec_get_int64_value(_rustPtr); }
    inline void setInt64Value(int64_t int64Value) override { HybridTestObjectRustSpec_set_int64_value(_rustPtr, int64Value); }
    inline uint64_t getUint64Value() override { return HybridTestObjectRustSpec_get_uint64_value(_rustPtr); }
    inline void setUint64Value(uint64_t uint64Value) override { HybridTestObjectRustSpec_set_uint64_value(_rustPtr, uint64Value); }
    inline nitro::NullType getNullValue() override { return HybridTestObjectRustSpec_get_null_value(_rustPtr); }
    inline void setNullValue(nitro::NullType nullValue) override { HybridTestObjectRustSpec_set_null_value(_rustPtr, nullValue); }
    inline std::optional<std::string> getOptionalString() override { return std::move(*static_cast<std::optional<std::string>*>(HybridTestObjectRustSpec_get_optional_string(_rustPtr))); }
    inline void setOptionalString(const std::optional<std::string>& optionalString) override { HybridTestObjectRustSpec_set_optional_string(_rustPtr, static_cast<void*>(new std::optional<std::string>(std::move(optionalString)))); }
    inline std::optional<std::string> getStringOrUndefined() override { return std::move(*static_cast<std::optional<std::string>*>(HybridTestObjectRustSpec_get_string_or_undefined(_rustPtr))); }
    inline void setStringOrUndefined(const std::optional<std::string>& stringOrUndefined) override { HybridTestObjectRustSpec_set_string_or_undefined(_rustPtr, static_cast<void*>(new std::optional<std::string>(std::move(stringOrUndefined)))); }
    inline std::variant<nitro::NullType, std::string> getStringOrNull() override { return std::move(*static_cast<std::variant<nitro::NullType, std::string>*>(HybridTestObjectRustSpec_get_string_or_null(_rustPtr))); }
    inline void setStringOrNull(const std::variant<nitro::NullType, std::string>& stringOrNull) override { HybridTestObjectRustSpec_set_string_or_null(_rustPtr, static_cast<void*>(new std::variant<nitro::NullType, std::string>(std::move(stringOrNull)))); }
    inline std::optional<std::vector<std::string>> getOptionalArray() override { return std::move(*static_cast<std::optional<std::vector<std::string>>*>(HybridTestObjectRustSpec_get_optional_array(_rustPtr))); }
    inline void setOptionalArray(const std::optional<std::vector<std::string>>& optionalArray) override { HybridTestObjectRustSpec_set_optional_array(_rustPtr, static_cast<void*>(new std::optional<std::vector<std::string>>(std::move(optionalArray)))); }
    inline std::optional<Powertrain> getOptionalEnum() override { return std::move(*static_cast<std::optional<Powertrain>*>(HybridTestObjectRustSpec_get_optional_enum(_rustPtr))); }
    inline void setOptionalEnum(std::optional<Powertrain> optionalEnum) override { HybridTestObjectRustSpec_set_optional_enum(_rustPtr, static_cast<void*>(new std::optional<Powertrain>(std::move(optionalEnum)))); }
    inline std::optional<OldEnum> getOptionalOldEnum() override { return std::move(*static_cast<std::optional<OldEnum>*>(HybridTestObjectRustSpec_get_optional_old_enum(_rustPtr))); }
    inline void setOptionalOldEnum(std::optional<OldEnum> optionalOldEnum) override { HybridTestObjectRustSpec_set_optional_old_enum(_rustPtr, static_cast<void*>(new std::optional<OldEnum>(std::move(optionalOldEnum)))); }
    inline std::optional<std::function<void(double /* value */)>> getOptionalCallback() override { return std::move(*static_cast<std::optional<std::function<void(double /* value */)>>*>(HybridTestObjectRustSpec_get_optional_callback(_rustPtr))); }
    inline void setOptionalCallback(const std::optional<std::function<void(double /* value */)>>& optionalCallback) override { HybridTestObjectRustSpec_set_optional_callback(_rustPtr, static_cast<void*>(new std::optional<std::function<void(double /* value */)>>(std::move(optionalCallback)))); }
    inline std::variant<std::string, double> getSomeVariant() override { return std::move(*static_cast<std::variant<std::string, double>*>(HybridTestObjectRustSpec_get_some_variant(_rustPtr))); }
    inline void setSomeVariant(const std::variant<std::string, double>& someVariant) override { HybridTestObjectRustSpec_set_some_variant(_rustPtr, static_cast<void*>(new std::variant<std::string, double>(std::move(someVariant)))); }

  public:
    // Methods
    inline std::shared_ptr<HybridTestObjectRustSpec> newTestObject() override { auto __result = HybridTestObjectRustSpec_new_test_object(_rustPtr); return __result; }
    inline std::variant<std::shared_ptr<HybridTestObjectRustSpec>, Person> getVariantHybrid(const std::variant<std::shared_ptr<HybridTestObjectRustSpec>, Person>& variant) override { auto __result = HybridTestObjectRustSpec_get_variant_hybrid(_rustPtr, static_cast<void*>(new std::variant<std::shared_ptr<HybridTestObjectRustSpec>, Person>(std::move(variant)))); return std::move(*static_cast<std::variant<std::shared_ptr<HybridTestObjectRustSpec>, Person>*>(__result)); }
    inline void simpleFunc() override { HybridTestObjectRustSpec_simple_func(_rustPtr); }
    inline double addNumbers(double a, double b) override { return HybridTestObjectRustSpec_add_numbers(_rustPtr, a, b); }
    inline std::string addStrings(const std::string& a, const std::string& b) override { auto __result = HybridTestObjectRustSpec_add_strings(_rustPtr, a.c_str(), b.c_str()); return std::string(__result); }
    inline void multipleArguments(double num, const std::string& str, bool boo) override { HybridTestObjectRustSpec_multiple_arguments(_rustPtr, num, str.c_str(), boo); }
    inline nitro::NullType bounceNull(nitro::NullType value) override { return HybridTestObjectRustSpec_bounce_null(_rustPtr, value); }
    inline std::vector<std::string> bounceStrings(const std::vector<std::string>& array) override { auto __result = HybridTestObjectRustSpec_bounce_strings(_rustPtr, static_cast<void*>(new std::vector<std::string>(std::move(array)))); return std::move(*static_cast<std::vector<std::string>*>(__result)); }
    inline std::vector<double> bounceNumbers(const std::vector<double>& array) override { auto __result = HybridTestObjectRustSpec_bounce_numbers(_rustPtr, static_cast<void*>(new std::vector<double>(std::move(array)))); return std::move(*static_cast<std::vector<double>*>(__result)); }
    inline std::vector<Person> bounceStructs(const std::vector<Person>& array) override { auto __result = HybridTestObjectRustSpec_bounce_structs(_rustPtr, static_cast<void*>(new std::vector<Person>(std::move(array)))); return std::move(*static_cast<std::vector<Person>*>(__result)); }
    inline PartialPerson bouncePartialStruct(const PartialPerson& person) override { auto __result = HybridTestObjectRustSpec_bounce_partial_struct(_rustPtr, static_cast<void*>(new PartialPerson(person))); return *static_cast<PartialPerson*>(__result); }
    inline std::string sumUpAllPassengers(const std::vector<Car>& cars) override { auto __result = HybridTestObjectRustSpec_sum_up_all_passengers(_rustPtr, static_cast<void*>(new std::vector<Car>(std::move(cars)))); return std::string(__result); }
    inline std::vector<Powertrain> bounceEnums(const std::vector<Powertrain>& array) override { auto __result = HybridTestObjectRustSpec_bounce_enums(_rustPtr, static_cast<void*>(new std::vector<Powertrain>(std::move(array)))); return std::move(*static_cast<std::vector<Powertrain>*>(__result)); }
    inline void complexEnumCallback(const std::vector<Powertrain>& array, const std::function<void(const std::vector<Powertrain>& /* array */)>& callback) override { HybridTestObjectRustSpec_complex_enum_callback(_rustPtr, static_cast<void*>(new std::vector<Powertrain>(std::move(array))), [&]() -> void* { struct __W { void(*fn_ptr)(void*, void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, void* __a0) { (*static_cast<std::function<void(const std::vector<Powertrain>& /* array */)>*>(__ud))(std::move(*static_cast<std::vector<Powertrain>*>(__a0))); }, static_cast<void*>(new std::function<void(const std::vector<Powertrain>& /* array */)>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<void(const std::vector<Powertrain>& /* array */)>*>(__ud); } }); }()); }
    inline std::vector<std::shared_ptr<HybridChildSpec>> bounceHybridObjects(const std::vector<std::shared_ptr<HybridChildSpec>>& array) override { auto __result = HybridTestObjectRustSpec_bounce_hybrid_objects(_rustPtr, static_cast<void*>(new std::vector<std::shared_ptr<HybridChildSpec>>(std::move(array)))); return std::move(*static_cast<std::vector<std::shared_ptr<HybridChildSpec>>*>(__result)); }
    inline std::vector<std::function<void()>> bounceFunctions(const std::vector<std::function<void()>>& functions) override { auto __result = HybridTestObjectRustSpec_bounce_functions(_rustPtr, static_cast<void*>(new std::vector<std::function<void()>>(std::move(functions)))); return std::move(*static_cast<std::vector<std::function<void()>>*>(__result)); }
    inline std::vector<std::shared_ptr<AnyMap>> bounceMaps(const std::vector<std::shared_ptr<AnyMap>>& maps) override { auto __result = HybridTestObjectRustSpec_bounce_maps(_rustPtr, static_cast<void*>(new std::vector<std::shared_ptr<AnyMap>>(std::move(maps)))); return std::move(*static_cast<std::vector<std::shared_ptr<AnyMap>>*>(__result)); }
    inline std::vector<std::shared_ptr<Promise<double>>> bouncePromises(const std::vector<std::shared_ptr<Promise<double>>>& promises) override { auto __result = HybridTestObjectRustSpec_bounce_promises(_rustPtr, static_cast<void*>(new std::vector<std::shared_ptr<Promise<double>>>(std::move(promises)))); return std::move(*static_cast<std::vector<std::shared_ptr<Promise<double>>>*>(__result)); }
    inline std::vector<std::shared_ptr<ArrayBuffer>> bounceArrayBuffers(const std::vector<std::shared_ptr<ArrayBuffer>>& arrayBuffers) override { auto __result = HybridTestObjectRustSpec_bounce_array_buffers(_rustPtr, static_cast<void*>(new std::vector<std::shared_ptr<ArrayBuffer>>(std::move(arrayBuffers)))); return std::move(*static_cast<std::vector<std::shared_ptr<ArrayBuffer>>*>(__result)); }
    inline std::shared_ptr<AnyMap> createMap() override { auto __result = HybridTestObjectRustSpec_create_map(_rustPtr); return std::move(*static_cast<std::shared_ptr<AnyMap>*>(__result)); }
    inline std::shared_ptr<AnyMap> mapRoundtrip(const std::shared_ptr<AnyMap>& map) override { auto __result = HybridTestObjectRustSpec_map_roundtrip(_rustPtr, static_cast<void*>(new std::shared_ptr<AnyMap>(std::move(map)))); return std::move(*static_cast<std::shared_ptr<AnyMap>*>(__result)); }
    inline std::vector<std::string> getMapKeys(const std::shared_ptr<AnyMap>& map) override { auto __result = HybridTestObjectRustSpec_get_map_keys(_rustPtr, static_cast<void*>(new std::shared_ptr<AnyMap>(std::move(map)))); return std::move(*static_cast<std::vector<std::string>*>(__result)); }
    inline std::shared_ptr<AnyMap> mergeMaps(const std::shared_ptr<AnyMap>& a, const std::shared_ptr<AnyMap>& b) override { auto __result = HybridTestObjectRustSpec_merge_maps(_rustPtr, static_cast<void*>(new std::shared_ptr<AnyMap>(std::move(a))), static_cast<void*>(new std::shared_ptr<AnyMap>(std::move(b)))); return std::move(*static_cast<std::shared_ptr<AnyMap>*>(__result)); }
    inline std::shared_ptr<AnyMap> copyAnyMap(const std::shared_ptr<AnyMap>& map) override { auto __result = HybridTestObjectRustSpec_copy_any_map(_rustPtr, static_cast<void*>(new std::shared_ptr<AnyMap>(std::move(map)))); return std::move(*static_cast<std::shared_ptr<AnyMap>*>(__result)); }
    inline std::unordered_map<std::string, std::variant<bool, double>> bounceMap(const std::unordered_map<std::string, std::variant<bool, double>>& map) override { auto __result = HybridTestObjectRustSpec_bounce_map(_rustPtr, static_cast<void*>(new std::unordered_map<std::string, std::variant<bool, double>>(std::move(map)))); return std::move(*static_cast<std::unordered_map<std::string, std::variant<bool, double>>*>(__result)); }
    inline std::unordered_map<std::string, double> bounceSimpleMap(const std::unordered_map<std::string, double>& map) override { auto __result = HybridTestObjectRustSpec_bounce_simple_map(_rustPtr, static_cast<void*>(new std::unordered_map<std::string, double>(std::move(map)))); return std::move(*static_cast<std::unordered_map<std::string, double>*>(__result)); }
    inline std::unordered_map<std::string, std::string> extractMap(const MapWrapper& mapWrapper) override { auto __result = HybridTestObjectRustSpec_extract_map(_rustPtr, static_cast<void*>(new MapWrapper(mapWrapper))); return std::move(*static_cast<std::unordered_map<std::string, std::string>*>(__result)); }
    inline double funcThatThrows() override { return HybridTestObjectRustSpec_func_that_throws(_rustPtr); }
    inline std::shared_ptr<Promise<void>> funcThatThrowsBeforePromise() override {
          return Promise<void>::async([=]() {
            HybridTestObjectRustSpec_func_that_throws_before_promise(_rustPtr);
          });
        }
    inline void throwError(const std::exception_ptr& error) override { HybridTestObjectRustSpec_throw_error(_rustPtr, [&]() -> const char* { try { std::rethrow_exception(error); } catch (const std::exception& e) { return e.what(); } catch (...) { return "unknown error"; } }()); }
    inline std::string tryOptionalParams(double num, bool boo, const std::optional<std::string>& str) override { auto __result = HybridTestObjectRustSpec_try_optional_params(_rustPtr, num, boo, static_cast<void*>(new std::optional<std::string>(std::move(str)))); return std::string(__result); }
    inline std::string tryMiddleParam(double num, std::optional<bool> boo, const std::string& str) override { auto __result = HybridTestObjectRustSpec_try_middle_param(_rustPtr, num, static_cast<void*>(new std::optional<bool>(std::move(boo))), str.c_str()); return std::string(__result); }
    inline std::optional<Powertrain> tryOptionalEnum(std::optional<Powertrain> value) override { auto __result = HybridTestObjectRustSpec_try_optional_enum(_rustPtr, static_cast<void*>(new std::optional<Powertrain>(std::move(value)))); return std::move(*static_cast<std::optional<Powertrain>*>(__result)); }
    inline bool tryTrailingOptional(double num, const std::string& str, std::optional<bool> boo) override { return HybridTestObjectRustSpec_try_trailing_optional(_rustPtr, num, str.c_str(), static_cast<void*>(new std::optional<bool>(std::move(boo)))); }
    inline std::chrono::system_clock::time_point add1Hour(std::chrono::system_clock::time_point date) override { auto __result = HybridTestObjectRustSpec_add1_hour(_rustPtr, std::chrono::duration<double, std::milli>(date.time_since_epoch()).count()); return std::chrono::system_clock::time_point(std::chrono::duration_cast<std::chrono::system_clock::duration>(std::chrono::duration<double, std::milli>(__result))); }
    inline std::chrono::system_clock::time_point currentDate() override { auto __result = HybridTestObjectRustSpec_current_date(_rustPtr); return std::chrono::system_clock::time_point(std::chrono::duration_cast<std::chrono::system_clock::duration>(std::chrono::duration<double, std::milli>(__result))); }
    inline int64_t calculateFibonacciSync(double value) override { return HybridTestObjectRustSpec_calculate_fibonacci_sync(_rustPtr, value); }
    inline std::shared_ptr<Promise<int64_t>> calculateFibonacciAsync(double value) override {
          return Promise<int64_t>::async([=]() -> int64_t {
            return HybridTestObjectRustSpec_calculate_fibonacci_async(_rustPtr, value);
          });
        }
    inline std::shared_ptr<Promise<void>> wait(double seconds) override {
          return Promise<void>::async([=]() {
            HybridTestObjectRustSpec_wait(_rustPtr, seconds);
          });
        }
    inline std::shared_ptr<Promise<void>> promiseThrows() override {
          return Promise<void>::async([=]() {
            HybridTestObjectRustSpec_promise_throws(_rustPtr);
          });
        }
    inline std::shared_ptr<Promise<double>> promiseReturnsInstantly() override {
          return Promise<double>::async([=]() -> double {
            return HybridTestObjectRustSpec_promise_returns_instantly(_rustPtr);
          });
        }
    inline std::shared_ptr<Promise<double>> promiseReturnsInstantlyAsync() override {
          return Promise<double>::async([=]() -> double {
            return HybridTestObjectRustSpec_promise_returns_instantly_async(_rustPtr);
          });
        }
    inline std::shared_ptr<Promise<void>> promiseThatResolvesVoidInstantly() override {
          return Promise<void>::async([=]() {
            HybridTestObjectRustSpec_promise_that_resolves_void_instantly(_rustPtr);
          });
        }
    inline std::shared_ptr<Promise<std::optional<double>>> promiseThatResolvesToUndefined() override {
          return Promise<std::optional<double>>::async([=]() -> std::optional<double> {
            auto __result = HybridTestObjectRustSpec_promise_that_resolves_to_undefined(_rustPtr);
            return std::move(*static_cast<std::optional<double>*>(__result));
          });
        }
    inline std::shared_ptr<Promise<double>> awaitAndGetPromise(const std::shared_ptr<Promise<double>>& promise) override {
          return Promise<double>::async([=]() -> double {
            return HybridTestObjectRustSpec_await_and_get_promise(_rustPtr, static_cast<void*>(new std::shared_ptr<Promise<double>>(std::move(promise))));
          });
        }
    inline std::shared_ptr<Promise<Car>> awaitAndGetComplexPromise(const std::shared_ptr<Promise<Car>>& promise) override {
          return Promise<Car>::async([=]() -> Car {
            auto __result = HybridTestObjectRustSpec_await_and_get_complex_promise(_rustPtr, static_cast<void*>(new std::shared_ptr<Promise<Car>>(std::move(promise))));
            return *static_cast<Car*>(__result);
          });
        }
    inline std::shared_ptr<Promise<void>> awaitPromise(const std::shared_ptr<Promise<void>>& promise) override {
          return Promise<void>::async([=]() {
            HybridTestObjectRustSpec_await_promise(_rustPtr, static_cast<void*>(new std::shared_ptr<Promise<void>>(std::move(promise))));
          });
        }
    inline void callCallback(const std::function<void()>& callback) override { HybridTestObjectRustSpec_call_callback(_rustPtr, [&]() -> void* { struct __W { void(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) { (*static_cast<std::function<void()>*>(__ud))(); }, static_cast<void*>(new std::function<void()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<void()>*>(__ud); } }); }()); }
    inline std::shared_ptr<Promise<void>> callCallbackThatReturnsPromiseVoid(const std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>()>& callback) override {
          return Promise<void>::async([=]() {
            HybridTestObjectRustSpec_call_callback_that_returns_promise_void(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>()>*>(__ud); } }); }());
          });
        }
    inline void callAll(const std::function<void()>& first, const std::function<void()>& second, const std::function<void()>& third) override { HybridTestObjectRustSpec_call_all(_rustPtr, [&]() -> void* { struct __W { void(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) { (*static_cast<std::function<void()>*>(__ud))(); }, static_cast<void*>(new std::function<void()>(std::move(first))), [](void* __ud) { delete static_cast<std::function<void()>*>(__ud); } }); }(), [&]() -> void* { struct __W { void(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) { (*static_cast<std::function<void()>*>(__ud))(); }, static_cast<void*>(new std::function<void()>(std::move(second))), [](void* __ud) { delete static_cast<std::function<void()>*>(__ud); } }); }(), [&]() -> void* { struct __W { void(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) { (*static_cast<std::function<void()>*>(__ud))(); }, static_cast<void*>(new std::function<void()>(std::move(third))), [](void* __ud) { delete static_cast<std::function<void()>*>(__ud); } }); }()); }
    inline void callWithOptional(std::optional<double> value, const std::function<void(std::optional<double> /* maybe */)>& callback) override { HybridTestObjectRustSpec_call_with_optional(_rustPtr, static_cast<void*>(new std::optional<double>(std::move(value))), [&]() -> void* { struct __W { void(*fn_ptr)(void*, void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, void* __a0) { (*static_cast<std::function<void(std::optional<double> /* maybe */)>*>(__ud))(std::move(*static_cast<std::optional<double>*>(__a0))); }, static_cast<void*>(new std::function<void(std::optional<double> /* maybe */)>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<void(std::optional<double> /* maybe */)>*>(__ud); } }); }()); }
    inline std::shared_ptr<Promise<double>> callSumUpNTimes(const std::function<std::shared_ptr<Promise<double>>()>& callback, double n) override {
          return Promise<double>::async([=]() -> double {
            return HybridTestObjectRustSpec_call_sum_up_n_times(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<double>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<double>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<double>>()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<double>>()>*>(__ud); } }); }(), n);
          });
        }
    inline std::shared_ptr<Promise<double>> callbackAsyncPromise(const std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>()>& callback) override {
          return Promise<double>::async([=]() -> double {
            return HybridTestObjectRustSpec_callback_async_promise(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>()>*>(__ud); } }); }());
          });
        }
    inline std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>> callbackAsyncPromiseBuffer(const std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>()>& callback) override {
          return Promise<std::shared_ptr<ArrayBuffer>>::async([=]() -> std::shared_ptr<ArrayBuffer> {
            auto __result = HybridTestObjectRustSpec_callback_async_promise_buffer(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>()>*>(__ud); } }); }());
            return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__result); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }();
          });
        }
    inline std::function<void(double /* value */)> getComplexCallback() override { auto __result = HybridTestObjectRustSpec_get_complex_callback(_rustPtr); return std::move(*static_cast<std::function<void(double /* value */)>*>(__result)); }
    inline void twoOptionalCallbacks(double value, const std::optional<std::function<void(double /* value */)>>& first, const std::optional<std::function<void(const std::string& /* value */)>>& second) override { HybridTestObjectRustSpec_two_optional_callbacks(_rustPtr, value, static_cast<void*>(new std::optional<std::function<void(double /* value */)>>(std::move(first))), static_cast<void*>(new std::optional<std::function<void(const std::string& /* value */)>>(std::move(second)))); }
    inline void errorCallback(const std::function<void(const std::exception_ptr& /* error */)>& onError) override { HybridTestObjectRustSpec_error_callback(_rustPtr, [&]() -> void* { struct __W { void(*fn_ptr)(void*, const char*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, const char* __a0) { (*static_cast<std::function<void(const std::exception_ptr& /* error */)>*>(__ud))(std::make_exception_ptr(std::runtime_error(__a0))); }, static_cast<void*>(new std::function<void(const std::exception_ptr& /* error */)>(std::move(onError))), [](void* __ud) { delete static_cast<std::function<void(const std::exception_ptr& /* error */)>*>(__ud); } }); }()); }
    inline std::function<void(double /* num */)> createNativeCallback(const std::function<void(double /* num */)>& wrappingJsCallback) override { auto __result = HybridTestObjectRustSpec_create_native_callback(_rustPtr, [&]() -> void* { struct __W { void(*fn_ptr)(void*, double); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, double __a0) { (*static_cast<std::function<void(double /* num */)>*>(__ud))(__a0); }, static_cast<void*>(new std::function<void(double /* num */)>(std::move(wrappingJsCallback))), [](void* __ud) { delete static_cast<std::function<void(double /* num */)>*>(__ud); } }); }()); return std::move(*static_cast<std::function<void(double /* num */)>*>(__result)); }
    inline std::shared_ptr<Promise<double>> getValueFromJSCallbackAndWait(const std::function<std::shared_ptr<Promise<double>>()>& getValue) override {
          return Promise<double>::async([=]() -> double {
            return HybridTestObjectRustSpec_get_value_from_j_s_callback_and_wait(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<double>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<double>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<double>>()>(std::move(getValue))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<double>>()>*>(__ud); } }); }());
          });
        }
    inline std::shared_ptr<Promise<void>> getValueFromJsCallback(const std::function<std::shared_ptr<Promise<std::string>>()>& callback, const std::function<void(const std::string& /* valueFromJs */)>& andThenCall) override {
          return Promise<void>::async([=]() {
            HybridTestObjectRustSpec_get_value_from_js_callback(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<Promise<std::string>>()>*>(__ud))(); return static_cast<void*>(new std::shared_ptr<Promise<std::string>>(std::move(__r))); }, static_cast<void*>(new std::function<std::shared_ptr<Promise<std::string>>()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<Promise<std::string>>()>*>(__ud); } }); }(), [&]() -> void* { struct __W { void(*fn_ptr)(void*, const char*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud, const char* __a0) { (*static_cast<std::function<void(const std::string& /* valueFromJs */)>*>(__ud))(std::string(__a0)); }, static_cast<void*>(new std::function<void(const std::string& /* valueFromJs */)>(std::move(andThenCall))), [](void* __ud) { delete static_cast<std::function<void(const std::string& /* valueFromJs */)>*>(__ud); } }); }());
          });
        }
    inline Car getCar() override { auto __result = HybridTestObjectRustSpec_get_car(_rustPtr); return *static_cast<Car*>(__result); }
    inline bool isCarElectric(const Car& car) override { return HybridTestObjectRustSpec_is_car_electric(_rustPtr, static_cast<void*>(new Car(car))); }
    inline std::optional<Person> getDriver(const Car& car) override { auto __result = HybridTestObjectRustSpec_get_driver(_rustPtr, static_cast<void*>(new Car(car))); return std::move(*static_cast<std::optional<Person>*>(__result)); }
    inline Car bounceCar(const Car& car) override { auto __result = HybridTestObjectRustSpec_bounce_car(_rustPtr, static_cast<void*>(new Car(car))); return *static_cast<Car*>(__result); }
    inline void jsStyleObjectAsParameters(const JsStyleStruct& params) override { HybridTestObjectRustSpec_js_style_object_as_parameters(_rustPtr, static_cast<void*>(new JsStyleStruct(params))); }
    inline WrappedJsStruct bounceWrappedJsStyleStruct(const WrappedJsStruct& value) override { auto __result = HybridTestObjectRustSpec_bounce_wrapped_js_style_struct(_rustPtr, static_cast<void*>(new WrappedJsStruct(value))); return *static_cast<WrappedJsStruct*>(__result); }
    inline OptionalWrapper bounceOptionalWrapper(const OptionalWrapper& wrapper) override { auto __result = HybridTestObjectRustSpec_bounce_optional_wrapper(_rustPtr, static_cast<void*>(new OptionalWrapper(wrapper))); return *static_cast<OptionalWrapper*>(__result); }
    inline OptionalCallback bounceOptionalCallback(const OptionalCallback& value) override { auto __result = HybridTestObjectRustSpec_bounce_optional_callback(_rustPtr, static_cast<void*>(new OptionalCallback(value))); return *static_cast<OptionalCallback*>(__result); }
    inline std::shared_ptr<ArrayBuffer> createArrayBuffer() override { auto __result = HybridTestObjectRustSpec_create_array_buffer(_rustPtr); return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__result); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }(); }
    inline std::shared_ptr<ArrayBuffer> createArrayBufferFromNativeBuffer(bool copy) override { auto __result = HybridTestObjectRustSpec_create_array_buffer_from_native_buffer(_rustPtr, copy); return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__result); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }(); }
    inline std::shared_ptr<ArrayBuffer> copyBuffer(const std::shared_ptr<ArrayBuffer>& buffer) override { auto __result = HybridTestObjectRustSpec_copy_buffer(_rustPtr, [&]() -> void* { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __sp = new std::shared_ptr<ArrayBuffer>(std::move(buffer)); return static_cast<void*>(new __NB { (*__sp)->data(), (*__sp)->size(), static_cast<void*>(__sp), [](void* __h) { delete static_cast<std::shared_ptr<ArrayBuffer>*>(__h); } }); }()); return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__result); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }(); }
    inline double getBufferLastItem(const std::shared_ptr<ArrayBuffer>& buffer) override { return HybridTestObjectRustSpec_get_buffer_last_item(_rustPtr, [&]() -> void* { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __sp = new std::shared_ptr<ArrayBuffer>(std::move(buffer)); return static_cast<void*>(new __NB { (*__sp)->data(), (*__sp)->size(), static_cast<void*>(__sp), [](void* __h) { delete static_cast<std::shared_ptr<ArrayBuffer>*>(__h); } }); }()); }
    inline void setAllValuesTo(const std::shared_ptr<ArrayBuffer>& buffer, double value) override { HybridTestObjectRustSpec_set_all_values_to(_rustPtr, [&]() -> void* { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __sp = new std::shared_ptr<ArrayBuffer>(std::move(buffer)); return static_cast<void*>(new __NB { (*__sp)->data(), (*__sp)->size(), static_cast<void*>(__sp), [](void* __h) { delete static_cast<std::shared_ptr<ArrayBuffer>*>(__h); } }); }(), value); }
    inline std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>> createArrayBufferAsync() override {
          return Promise<std::shared_ptr<ArrayBuffer>>::async([=]() -> std::shared_ptr<ArrayBuffer> {
            auto __result = HybridTestObjectRustSpec_create_array_buffer_async(_rustPtr);
            return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__result); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }();
          });
        }
    inline std::shared_ptr<ArrayBuffer> bounceArrayBuffer(const std::shared_ptr<ArrayBuffer>& buffer) override { auto __result = HybridTestObjectRustSpec_bounce_array_buffer(_rustPtr, [&]() -> void* { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __sp = new std::shared_ptr<ArrayBuffer>(std::move(buffer)); return static_cast<void*>(new __NB { (*__sp)->data(), (*__sp)->size(), static_cast<void*>(__sp), [](void* __h) { delete static_cast<std::shared_ptr<ArrayBuffer>*>(__h); } }); }()); return [&]() -> std::shared_ptr<ArrayBuffer> { struct __NB { uint8_t* data; size_t len; void* handle; void(*release_fn)(void*); }; auto __nb = static_cast<__NB*>(__result); auto __data = __nb->data; auto __len = __nb->len; auto __handle = __nb->handle; auto __release = __nb->release_fn; delete __nb; return ArrayBuffer::wrap(__data, __len, [=]() { __release(__handle); }); }(); }
    inline std::variant<std::string, double> passVariant(const std::variant<bool, std::vector<double>, std::vector<std::string>, std::string, double>& either) override { auto __result = HybridTestObjectRustSpec_pass_variant(_rustPtr, static_cast<void*>(new std::variant<bool, std::vector<double>, std::vector<std::string>, std::string, double>(std::move(either)))); return std::move(*static_cast<std::variant<std::string, double>*>(__result)); }
    inline std::variant<bool, OldEnum> getVariantEnum(const std::variant<bool, OldEnum>& variant) override { auto __result = HybridTestObjectRustSpec_get_variant_enum(_rustPtr, static_cast<void*>(new std::variant<bool, OldEnum>(std::move(variant)))); return std::move(*static_cast<std::variant<bool, OldEnum>*>(__result)); }
    inline std::variant<bool, WeirdNumbersEnum> getVariantWeirdNumbersEnum(const std::variant<bool, WeirdNumbersEnum>& variant) override { auto __result = HybridTestObjectRustSpec_get_variant_weird_numbers_enum(_rustPtr, static_cast<void*>(new std::variant<bool, WeirdNumbersEnum>(std::move(variant)))); return std::move(*static_cast<std::variant<bool, WeirdNumbersEnum>*>(__result)); }
    inline std::variant<Car, Person> getVariantObjects(const std::variant<Car, Person>& variant) override { auto __result = HybridTestObjectRustSpec_get_variant_objects(_rustPtr, static_cast<void*>(new std::variant<Car, Person>(std::move(variant)))); return std::move(*static_cast<std::variant<Car, Person>*>(__result)); }
    inline std::variant<std::string, Car> passNamedVariant(const std::variant<std::string, Car>& variant) override { auto __result = HybridTestObjectRustSpec_pass_named_variant(_rustPtr, static_cast<void*>(new std::variant<std::string, Car>(std::move(variant)))); return std::move(*static_cast<std::variant<std::string, Car>*>(__result)); }
    inline std::variant<std::shared_ptr<HybridBaseSpec>, OptionalWrapper> passAllEmptyObjectVariant(const std::variant<std::shared_ptr<HybridBaseSpec>, OptionalWrapper>& variant) override { auto __result = HybridTestObjectRustSpec_pass_all_empty_object_variant(_rustPtr, static_cast<void*>(new std::variant<std::shared_ptr<HybridBaseSpec>, OptionalWrapper>(std::move(variant)))); return std::move(*static_cast<std::variant<std::shared_ptr<HybridBaseSpec>, OptionalWrapper>*>(__result)); }
    inline std::variant<std::shared_ptr<ArrayBuffer>, std::function<void(double /* value */)>, WrappedJsStruct, std::shared_ptr<Promise<double>>, std::chrono::system_clock::time_point, std::shared_ptr<AnyMap>> bounceComplexVariant(const std::variant<std::shared_ptr<ArrayBuffer>, std::function<void(double /* value */)>, WrappedJsStruct, std::shared_ptr<Promise<double>>, std::chrono::system_clock::time_point, std::shared_ptr<AnyMap>>& variant) override { auto __result = HybridTestObjectRustSpec_bounce_complex_variant(_rustPtr, static_cast<void*>(new std::variant<std::shared_ptr<ArrayBuffer>, std::function<void(double /* value */)>, WrappedJsStruct, std::shared_ptr<Promise<double>>, std::chrono::system_clock::time_point, std::shared_ptr<AnyMap>>(std::move(variant)))); return std::move(*static_cast<std::variant<std::shared_ptr<ArrayBuffer>, std::function<void(double /* value */)>, WrappedJsStruct, std::shared_ptr<Promise<double>>, std::chrono::system_clock::time_point, std::shared_ptr<AnyMap>>*>(__result)); }
    inline std::shared_ptr<HybridChildSpec> createChild() override { auto __result = HybridTestObjectRustSpec_create_child(_rustPtr); return __result; }
    inline std::shared_ptr<HybridBaseSpec> createBase() override { auto __result = HybridTestObjectRustSpec_create_base(_rustPtr); return __result; }
    inline std::shared_ptr<HybridBaseSpec> createBaseActualChild() override { auto __result = HybridTestObjectRustSpec_create_base_actual_child(_rustPtr); return __result; }
    inline std::shared_ptr<HybridChildSpec> bounceChild(const std::shared_ptr<HybridChildSpec>& child) override { auto __result = HybridTestObjectRustSpec_bounce_child(_rustPtr, static_cast<void*>(child.get())); return __result; }
    inline std::shared_ptr<HybridBaseSpec> bounceBase(const std::shared_ptr<HybridBaseSpec>& base) override { auto __result = HybridTestObjectRustSpec_bounce_base(_rustPtr, static_cast<void*>(base.get())); return __result; }
    inline std::shared_ptr<HybridBaseSpec> bounceChildBase(const std::shared_ptr<HybridChildSpec>& child) override { auto __result = HybridTestObjectRustSpec_bounce_child_base(_rustPtr, static_cast<void*>(child.get())); return __result; }
    inline std::shared_ptr<HybridChildSpec> castBase(const std::shared_ptr<HybridBaseSpec>& base) override { auto __result = HybridTestObjectRustSpec_cast_base(_rustPtr, static_cast<void*>(base.get())); return __result; }
    inline double callbackSync(const std::function<double()>& callback) override { return HybridTestObjectRustSpec_callback_sync(_rustPtr, [&]() -> void* { struct __W { double(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> double { return (*static_cast<std::function<double()>*>(__ud))(); }, static_cast<void*>(new std::function<double()>(std::move(callback))), [](void* __ud) { delete static_cast<std::function<double()>*>(__ud); } }); }()); }
    inline bool getIsViewBlue(const std::shared_ptr<HybridTestViewSpec>& view) override { return HybridTestObjectRustSpec_get_is_view_blue(_rustPtr, static_cast<void*>(view.get())); }
    inline std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec> bounceExternalHybrid(const std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>& externalObject) override { auto __result = HybridTestObjectRustSpec_bounce_external_hybrid(_rustPtr, static_cast<void*>(externalObject.get())); return __result; }
    inline std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec> createInternalObject() override { auto __result = HybridTestObjectRustSpec_create_internal_object(_rustPtr); return __result; }
    inline ExternalObjectStruct bounceExternalStruct(const ExternalObjectStruct& externalStruct) override { auto __result = HybridTestObjectRustSpec_bounce_external_struct(_rustPtr, static_cast<void*>(new ExternalObjectStruct(externalStruct))); return *static_cast<ExternalObjectStruct*>(__result); }
    inline std::variant<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>, std::string> bounceExternalVariant(const std::variant<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>, std::string>& variant) override { auto __result = HybridTestObjectRustSpec_bounce_external_variant(_rustPtr, static_cast<void*>(new std::variant<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>, std::string>(std::move(variant)))); return std::move(*static_cast<std::variant<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>, std::string>*>(__result)); }
    inline std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec> createExternalVariantFromFunc(const std::function<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>()>& factory) override { auto __result = HybridTestObjectRustSpec_create_external_variant_from_func(_rustPtr, [&]() -> void* { struct __W { void*(*fn_ptr)(void*); void* userdata; void(*destroy_fn)(void*); }; return static_cast<void*>(new __W { [](void* __ud) -> void* { auto __r = (*static_cast<std::function<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>()>*>(__ud))(); return static_cast<void*>(__r.get()); }, static_cast<void*>(new std::function<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>()>(std::move(factory))), [](void* __ud) { delete static_cast<std::function<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>()>*>(__ud); } }); }()); return __result; }

  public:
    inline size_t getExternalMemorySize() noexcept override {
      return HybridTestObjectRustSpec_memory_size(_rustPtr);
    }

  private:
    void* _rustPtr;
  };

} // namespace margelo::nitro::test
