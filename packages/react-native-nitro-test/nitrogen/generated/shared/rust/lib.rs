//
// lib.rs
// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
// https://github.com/mrousavy/nitro
// Copyright Â© Marc Rousavy @ Margelo
//
#![allow(
    non_camel_case_types,
    non_snake_case,
    dead_code,
    unused_imports,
    clippy::needless_return,
    clippy::redundant_closure,
    clippy::new_without_default,
    clippy::useless_conversion
)]

pub mod Car;
pub mod CoreTypesVariant;
pub mod ExternalObjectStruct;
pub mod Func_double;
pub mod Func_std__shared_ptr_Promise_double__;
pub mod Func_std__shared_ptr_Promise_std__shared_ptr_Promise_double____;
pub mod Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer_____;
pub mod Func_std__shared_ptr_Promise_std__shared_ptr_Promise_void____;
pub mod Func_std__shared_ptr_Promise_std__string__;
pub mod Func_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_;
pub mod Func_void;
pub mod Func_void_double;
pub mod Func_void_std__exception_ptr;
pub mod Func_void_std__optional_double_;
pub mod Func_void_std__string;
pub mod Func_void_std__vector_Powertrain_;
pub mod HybridTestObjectRustSpec;
pub mod JsStyleStruct;
pub mod MapWrapper;
pub mod NamedVariant;
pub mod NitroBuffer;
pub mod OldEnum;
pub mod OptionalCallback;
pub mod OptionalWrapper;
pub mod PartialPerson;
pub mod Person;
pub mod Powertrain;
pub mod SecondMapWrapper;
pub mod StringOrExternal;
pub mod Variant_Box_dyn_Fn____f64;
pub mod Variant_Box_dyn_HybridBaseSpec__OptionalWrapper;
pub mod Variant_Box_dyn_HybridTestObjectRustSpec__Person;
pub mod Variant_Car_Person;
pub mod Variant_String_f64;
pub mod Variant____String;
pub mod Variant_bool_OldEnum;
pub mod Variant_bool_Vec_f64__Vec_String__String_f64;
pub mod Variant_bool_WeirdNumbersEnum;
pub mod Variant_bool_f64;
pub mod WeirdNumbersEnum;
pub mod WrappedJsStruct;

// Stub modules for externally referenced types.
// These are types referenced by the generated code but not implemented in Rust.
// Replace these stubs with real implementations or external crate imports as needed.
pub mod HybridBaseSpec {
    pub trait HybridBaseSpec: Send + Sync {}
}
pub mod HybridChildSpec {
    pub trait HybridChildSpec: Send + Sync {}
}
pub mod HybridSomeExternalObjectSpec {
    pub trait HybridSomeExternalObjectSpec: Send + Sync {}
}
pub mod HybridTestViewSpec {
    pub trait HybridTestViewSpec: Send + Sync {}
}

/// Free a Rust-allocated CString from C++.
/// This is called by the C++ bridge to deallocate strings returned from Rust.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn __nitrogen_free_cstring(ptr: *mut std::ffi::c_char) {
    unsafe {
        let _ = std::ffi::CString::from_raw(ptr);
    }
}

/// Convert a panic payload into a C string for FFI error propagation.
pub fn __nitro_panic_to_cstring(panic: Box<dyn std::any::Any + Send>) -> *mut std::ffi::c_char {
    let msg = if let Some(s) = panic.downcast_ref::<&str>() {
        s.to_string()
    } else if let Some(s) = panic.downcast_ref::<String>() {
        s.clone()
    } else {
        "unknown Rust panic".to_string()
    };
    let safe = msg.replace('\0', "");
    std::ffi::CString::new(safe).unwrap_or_default().into_raw()
}

// FFI result structs for error propagation across the Rust/C++ boundary.
// Each shim returns one of these instead of a bare value, so panics
// can be caught with catch_unwind and reported to C++ as errors.

#[repr(C)]
pub struct __FfiResult_void {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
}

#[repr(C)]
pub struct __FfiResult_f64 {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: f64,
}

#[repr(C)]
pub struct __FfiResult_bool {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: bool,
}

#[repr(C)]
pub struct __FfiResult_i32 {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: i32,
}

#[repr(C)]
pub struct __FfiResult_i64 {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: i64,
}

#[repr(C)]
pub struct __FfiResult_u64 {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: u64,
}

#[repr(C)]
pub struct __FfiResult_usize {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: usize,
}

#[repr(C)]
pub struct __FfiResult_cstr {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: *const std::ffi::c_char,
}

#[repr(C)]
pub struct __FfiResult_ptr {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: *mut std::ffi::c_void,
}
