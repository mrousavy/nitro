//
// lib.rs
// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
// https://github.com/mrousavy/nitro
// Copyright Â© Marc Rousavy @ Margelo
//
#![allow(
    non_camel_case_types,
    non_snake_case,
    dead_code,
    unused_imports,
    clippy::needless_return,
    clippy::redundant_closure,
    clippy::new_without_default,
    clippy::useless_conversion
)]

pub mod any_map;
pub mod car;
pub mod core_types_variant;
pub mod external_object_struct;
pub mod func_double;
pub mod func_std__shared_ptr_margelo__nitro__test__external__hybrid_some_external_object_spec_;
pub mod func_std__shared_ptr_promise_double__;
pub mod func_std__shared_ptr_promise_std__shared_ptr_promise_double____;
pub mod func_std__shared_ptr_promise_std__shared_ptr_promise_std__shared_ptr_array_buffer_____;
pub mod func_std__shared_ptr_promise_std__shared_ptr_promise_void____;
pub mod func_std__shared_ptr_promise_std__string__;
pub mod func_void;
pub mod func_void_double;
pub mod func_void_std__exception_ptr;
pub mod func_void_std__optional_double_;
pub mod func_void_std__string;
pub mod func_void_std__vector_powertrain_;
pub mod hybrid_test_object_rust_spec;
pub mod js_style_struct;
pub mod map_wrapper;
pub mod named_variant;
pub mod nitro_buffer;
pub mod old_enum;
pub mod optional_callback;
pub mod optional_wrapper;
pub mod partial_person;
pub mod person;
pub mod powertrain;
pub mod second_map_wrapper;
pub mod string_or_external;
pub mod variant____string;
pub mod variant_bool_f64;
pub mod variant_bool_old_enum;
pub mod variant_bool_vec_f64__vec_string__string_f64;
pub mod variant_bool_weird_numbers_enum;
pub mod variant_box_dyn_fn____f64;
pub mod variant_box_dyn_hybrid_base_spec__optional_wrapper;
pub mod variant_box_dyn_hybrid_test_object_rust_spec__person;
pub mod variant_car_person;
pub mod variant_string_f64;
pub mod weird_numbers_enum;
pub mod wrapped_js_struct;

// Stub modules for externally referenced types.
// These are types referenced by the generated code but not implemented in Rust.
// Replace these stubs with real implementations or external crate imports as needed.
pub mod hybrid_base_spec {
    pub trait HybridBaseSpec: Send + Sync {}
}
pub mod hybrid_child_spec {
    pub trait HybridChildSpec: Send + Sync {}
}
pub mod hybrid_some_external_object_spec {
    pub trait HybridSomeExternalObjectSpec: Send + Sync {}
}
pub mod hybrid_test_view_spec {
    pub trait HybridTestViewSpec: Send + Sync {}
}

/// Free a Rust-allocated CString from C++.
/// This is called by the C++ bridge to deallocate strings returned from Rust.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn __nitrogen_free_cstring(ptr: *mut std::ffi::c_char) {
    unsafe {
        let _ = std::ffi::CString::from_raw(ptr);
    }
}

/// Convert a panic payload into a C string for FFI error propagation.
pub fn __nitro_panic_to_cstring(panic: Box<dyn std::any::Any + Send>) -> *mut std::ffi::c_char {
    let msg = if let Some(s) = panic.downcast_ref::<&str>() {
        s.to_string()
    } else if let Some(s) = panic.downcast_ref::<String>() {
        s.clone()
    } else {
        "unknown Rust panic".to_string()
    };
    let safe = msg.replace('\0', "");
    std::ffi::CString::new(safe).unwrap_or_default().into_raw()
}

// FFI result structs for error propagation across the Rust/C++ boundary.
// Each shim returns one of these instead of a bare value, so panics
// can be caught with catch_unwind and reported to C++ as errors.

#[repr(C)]
pub struct __FfiResult_void {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
}

#[repr(C)]
pub struct __FfiResult_f64 {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: f64,
}

#[repr(C)]
pub struct __FfiResult_bool {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: bool,
}

#[repr(C)]
pub struct __FfiResult_i32 {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: i32,
}

#[repr(C)]
pub struct __FfiResult_i64 {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: i64,
}

#[repr(C)]
pub struct __FfiResult_u64 {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: u64,
}

#[repr(C)]
pub struct __FfiResult_usize {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: usize,
}

#[repr(C)]
pub struct __FfiResult_cstr {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: *const std::ffi::c_char,
}

#[repr(C)]
pub struct __FfiResult_ptr {
    pub is_ok: u8,
    pub error: *mut std::ffi::c_char,
    pub value: *mut std::ffi::c_void,
}
