//
// hybrid_test_object_rust_spec.rs
// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
// https://github.com/mrousavy/nitro
// Copyright © Marc Rousavy @ Margelo
//
#![allow(
    non_camel_case_types,
    non_snake_case,
    dead_code,
    unused_imports,
    clippy::needless_return,
    clippy::redundant_closure,
    clippy::new_without_default,
    clippy::useless_conversion
)]

use super::any_map::AnyMap;
use super::car::Car;
use super::core_types_variant::CoreTypesVariant;
use super::external_object_struct::ExternalObjectStruct;
use super::hybrid_base_spec::HybridBaseSpec;
use super::hybrid_child_spec::HybridChildSpec;
use super::hybrid_some_external_object_spec::HybridSomeExternalObjectSpec;
use super::hybrid_test_view_spec::HybridTestViewSpec;
use super::js_style_struct::JsStyleStruct;
use super::map_wrapper::MapWrapper;
use super::named_variant::NamedVariant;
use super::nitro_buffer::NitroBuffer;
use super::old_enum::OldEnum;
use super::optional_callback::OptionalCallback;
use super::optional_wrapper::OptionalWrapper;
use super::partial_person::PartialPerson;
use super::person::Person;
use super::powertrain::Powertrain;
use super::string_or_external::StringOrExternal;
use super::variant____string::Variant____String;
use super::variant_bool_f64::Variant_bool_f64;
use super::variant_bool_old_enum::Variant_bool_OldEnum;
use super::variant_bool_vec_f64__vec_string__string_f64::Variant_bool_Vec_f64__Vec_String__String_f64;
use super::variant_bool_weird_numbers_enum::Variant_bool_WeirdNumbersEnum;
use super::variant_box_dyn_hybrid_base_spec__optional_wrapper::Variant_Box_dyn_HybridBaseSpec__OptionalWrapper;
use super::variant_box_dyn_hybrid_test_object_rust_spec__person::Variant_Box_dyn_HybridTestObjectRustSpec__Person;
use super::variant_car_person::Variant_Car_Person;
use super::variant_string_f64::Variant_String_f64;
use super::weird_numbers_enum::WeirdNumbersEnum;
use super::wrapped_js_struct::WrappedJsStruct;
use crate::*;
use std::collections::HashMap;

/// Implement this trait to create a Rust-backed HybridObject for `TestObjectRust`.
///
/// After implementing, provide a factory function for registration:
/// ```rust
/// #[unsafe(no_mangle)]
/// pub extern "C" fn create_HybridTestObjectRustSpec() -> *mut std::ffi::c_void {
///     let obj: Box<dyn HybridTestObjectRustSpec> = Box::new(MyTestObjectRust::new());
///     Box::into_raw(Box::new(obj)) as *mut std::ffi::c_void
/// }
/// ```
///
/// Note: The factory returns a `Box<Box<dyn HybridTestObjectRustSpec>>` (double-boxed)
/// because the C++ bridge stores it as an opaque `void*` pointing to the trait object.
///
/// All methods take `&self` (shared reference) because the C++ bridge may call
/// methods concurrently from multiple threads. Use interior mutability
/// (`Mutex`, `RwLock`, `AtomicXxx`, etc.) for any mutable state.
pub trait HybridTestObjectRustSpec: Send + Sync {
    // Properties
    fn this_object(&self) -> Box<dyn HybridTestObjectRustSpec>;
    fn optional_hybrid(&self) -> Option<Box<dyn HybridTestObjectRustSpec>>;
    fn set_optional_hybrid(&self, value: Option<Box<dyn HybridTestObjectRustSpec>>);
    fn number_value(&self) -> f64;
    fn set_number_value(&self, value: f64);
    fn bool_value(&self) -> bool;
    fn set_bool_value(&self, value: bool);
    fn string_value(&self) -> String;
    fn set_string_value(&self, value: String);
    fn int64_value(&self) -> i64;
    fn set_int64_value(&self, value: i64);
    fn uint64_value(&self) -> u64;
    fn set_uint64_value(&self, value: u64);
    fn null_value(&self) -> ();
    fn set_null_value(&self, value: ());
    fn optional_string(&self) -> Option<String>;
    fn set_optional_string(&self, value: Option<String>);
    fn string_or_undefined(&self) -> Option<String>;
    fn set_string_or_undefined(&self, value: Option<String>);
    fn string_or_null(&self) -> Variant____String;
    fn set_string_or_null(&self, value: Variant____String);
    fn optional_array(&self) -> Option<Vec<String>>;
    fn set_optional_array(&self, value: Option<Vec<String>>);
    fn optional_enum(&self) -> Option<Powertrain>;
    fn set_optional_enum(&self, value: Option<Powertrain>);
    fn optional_old_enum(&self) -> Option<OldEnum>;
    fn set_optional_old_enum(&self, value: Option<OldEnum>);
    fn optional_callback(&self) -> Option<Box<dyn Fn(f64) + Send + Sync>>;
    fn set_optional_callback(&self, value: Option<Box<dyn Fn(f64) + Send + Sync>>);
    fn some_variant(&self) -> Variant_String_f64;
    fn set_some_variant(&self, value: Variant_String_f64);

    // Methods
    fn new_test_object(&self) -> Result<Box<dyn HybridTestObjectRustSpec>, String>;
    fn get_variant_hybrid(
        &self,
        variant: Variant_Box_dyn_HybridTestObjectRustSpec__Person,
    ) -> Result<Variant_Box_dyn_HybridTestObjectRustSpec__Person, String>;
    fn simple_func(&self) -> Result<(), String>;
    fn add_numbers(&self, a: f64, b: f64) -> Result<f64, String>;
    fn add_strings(&self, a: String, b: String) -> Result<String, String>;
    fn multiple_arguments(&self, num: f64, str: String, boo: bool) -> Result<(), String>;
    fn bounce_null(&self, value: ()) -> Result<(), String>;
    fn bounce_strings(&self, array: Vec<String>) -> Result<Vec<String>, String>;
    fn bounce_numbers(&self, array: Vec<f64>) -> Result<Vec<f64>, String>;
    fn bounce_structs(&self, array: Vec<Person>) -> Result<Vec<Person>, String>;
    fn bounce_partial_struct(&self, person: PartialPerson) -> Result<PartialPerson, String>;
    fn sum_up_all_passengers(&self, cars: Vec<Car>) -> Result<String, String>;
    fn bounce_enums(&self, array: Vec<Powertrain>) -> Result<Vec<Powertrain>, String>;
    fn complex_enum_callback(
        &self,
        array: Vec<Powertrain>,
        callback: Box<dyn Fn(Vec<Powertrain>) + Send + Sync>,
    ) -> Result<(), String>;
    fn bounce_hybrid_objects(
        &self,
        array: Vec<Box<dyn HybridChildSpec>>,
    ) -> Result<Vec<Box<dyn HybridChildSpec>>, String>;
    fn bounce_functions(
        &self,
        functions: Vec<Box<dyn Fn() + Send + Sync>>,
    ) -> Result<Vec<Box<dyn Fn() + Send + Sync>>, String>;
    fn bounce_maps(&self, maps: Vec<AnyMap>) -> Result<Vec<AnyMap>, String>;
    fn bounce_promises(&self, promises: Vec<f64>) -> Result<Vec<f64>, String>;
    fn bounce_array_buffers(
        &self,
        array_buffers: Vec<NitroBuffer>,
    ) -> Result<Vec<NitroBuffer>, String>;
    fn create_map(&self) -> Result<AnyMap, String>;
    fn map_roundtrip(&self, map: AnyMap) -> Result<AnyMap, String>;
    fn get_map_keys(&self, map: AnyMap) -> Result<Vec<String>, String>;
    fn merge_maps(&self, a: AnyMap, b: AnyMap) -> Result<AnyMap, String>;
    fn copy_any_map(&self, map: AnyMap) -> Result<AnyMap, String>;
    fn bounce_map(
        &self,
        map: HashMap<String, Variant_bool_f64>,
    ) -> Result<HashMap<String, Variant_bool_f64>, String>;
    fn bounce_simple_map(&self, map: HashMap<String, f64>) -> Result<HashMap<String, f64>, String>;
    fn extract_map(&self, map_wrapper: MapWrapper) -> Result<HashMap<String, String>, String>;
    fn func_that_throws(&self) -> Result<f64, String>;
    fn func_that_throws_before_promise(&self) -> Result<(), String>;
    fn throw_error(&self, error: String) -> Result<(), String>;
    fn try_optional_params(
        &self,
        num: f64,
        boo: bool,
        str: Option<String>,
    ) -> Result<String, String>;
    fn try_middle_param(&self, num: f64, boo: Option<bool>, str: String) -> Result<String, String>;
    fn try_optional_enum(&self, value: Option<Powertrain>) -> Result<Option<Powertrain>, String>;
    fn try_trailing_optional(
        &self,
        num: f64,
        str: String,
        boo: Option<bool>,
    ) -> Result<bool, String>;
    fn add1_hour(&self, date: f64) -> Result<f64, String>;
    fn current_date(&self) -> Result<f64, String>;
    fn calculate_fibonacci_sync(&self, value: f64) -> Result<i64, String>;
    fn calculate_fibonacci_async(&self, value: f64) -> Result<i64, String>;
    fn wait(&self, seconds: f64) -> Result<(), String>;
    fn promise_throws(&self) -> Result<(), String>;
    fn promise_returns_instantly(&self) -> Result<f64, String>;
    fn promise_returns_instantly_async(&self) -> Result<f64, String>;
    fn promise_that_resolves_void_instantly(&self) -> Result<(), String>;
    fn promise_that_resolves_to_undefined(&self) -> Result<Option<f64>, String>;
    fn await_and_get_promise(&self, promise: f64) -> Result<f64, String>;
    fn await_and_get_complex_promise(&self, promise: Car) -> Result<Car, String>;
    fn await_promise(&self, promise: ()) -> Result<(), String>;
    fn call_callback(&self, callback: Box<dyn Fn() + Send + Sync>) -> Result<(), String>;
    fn call_callback_that_returns_promise_void(
        &self,
        callback: Box<dyn Fn() + Send + Sync>,
    ) -> Result<(), String>;
    fn call_all(
        &self,
        first: Box<dyn Fn() + Send + Sync>,
        second: Box<dyn Fn() + Send + Sync>,
        third: Box<dyn Fn() + Send + Sync>,
    ) -> Result<(), String>;
    fn call_with_optional(
        &self,
        value: Option<f64>,
        callback: Box<dyn Fn(Option<f64>) + Send + Sync>,
    ) -> Result<(), String>;
    fn call_sum_up_n_times(
        &self,
        callback: Box<dyn Fn() -> f64 + Send + Sync>,
        n: f64,
    ) -> Result<f64, String>;
    fn callback_async_promise(
        &self,
        callback: Box<dyn Fn() -> f64 + Send + Sync>,
    ) -> Result<f64, String>;
    fn callback_async_promise_buffer(
        &self,
        callback: Box<dyn Fn() -> NitroBuffer + Send + Sync>,
    ) -> Result<NitroBuffer, String>;
    fn get_complex_callback(&self) -> Result<Box<dyn Fn(f64) + Send + Sync>, String>;
    fn two_optional_callbacks(
        &self,
        value: f64,
        first: Option<Box<dyn Fn(f64) + Send + Sync>>,
        second: Option<Box<dyn Fn(String) + Send + Sync>>,
    ) -> Result<(), String>;
    fn error_callback(&self, on_error: Box<dyn Fn(String) + Send + Sync>) -> Result<(), String>;
    fn create_native_callback(
        &self,
        wrapping_js_callback: Box<dyn Fn(f64) + Send + Sync>,
    ) -> Result<Box<dyn Fn(f64) + Send + Sync>, String>;
    fn get_value_from_js_callback_and_wait(
        &self,
        get_value: Box<dyn Fn() -> f64 + Send + Sync>,
    ) -> Result<f64, String>;
    fn get_value_from_js_callback(
        &self,
        callback: Box<dyn Fn() -> String + Send + Sync>,
        and_then_call: Box<dyn Fn(String) + Send + Sync>,
    ) -> Result<(), String>;
    fn get_car(&self) -> Result<Car, String>;
    fn is_car_electric(&self, car: Car) -> Result<bool, String>;
    fn get_driver(&self, car: Car) -> Result<Option<Person>, String>;
    fn bounce_car(&self, car: Car) -> Result<Car, String>;
    fn js_style_object_as_parameters(&self, params: JsStyleStruct) -> Result<(), String>;
    fn bounce_wrapped_js_style_struct(
        &self,
        value: WrappedJsStruct,
    ) -> Result<WrappedJsStruct, String>;
    fn bounce_optional_wrapper(&self, wrapper: OptionalWrapper) -> Result<OptionalWrapper, String>;
    fn bounce_optional_callback(&self, value: OptionalCallback)
        -> Result<OptionalCallback, String>;
    fn create_array_buffer(&self) -> Result<NitroBuffer, String>;
    fn create_array_buffer_from_native_buffer(&self, copy: bool) -> Result<NitroBuffer, String>;
    fn copy_buffer(&self, buffer: NitroBuffer) -> Result<NitroBuffer, String>;
    fn get_buffer_last_item(&self, buffer: NitroBuffer) -> Result<f64, String>;
    fn set_all_values_to(&self, buffer: NitroBuffer, value: f64) -> Result<(), String>;
    fn create_array_buffer_async(&self) -> Result<NitroBuffer, String>;
    fn bounce_array_buffer(&self, buffer: NitroBuffer) -> Result<NitroBuffer, String>;
    fn pass_variant(
        &self,
        either: Variant_bool_Vec_f64__Vec_String__String_f64,
    ) -> Result<Variant_String_f64, String>;
    fn get_variant_enum(
        &self,
        variant: Variant_bool_OldEnum,
    ) -> Result<Variant_bool_OldEnum, String>;
    fn get_variant_weird_numbers_enum(
        &self,
        variant: Variant_bool_WeirdNumbersEnum,
    ) -> Result<Variant_bool_WeirdNumbersEnum, String>;
    fn get_variant_objects(
        &self,
        variant: Variant_Car_Person,
    ) -> Result<Variant_Car_Person, String>;
    fn pass_named_variant(&self, variant: NamedVariant) -> Result<NamedVariant, String>;
    fn pass_all_empty_object_variant(
        &self,
        variant: Variant_Box_dyn_HybridBaseSpec__OptionalWrapper,
    ) -> Result<Variant_Box_dyn_HybridBaseSpec__OptionalWrapper, String>;
    fn bounce_complex_variant(&self, variant: CoreTypesVariant)
        -> Result<CoreTypesVariant, String>;
    fn create_child(&self) -> Result<Box<dyn HybridChildSpec>, String>;
    fn create_base(&self) -> Result<Box<dyn HybridBaseSpec>, String>;
    fn create_base_actual_child(&self) -> Result<Box<dyn HybridBaseSpec>, String>;
    fn bounce_child(
        &self,
        child: Box<dyn HybridChildSpec>,
    ) -> Result<Box<dyn HybridChildSpec>, String>;
    fn bounce_base(&self, base: Box<dyn HybridBaseSpec>)
        -> Result<Box<dyn HybridBaseSpec>, String>;
    fn bounce_child_base(
        &self,
        child: Box<dyn HybridChildSpec>,
    ) -> Result<Box<dyn HybridBaseSpec>, String>;
    fn cast_base(&self, base: Box<dyn HybridBaseSpec>) -> Result<Box<dyn HybridChildSpec>, String>;
    fn callback_sync(&self, callback: Box<dyn Fn() -> f64 + Send + Sync>) -> Result<f64, String>;
    fn get_is_view_blue(&self, view: Box<dyn HybridTestViewSpec>) -> Result<bool, String>;
    fn bounce_external_hybrid(
        &self,
        external_object: Box<dyn HybridSomeExternalObjectSpec>,
    ) -> Result<Box<dyn HybridSomeExternalObjectSpec>, String>;
    fn create_internal_object(&self) -> Result<Box<dyn HybridSomeExternalObjectSpec>, String>;
    fn bounce_external_struct(
        &self,
        external_struct: ExternalObjectStruct,
    ) -> Result<ExternalObjectStruct, String>;
    fn bounce_external_variant(
        &self,
        variant: StringOrExternal,
    ) -> Result<StringOrExternal, String>;
    fn create_external_variant_from_func(
        &self,
        factory: Box<dyn Fn() -> Box<dyn HybridSomeExternalObjectSpec> + Send + Sync>,
    ) -> Result<Box<dyn HybridSomeExternalObjectSpec>, String>;

    /// Return the size of any external heap allocations, in bytes.
    /// This is used to inform the JavaScript GC about native memory pressure.
    fn memory_size(&self) -> usize {
        0
    }
}

// FFI shims for C++ bridge

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_this_object(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            Box::into_raw(Box::new(obj.this_object())) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_hybrid(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __opt: __Opt = match obj.optional_hybrid() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: Box::into_raw(Box::new(__v)) as *mut std::ffi::c_void,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_hybrid(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_hybrid({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(*Box::from_raw(
                        __s.value as *mut Box<dyn HybridTestObjectRustSpec>,
                    ))
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_number_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.number_value()
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_number_value(
    ptr: *mut std::ffi::c_void,
    value: f64,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_number_value(value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_bool_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_bool {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.bool_value()
        })) {
            Ok(__result) => __FfiResult_bool {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_bool {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_bool_value(
    ptr: *mut std::ffi::c_void,
    value: bool,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_bool_value(value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_string_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_cstr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                let __s = obj.string_value().replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            }
        })) {
            Ok(__result) => __FfiResult_cstr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_cstr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_string_value(
    ptr: *mut std::ffi::c_void,
    value: *const std::ffi::c_char,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_string_value(
                std::ffi::CStr::from_ptr(value)
                    .to_string_lossy()
                    .into_owned(),
            );
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_int64_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_i64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.int64_value()
        })) {
            Ok(__result) => __FfiResult_i64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_i64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_int64_value(
    ptr: *mut std::ffi::c_void,
    value: i64,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_int64_value(value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_uint64_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_u64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.uint64_value()
        })) {
            Ok(__result) => __FfiResult_u64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_u64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_uint64_value(
    ptr: *mut std::ffi::c_void,
    value: u64,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_uint64_value(value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_null_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.null_value()
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_null_value(
    ptr: *mut std::ffi::c_void,
    value: (),
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_null_value(value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_string(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *const std::ffi::c_char,
                }
                let __opt: __Opt = match obj.optional_string() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: {
                            let __s = __v.replace('\0', "");
                            std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                        },
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_string(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_string({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *const std::ffi::c_char,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(
                        std::ffi::CStr::from_ptr(__s.value)
                            .to_string_lossy()
                            .into_owned(),
                    )
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_string_or_undefined(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *const std::ffi::c_char,
                }
                let __opt: __Opt = match obj.string_or_undefined() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: {
                            let __s = __v.replace('\0', "");
                            std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                        },
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_string_or_undefined(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_string_or_undefined({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *const std::ffi::c_char,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(
                        std::ffi::CStr::from_ptr(__s.value)
                            .to_string_lossy()
                            .into_owned(),
                    )
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_string_or_null(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            Box::into_raw(Box::new(obj.string_or_null())) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_string_or_null(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_string_or_null(*Box::from_raw(value as *mut Variant____String));
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_array(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __opt: __Opt = match obj.optional_array() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: Box::into_raw(Box::new(__v)) as *mut std::ffi::c_void,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_array(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_array({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(*Box::from_raw(__s.value as *mut Vec<String>))
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_enum(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __opt: __Opt = match obj.optional_enum() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: __v as i32,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_enum(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_enum({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(Powertrain::from_i32(__s.value).unwrap_or_else(|| {
                        panic!("[Nitro] Invalid Powertrain discriminant: {}", __s.value)
                    }))
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_old_enum(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __opt: __Opt = match obj.optional_old_enum() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: __v as i32,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_old_enum(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_old_enum({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(OldEnum::from_i32(__s.value).unwrap_or_else(|| {
                        panic!("[Nitro] Invalid OldEnum discriminant: {}", __s.value)
                    }))
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_callback(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __opt: __Opt = match obj.optional_callback() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: Box::into_raw(Box::new(__v)) as *mut std::ffi::c_void,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_callback(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_callback({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some({
                        let __wrapper = Box::from_raw(
                            __s.value as *mut super::func_void_double::Func_void_double,
                        );
                        let __cb: Box<dyn Fn(f64) + Send + Sync> =
                            Box::new(move |__p0: f64| __wrapper.call(__p0));
                        __cb
                    })
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_some_variant(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            Box::into_raw(Box::new(obj.some_variant())) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_some_variant(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_some_variant(*Box::from_raw(value as *mut Variant_String_f64));
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_new_test_object(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.new_test_object()
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_variant_hybrid(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant =
                *Box::from_raw(variant as *mut Variant_Box_dyn_HybridTestObjectRustSpec__Person);
            obj.get_variant_hybrid(__variant)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_simple_func(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.simple_func()
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_add_numbers(
    ptr: *mut std::ffi::c_void,
    a: f64,
    b: f64,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.add_numbers(a, b)
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_add_strings(
    ptr: *mut std::ffi::c_void,
    a: *const std::ffi::c_char,
    b: *const std::ffi::c_char,
) -> __FfiResult_cstr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __a = std::ffi::CStr::from_ptr(a).to_string_lossy().into_owned();
            let __b = std::ffi::CStr::from_ptr(b).to_string_lossy().into_owned();
            obj.add_strings(__a, __b).map(|__value| {
                let __s = __value.replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            })
        })) {
            Ok(Ok(__value)) => __FfiResult_cstr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_cstr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_cstr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_multiple_arguments(
    ptr: *mut std::ffi::c_void,
    num: f64,
    str: *const std::ffi::c_char,
    boo: bool,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __str = std::ffi::CStr::from_ptr(str).to_string_lossy().into_owned();
            obj.multiple_arguments(num, __str, boo)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_null(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.bounce_null()
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_strings(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<String>);
            obj.bounce_strings(__array)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_numbers(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<f64>);
            obj.bounce_numbers(__array)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_structs(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<Person>);
            obj.bounce_structs(__array)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_partial_struct(
    ptr: *mut std::ffi::c_void,
    person: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __person = *Box::from_raw(person as *mut PartialPerson);
            obj.bounce_partial_struct(__person)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_sum_up_all_passengers(
    ptr: *mut std::ffi::c_void,
    cars: *mut std::ffi::c_void,
) -> __FfiResult_cstr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __cars = *Box::from_raw(cars as *mut Vec<Car>);
            obj.sum_up_all_passengers(__cars).map(|__value| {
                let __s = __value.replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            })
        })) {
            Ok(Ok(__value)) => __FfiResult_cstr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_cstr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_cstr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_enums(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<Powertrain>);
            obj.bounce_enums(__array)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_complex_enum_callback(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<Powertrain>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::func_void_std__vector_powertrain_::Func_void_std__vector_Powertrain_);
                let __cb: Box<dyn Fn(Vec<Powertrain>) + Send + Sync> =
                    Box::new(move |__p0: Vec<Powertrain>| __wrapper.call(__p0));
                __cb
            };
            obj.complex_enum_callback(__array, __callback)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_hybrid_objects(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<Box<dyn HybridChildSpec>>);
            obj.bounce_hybrid_objects(__array)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_functions(
    ptr: *mut std::ffi::c_void,
    functions: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __functions = *Box::from_raw(functions as *mut Vec<Box<dyn Fn() + Send + Sync>>);
            obj.bounce_functions(__functions)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_maps(
    ptr: *mut std::ffi::c_void,
    maps: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __maps = *Box::from_raw(maps as *mut Vec<AnyMap>);
            obj.bounce_maps(__maps)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_promises(
    ptr: *mut std::ffi::c_void,
    promises: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __promises = *Box::from_raw(promises as *mut Vec<f64>);
            obj.bounce_promises(__promises)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_array_buffers(
    ptr: *mut std::ffi::c_void,
    array_buffers: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array_buffers = *Box::from_raw(array_buffers as *mut Vec<NitroBuffer>);
            obj.bounce_array_buffers(__array_buffers)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_map(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.create_map().map(|__value| __value.as_raw())
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_map_roundtrip(
    ptr: *mut std::ffi::c_void,
    map: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map = AnyMap::from_raw(map);
            obj.map_roundtrip(__map).map(|__value| __value.as_raw())
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_map_keys(
    ptr: *mut std::ffi::c_void,
    map: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map = AnyMap::from_raw(map);
            obj.get_map_keys(__map)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_merge_maps(
    ptr: *mut std::ffi::c_void,
    a: *mut std::ffi::c_void,
    b: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __a = AnyMap::from_raw(a);
            let __b = AnyMap::from_raw(b);
            obj.merge_maps(__a, __b).map(|__value| __value.as_raw())
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_copy_any_map(
    ptr: *mut std::ffi::c_void,
    map: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map = AnyMap::from_raw(map);
            obj.copy_any_map(__map).map(|__value| __value.as_raw())
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_map(
    ptr: *mut std::ffi::c_void,
    map: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map = *Box::from_raw(map as *mut HashMap<String, Variant_bool_f64>);
            obj.bounce_map(__map)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_simple_map(
    ptr: *mut std::ffi::c_void,
    map: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map = *Box::from_raw(map as *mut HashMap<String, f64>);
            obj.bounce_simple_map(__map)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_extract_map(
    ptr: *mut std::ffi::c_void,
    map_wrapper: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map_wrapper = *Box::from_raw(map_wrapper as *mut MapWrapper);
            obj.extract_map(__map_wrapper)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_func_that_throws(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.func_that_throws()
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_func_that_throws_before_promise(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.func_that_throws_before_promise()
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_throw_error(
    ptr: *mut std::ffi::c_void,
    error: *const std::ffi::c_char,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __error = std::ffi::CStr::from_ptr(error)
                .to_string_lossy()
                .into_owned();
            obj.throw_error(__error)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_try_optional_params(
    ptr: *mut std::ffi::c_void,
    num: f64,
    boo: bool,
    str: *mut std::ffi::c_void,
) -> __FfiResult_cstr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __str = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *const std::ffi::c_char,
                }
                let __s = *Box::from_raw(str as *mut __Opt);
                if __s.has_value != 0 {
                    Some(
                        std::ffi::CStr::from_ptr(__s.value)
                            .to_string_lossy()
                            .into_owned(),
                    )
                } else {
                    None
                }
            };
            obj.try_optional_params(num, boo, __str).map(|__value| {
                let __s = __value.replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            })
        })) {
            Ok(Ok(__value)) => __FfiResult_cstr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_cstr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_cstr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_try_middle_param(
    ptr: *mut std::ffi::c_void,
    num: f64,
    boo: *mut std::ffi::c_void,
    str: *const std::ffi::c_char,
) -> __FfiResult_cstr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __boo = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: bool,
                }
                let __s = *Box::from_raw(boo as *mut __Opt);
                if __s.has_value != 0 {
                    Some(__s.value)
                } else {
                    None
                }
            };
            let __str = std::ffi::CStr::from_ptr(str).to_string_lossy().into_owned();
            obj.try_middle_param(num, __boo, __str).map(|__value| {
                let __s = __value.replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            })
        })) {
            Ok(Ok(__value)) => __FfiResult_cstr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_cstr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_cstr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_try_optional_enum(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __value = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(Powertrain::from_i32(__s.value).unwrap_or_else(|| {
                        panic!("[Nitro] Invalid Powertrain discriminant: {}", __s.value)
                    }))
                } else {
                    None
                }
            };
            obj.try_optional_enum(__value).map(|__value| { #[repr(C)] struct __Opt { has_value: u8, value: i32 } let __opt: __Opt = match __value { Some(__v) => __Opt { has_value: 1, value: __v as i32 }, None => __Opt { has_value: 0, value: unsafe { std::mem::zeroed() } /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */ } }; Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void })
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_try_trailing_optional(
    ptr: *mut std::ffi::c_void,
    num: f64,
    str: *const std::ffi::c_char,
    boo: *mut std::ffi::c_void,
) -> __FfiResult_bool {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __str = std::ffi::CStr::from_ptr(str).to_string_lossy().into_owned();
            let __boo = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: bool,
                }
                let __s = *Box::from_raw(boo as *mut __Opt);
                if __s.has_value != 0 {
                    Some(__s.value)
                } else {
                    None
                }
            };
            obj.try_trailing_optional(num, __str, __boo)
        })) {
            Ok(Ok(__value)) => __FfiResult_bool {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_bool {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_bool {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_add1_hour(
    ptr: *mut std::ffi::c_void,
    date: f64,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __date = date;
            obj.add1_hour(__date).map(|__value| __value)
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_current_date(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.current_date().map(|__value| __value)
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_calculate_fibonacci_sync(
    ptr: *mut std::ffi::c_void,
    value: f64,
) -> __FfiResult_i64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.calculate_fibonacci_sync(value)
        })) {
            Ok(Ok(__value)) => __FfiResult_i64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_i64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_i64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_calculate_fibonacci_async(
    ptr: *mut std::ffi::c_void,
    value: f64,
) -> __FfiResult_i64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.calculate_fibonacci_async(value)
        })) {
            Ok(Ok(__value)) => __FfiResult_i64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_i64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_i64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_wait(
    ptr: *mut std::ffi::c_void,
    seconds: f64,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.wait(seconds)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_promise_throws(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.promise_throws()
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_promise_returns_instantly(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.promise_returns_instantly()
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_promise_returns_instantly_async(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.promise_returns_instantly_async()
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_promise_that_resolves_void_instantly(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.promise_that_resolves_void_instantly()
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_promise_that_resolves_to_undefined(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.promise_that_resolves_to_undefined().map(|__value| { #[repr(C)] struct __Opt { has_value: u8, value: f64 } let __opt: __Opt = match __value { Some(__v) => __Opt { has_value: 1, value: __v }, None => __Opt { has_value: 0, value: unsafe { std::mem::zeroed() } /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */ } }; Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void })
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_await_and_get_promise(
    ptr: *mut std::ffi::c_void,
    promise: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __promise = *Box::from_raw(promise as *mut f64);
            obj.await_and_get_promise(__promise)
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_await_and_get_complex_promise(
    ptr: *mut std::ffi::c_void,
    promise: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __promise = *Box::from_raw(promise as *mut Car);
            obj.await_and_get_complex_promise(__promise)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_await_promise(
    ptr: *mut std::ffi::c_void,
    promise: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __promise = *Box::from_raw(promise as *mut ());
            obj.await_promise(__promise)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_call_callback(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::func_void::Func_void);
                let __cb: Box<dyn Fn() + Send + Sync> = Box::new(move || __wrapper.call());
                __cb
            };
            obj.call_callback(__callback)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_call_callback_that_returns_promise_void(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::func_std__shared_ptr_promise_std__shared_ptr_promise_void____::Func_std__shared_ptr_Promise_std__shared_ptr_Promise_void____);
                let __cb: Box<dyn Fn() + Send + Sync> = Box::new(move || __wrapper.call());
                __cb
            };
            obj.call_callback_that_returns_promise_void(__callback)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_call_all(
    ptr: *mut std::ffi::c_void,
    first: *mut std::ffi::c_void,
    second: *mut std::ffi::c_void,
    third: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __first = {
                let __wrapper = Box::from_raw(first as *mut super::func_void::Func_void);
                let __cb: Box<dyn Fn() + Send + Sync> = Box::new(move || __wrapper.call());
                __cb
            };
            let __second = {
                let __wrapper = Box::from_raw(second as *mut super::func_void::Func_void);
                let __cb: Box<dyn Fn() + Send + Sync> = Box::new(move || __wrapper.call());
                __cb
            };
            let __third = {
                let __wrapper = Box::from_raw(third as *mut super::func_void::Func_void);
                let __cb: Box<dyn Fn() + Send + Sync> = Box::new(move || __wrapper.call());
                __cb
            };
            obj.call_all(__first, __second, __third)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_call_with_optional(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __value = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: f64,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(__s.value)
                } else {
                    None
                }
            };
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::func_void_std__optional_double_::Func_void_std__optional_double_);
                let __cb: Box<dyn Fn(Option<f64>) + Send + Sync> =
                    Box::new(move |__p0: Option<f64>| __wrapper.call(__p0));
                __cb
            };
            obj.call_with_optional(__value, __callback)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_call_sum_up_n_times(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
    n: f64,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::func_std__shared_ptr_promise_double__::Func_std__shared_ptr_Promise_double__);
                let __cb: Box<dyn Fn() -> f64 + Send + Sync> =
                    Box::new(move || -> f64 { __wrapper.call() });
                __cb
            };
            obj.call_sum_up_n_times(__callback, n)
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_callback_async_promise(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::func_std__shared_ptr_promise_std__shared_ptr_promise_double____::Func_std__shared_ptr_Promise_std__shared_ptr_Promise_double____);
                let __cb: Box<dyn Fn() -> f64 + Send + Sync> =
                    Box::new(move || -> f64 { __wrapper.call() });
                __cb
            };
            obj.callback_async_promise(__callback)
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_callback_async_promise_buffer(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::func_std__shared_ptr_promise_std__shared_ptr_promise_std__shared_ptr_array_buffer_____::Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer_____);
                let __cb: Box<dyn Fn() -> NitroBuffer + Send + Sync> =
                    Box::new(move || -> NitroBuffer { __wrapper.call() });
                __cb
            };
            obj.callback_async_promise_buffer(__callback)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_complex_callback(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.get_complex_callback()
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_two_optional_callbacks(
    ptr: *mut std::ffi::c_void,
    value: f64,
    first: *mut std::ffi::c_void,
    second: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __first = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __s = *Box::from_raw(first as *mut __Opt);
                if __s.has_value != 0 {
                    Some({
                        let __wrapper = Box::from_raw(
                            __s.value as *mut super::func_void_double::Func_void_double,
                        );
                        let __cb: Box<dyn Fn(f64) + Send + Sync> =
                            Box::new(move |__p0: f64| __wrapper.call(__p0));
                        __cb
                    })
                } else {
                    None
                }
            };
            let __second = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __s = *Box::from_raw(second as *mut __Opt);
                if __s.has_value != 0 {
                    Some({
                        let __wrapper = Box::from_raw(
                            __s.value as *mut super::func_void_std__string::Func_void_std__string,
                        );
                        let __cb: Box<dyn Fn(String) + Send + Sync> =
                            Box::new(move |__p0: String| __wrapper.call(__p0));
                        __cb
                    })
                } else {
                    None
                }
            };
            obj.two_optional_callbacks(value, __first, __second)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_error_callback(
    ptr: *mut std::ffi::c_void,
    on_error: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __on_error = {
                let __wrapper = Box::from_raw(
                    on_error
                        as *mut super::func_void_std__exception_ptr::Func_void_std__exception_ptr,
                );
                let __cb: Box<dyn Fn(String) + Send + Sync> =
                    Box::new(move |__p0: String| __wrapper.call(__p0));
                __cb
            };
            obj.error_callback(__on_error)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_native_callback(
    ptr: *mut std::ffi::c_void,
    wrapping_js_callback: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __wrapping_js_callback = {
                let __wrapper = Box::from_raw(
                    wrapping_js_callback as *mut super::func_void_double::Func_void_double,
                );
                let __cb: Box<dyn Fn(f64) + Send + Sync> =
                    Box::new(move |__p0: f64| __wrapper.call(__p0));
                __cb
            };
            obj.create_native_callback(__wrapping_js_callback)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_value_from_js_callback_and_wait(
    ptr: *mut std::ffi::c_void,
    get_value: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __get_value = {
                let __wrapper = Box::from_raw(get_value as *mut super::func_std__shared_ptr_promise_double__::Func_std__shared_ptr_Promise_double__);
                let __cb: Box<dyn Fn() -> f64 + Send + Sync> =
                    Box::new(move || -> f64 { __wrapper.call() });
                __cb
            };
            obj.get_value_from_js_callback_and_wait(__get_value)
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_value_from_js_callback(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
    and_then_call: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::func_std__shared_ptr_promise_std__string__::Func_std__shared_ptr_Promise_std__string__);
                let __cb: Box<dyn Fn() -> String + Send + Sync> =
                    Box::new(move || -> String { __wrapper.call() });
                __cb
            };
            let __and_then_call = {
                let __wrapper = Box::from_raw(
                    and_then_call as *mut super::func_void_std__string::Func_void_std__string,
                );
                let __cb: Box<dyn Fn(String) + Send + Sync> =
                    Box::new(move |__p0: String| __wrapper.call(__p0));
                __cb
            };
            obj.get_value_from_js_callback(__callback, __and_then_call)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_car(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.get_car()
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_is_car_electric(
    ptr: *mut std::ffi::c_void,
    car: *mut std::ffi::c_void,
) -> __FfiResult_bool {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __car = *Box::from_raw(car as *mut Car);
            obj.is_car_electric(__car)
        })) {
            Ok(Ok(__value)) => __FfiResult_bool {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_bool {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_bool {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_driver(
    ptr: *mut std::ffi::c_void,
    car: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __car = *Box::from_raw(car as *mut Car);
            obj.get_driver(__car).map(|__value| { #[repr(C)] struct __Opt { has_value: u8, value: *mut std::ffi::c_void } let __opt: __Opt = match __value { Some(__v) => __Opt { has_value: 1, value: Box::into_raw(Box::new(__v)) as *mut std::ffi::c_void }, None => __Opt { has_value: 0, value: unsafe { std::mem::zeroed() } /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */ } }; Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void })
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_car(
    ptr: *mut std::ffi::c_void,
    car: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __car = *Box::from_raw(car as *mut Car);
            obj.bounce_car(__car)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_js_style_object_as_parameters(
    ptr: *mut std::ffi::c_void,
    params: *mut std::ffi::c_void,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __params = *Box::from_raw(params as *mut JsStyleStruct);
            obj.js_style_object_as_parameters(__params)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_wrapped_js_style_struct(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __value = *Box::from_raw(value as *mut WrappedJsStruct);
            obj.bounce_wrapped_js_style_struct(__value)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_optional_wrapper(
    ptr: *mut std::ffi::c_void,
    wrapper: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __wrapper = *Box::from_raw(wrapper as *mut OptionalWrapper);
            obj.bounce_optional_wrapper(__wrapper)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_optional_callback(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __value = *Box::from_raw(value as *mut OptionalCallback);
            obj.bounce_optional_callback(__value)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_array_buffer(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.create_array_buffer()
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_array_buffer_from_native_buffer(
    ptr: *mut std::ffi::c_void,
    copy: bool,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.create_array_buffer_from_native_buffer(copy)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_copy_buffer(
    ptr: *mut std::ffi::c_void,
    buffer: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __buffer = *Box::from_raw(buffer as *mut super::nitro_buffer::NitroBuffer);
            obj.copy_buffer(__buffer)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_buffer_last_item(
    ptr: *mut std::ffi::c_void,
    buffer: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __buffer = *Box::from_raw(buffer as *mut super::nitro_buffer::NitroBuffer);
            obj.get_buffer_last_item(__buffer)
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_all_values_to(
    ptr: *mut std::ffi::c_void,
    buffer: *mut std::ffi::c_void,
    value: f64,
) -> __FfiResult_void {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __buffer = *Box::from_raw(buffer as *mut super::nitro_buffer::NitroBuffer);
            obj.set_all_values_to(__buffer, value)
        })) {
            Ok(Ok(_)) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Ok(Err(__err)) => __FfiResult_void {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_array_buffer_async(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.create_array_buffer_async()
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_array_buffer(
    ptr: *mut std::ffi::c_void,
    buffer: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __buffer = *Box::from_raw(buffer as *mut super::nitro_buffer::NitroBuffer);
            obj.bounce_array_buffer(__buffer)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_pass_variant(
    ptr: *mut std::ffi::c_void,
    either: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __either =
                *Box::from_raw(either as *mut Variant_bool_Vec_f64__Vec_String__String_f64);
            obj.pass_variant(__either)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_variant_enum(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut Variant_bool_OldEnum);
            obj.get_variant_enum(__variant)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_variant_weird_numbers_enum(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut Variant_bool_WeirdNumbersEnum);
            obj.get_variant_weird_numbers_enum(__variant)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_variant_objects(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut Variant_Car_Person);
            obj.get_variant_objects(__variant)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_pass_named_variant(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut NamedVariant);
            obj.pass_named_variant(__variant)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_pass_all_empty_object_variant(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant =
                *Box::from_raw(variant as *mut Variant_Box_dyn_HybridBaseSpec__OptionalWrapper);
            obj.pass_all_empty_object_variant(__variant)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_complex_variant(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut CoreTypesVariant);
            obj.bounce_complex_variant(__variant)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_child(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.create_child()
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_base(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.create_base()
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_base_actual_child(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.create_base_actual_child()
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_child(
    ptr: *mut std::ffi::c_void,
    child: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __child = *Box::from_raw(child as *mut Box<dyn HybridChildSpec>);
            obj.bounce_child(__child)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_base(
    ptr: *mut std::ffi::c_void,
    base: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __base = *Box::from_raw(base as *mut Box<dyn HybridBaseSpec>);
            obj.bounce_base(__base)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_child_base(
    ptr: *mut std::ffi::c_void,
    child: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __child = *Box::from_raw(child as *mut Box<dyn HybridChildSpec>);
            obj.bounce_child_base(__child)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_cast_base(
    ptr: *mut std::ffi::c_void,
    base: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __base = *Box::from_raw(base as *mut Box<dyn HybridBaseSpec>);
            obj.cast_base(__base)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_callback_sync(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::func_double::Func_double);
                let __cb: Box<dyn Fn() -> f64 + Send + Sync> =
                    Box::new(move || -> f64 { __wrapper.call() });
                __cb
            };
            obj.callback_sync(__callback)
        })) {
            Ok(Ok(__value)) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_f64 {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_is_view_blue(
    ptr: *mut std::ffi::c_void,
    view: *mut std::ffi::c_void,
) -> __FfiResult_bool {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __view = *Box::from_raw(view as *mut Box<dyn HybridTestViewSpec>);
            obj.get_is_view_blue(__view)
        })) {
            Ok(Ok(__value)) => __FfiResult_bool {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_bool {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_bool {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_external_hybrid(
    ptr: *mut std::ffi::c_void,
    external_object: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __external_object =
                *Box::from_raw(external_object as *mut Box<dyn HybridSomeExternalObjectSpec>);
            obj.bounce_external_hybrid(__external_object)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_internal_object(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.create_internal_object()
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_external_struct(
    ptr: *mut std::ffi::c_void,
    external_struct: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __external_struct = *Box::from_raw(external_struct as *mut ExternalObjectStruct);
            obj.bounce_external_struct(__external_struct)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_external_variant(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut StringOrExternal);
            obj.bounce_external_variant(__variant)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_external_variant_from_func(
    ptr: *mut std::ffi::c_void,
    factory: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    // NOTE: AssertUnwindSafe is used because UnwindSafe cannot be required on the trait
    // without making it viral across all implementations. If a panic occurs mid-mutation,
    // the object's internal state may be inconsistent on subsequent calls.
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __factory = {
                let __wrapper = Box::from_raw(factory as *mut super::func_std__shared_ptr_margelo__nitro__test__external__hybrid_some_external_object_spec_::Func_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_);
                let __cb: Box<dyn Fn() -> Box<dyn HybridSomeExternalObjectSpec> + Send + Sync> =
                    Box::new(move || -> Box<dyn HybridSomeExternalObjectSpec> { __wrapper.call() });
                __cb
            };
            obj.create_external_variant_from_func(__factory)
                .map(|__value| Box::into_raw(Box::new(__value)) as *mut std::ffi::c_void)
        })) {
            Ok(Ok(__value)) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __value,
            },
            Ok(Err(__err)) => __FfiResult_ptr {
                is_ok: 0,
                error: {
                    let __s = __err.replace('\0', "");
                    std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                },
                value: std::mem::zeroed(),
            },
            // SAFETY: value is intentionally zeroed on error — C++ checks is_ok before reading it.
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: crate::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_memory_size(ptr: *mut std::ffi::c_void) -> usize {
    unsafe {
        let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
        obj.memory_size()
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_destroy(ptr: *mut std::ffi::c_void) {
    unsafe {
        let _ = Box::from_raw(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
    }
}
