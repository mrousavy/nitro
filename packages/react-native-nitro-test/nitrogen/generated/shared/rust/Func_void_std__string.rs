//
// Func_void_std__string.rs
// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
// https://github.com/mrousavy/nitro
// Copyright Â© Marc Rousavy @ Margelo
//
#![allow(
    non_camel_case_types,
    non_snake_case,
    dead_code,
    unused_imports,
    clippy::needless_return,
    clippy::redundant_closure,
    clippy::new_without_default,
    clippy::useless_conversion
)]

use std::ffi;

/// FFI-safe wrapper for callback `Func_void_std__string`.
///
/// Wraps a C function pointer + userdata into a callable Rust struct.
/// The C++ side passes a function pointer and opaque userdata;
/// the Rust side can call it safely through this wrapper.
#[repr(C)]
pub struct Func_void_std__string {
    fn_ptr: unsafe extern "C" fn(*mut std::ffi::c_void, *const std::ffi::c_char),
    userdata: *mut std::ffi::c_void,
    destroy_fn: unsafe extern "C" fn(*mut std::ffi::c_void),
}

// Safety: The C++ side guarantees the function pointer and userdata
// are valid for the lifetime of this struct and are thread-safe.
unsafe impl Send for Func_void_std__string {}
unsafe impl Sync for Func_void_std__string {}

impl Func_void_std__string {
    /// Create a new wrapper from a C function pointer, userdata, and destroy function.
    pub fn new(
        fn_ptr: unsafe extern "C" fn(*mut std::ffi::c_void, *const std::ffi::c_char),
        userdata: *mut ffi::c_void,
        destroy_fn: unsafe extern "C" fn(*mut ffi::c_void),
    ) -> Self {
        Self {
            fn_ptr,
            userdata,
            destroy_fn,
        }
    }

    /// Call the wrapped function.
    pub unsafe fn call(&self, value: String) {
        unsafe {
            (self.fn_ptr)(self.userdata, {
                let __s = value.replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            });
        }
    }
}

impl Drop for Func_void_std__string {
    fn drop(&mut self) {
        unsafe {
            (self.destroy_fn)(self.userdata);
        }
    }
}
