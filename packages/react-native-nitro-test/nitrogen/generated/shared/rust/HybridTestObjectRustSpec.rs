//
// HybridTestObjectRustSpec.rs
// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
// https://github.com/mrousavy/nitro
// Copyright Â© Marc Rousavy @ Margelo
//
#![allow(
    non_camel_case_types,
    non_snake_case,
    dead_code,
    unused_imports,
    clippy::needless_return,
    clippy::redundant_closure,
    clippy::new_without_default,
    clippy::useless_conversion
)]

use super::Car::Car;
use super::CoreTypesVariant::CoreTypesVariant;
use super::ExternalObjectStruct::ExternalObjectStruct;
use super::HybridBaseSpec::HybridBaseSpec;
use super::HybridChildSpec::HybridChildSpec;
use super::HybridSomeExternalObjectSpec::HybridSomeExternalObjectSpec;
use super::HybridTestViewSpec::HybridTestViewSpec;
use super::JsStyleStruct::JsStyleStruct;
use super::MapWrapper::MapWrapper;
use super::NamedVariant::NamedVariant;
use super::NitroBuffer::NitroBuffer;
use super::OldEnum::OldEnum;
use super::OptionalCallback::OptionalCallback;
use super::OptionalWrapper::OptionalWrapper;
use super::PartialPerson::PartialPerson;
use super::Person::Person;
use super::Powertrain::Powertrain;
use super::StringOrExternal::StringOrExternal;
use super::Variant_Box_dyn_HybridBaseSpec__OptionalWrapper::Variant_Box_dyn_HybridBaseSpec__OptionalWrapper;
use super::Variant_Box_dyn_HybridTestObjectRustSpec__Person::Variant_Box_dyn_HybridTestObjectRustSpec__Person;
use super::Variant_Car_Person::Variant_Car_Person;
use super::Variant_String_f64::Variant_String_f64;
use super::Variant____String::Variant____String;
use super::Variant_bool_OldEnum::Variant_bool_OldEnum;
use super::Variant_bool_Vec_f64__Vec_String__String_f64::Variant_bool_Vec_f64__Vec_String__String_f64;
use super::Variant_bool_WeirdNumbersEnum::Variant_bool_WeirdNumbersEnum;
use super::Variant_bool_f64::Variant_bool_f64;
use super::WeirdNumbersEnum::WeirdNumbersEnum;
use super::WrappedJsStruct::WrappedJsStruct;
use std::collections::HashMap;

/// Implement this trait to create a Rust-backed HybridObject for `TestObjectRust`.
///
/// After implementing, provide a factory function for registration:
/// ```rust
/// #[unsafe(no_mangle)]
/// pub extern "C" fn create_HybridTestObjectRustSpec() -> *mut std::ffi::c_void {
///     let obj: Box<dyn HybridTestObjectRustSpec> = Box::new(MyTestObjectRust::new());
///     Box::into_raw(Box::new(obj)) as *mut std::ffi::c_void
/// }
/// ```
///
/// Note: The factory returns a `Box<Box<dyn HybridTestObjectRustSpec>>` (double-boxed)
/// because the C++ bridge stores it as an opaque `void*` pointing to the trait object.
pub trait HybridTestObjectRustSpec: Send + Sync {
    // Properties
    fn get_this_object(&self) -> Box<dyn HybridTestObjectRustSpec>;
    fn get_optional_hybrid(&self) -> Option<Box<dyn HybridTestObjectRustSpec>>;
    fn set_optional_hybrid(&mut self, value: Option<Box<dyn HybridTestObjectRustSpec>>);
    fn get_number_value(&self) -> f64;
    fn set_number_value(&mut self, value: f64);
    fn get_bool_value(&self) -> bool;
    fn set_bool_value(&mut self, value: bool);
    fn get_string_value(&self) -> String;
    fn set_string_value(&mut self, value: String);
    fn get_int64_value(&self) -> i64;
    fn set_int64_value(&mut self, value: i64);
    fn get_uint64_value(&self) -> u64;
    fn set_uint64_value(&mut self, value: u64);
    fn get_null_value(&self) -> ();
    fn set_null_value(&mut self, value: ());
    fn get_optional_string(&self) -> Option<String>;
    fn set_optional_string(&mut self, value: Option<String>);
    fn get_string_or_undefined(&self) -> Option<String>;
    fn set_string_or_undefined(&mut self, value: Option<String>);
    fn get_string_or_null(&self) -> Variant____String;
    fn set_string_or_null(&mut self, value: Variant____String);
    fn get_optional_array(&self) -> Option<Vec<String>>;
    fn set_optional_array(&mut self, value: Option<Vec<String>>);
    fn get_optional_enum(&self) -> Option<Powertrain>;
    fn set_optional_enum(&mut self, value: Option<Powertrain>);
    fn get_optional_old_enum(&self) -> Option<OldEnum>;
    fn set_optional_old_enum(&mut self, value: Option<OldEnum>);
    fn get_optional_callback(&self) -> Option<Box<dyn Fn(f64)>>;
    fn set_optional_callback(&mut self, value: Option<Box<dyn Fn(f64)>>);
    fn get_some_variant(&self) -> Variant_String_f64;
    fn set_some_variant(&mut self, value: Variant_String_f64);

    // Methods
    fn new_test_object(&mut self) -> Box<dyn HybridTestObjectRustSpec>;
    fn get_variant_hybrid(
        &mut self,
        variant: Variant_Box_dyn_HybridTestObjectRustSpec__Person,
    ) -> Variant_Box_dyn_HybridTestObjectRustSpec__Person;
    fn simple_func(&mut self);
    fn add_numbers(&mut self, a: f64, b: f64) -> f64;
    fn add_strings(&mut self, a: String, b: String) -> String;
    fn multiple_arguments(&mut self, num: f64, str: String, boo: bool);
    fn bounce_null(&mut self, value: ());
    fn bounce_strings(&mut self, array: Vec<String>) -> Vec<String>;
    fn bounce_numbers(&mut self, array: Vec<f64>) -> Vec<f64>;
    fn bounce_structs(&mut self, array: Vec<Person>) -> Vec<Person>;
    fn bounce_partial_struct(&mut self, person: PartialPerson) -> PartialPerson;
    fn sum_up_all_passengers(&mut self, cars: Vec<Car>) -> String;
    fn bounce_enums(&mut self, array: Vec<Powertrain>) -> Vec<Powertrain>;
    fn complex_enum_callback(
        &mut self,
        array: Vec<Powertrain>,
        callback: Box<dyn Fn(Vec<Powertrain>)>,
    );
    fn bounce_hybrid_objects(
        &mut self,
        array: Vec<Box<dyn HybridChildSpec>>,
    ) -> Vec<Box<dyn HybridChildSpec>>;
    fn bounce_functions(&mut self, functions: Vec<Box<dyn Fn()>>) -> Vec<Box<dyn Fn()>>;
    fn bounce_maps(&mut self, maps: Vec<*mut std::ffi::c_void>) -> Vec<*mut std::ffi::c_void>;
    fn bounce_promises(&mut self, promises: Vec<f64>) -> Vec<f64>;
    fn bounce_array_buffers(&mut self, array_buffers: Vec<NitroBuffer>) -> Vec<NitroBuffer>;
    fn create_map(&mut self) -> *mut std::ffi::c_void;
    fn map_roundtrip(&mut self, map: *mut std::ffi::c_void) -> *mut std::ffi::c_void;
    fn get_map_keys(&mut self, map: *mut std::ffi::c_void) -> Vec<String>;
    fn merge_maps(
        &mut self,
        a: *mut std::ffi::c_void,
        b: *mut std::ffi::c_void,
    ) -> *mut std::ffi::c_void;
    fn copy_any_map(&mut self, map: *mut std::ffi::c_void) -> *mut std::ffi::c_void;
    fn bounce_map(
        &mut self,
        map: HashMap<String, Variant_bool_f64>,
    ) -> HashMap<String, Variant_bool_f64>;
    fn bounce_simple_map(&mut self, map: HashMap<String, f64>) -> HashMap<String, f64>;
    fn extract_map(&mut self, map_wrapper: MapWrapper) -> HashMap<String, String>;
    fn func_that_throws(&mut self) -> f64;
    fn func_that_throws_before_promise(&mut self);
    fn throw_error(&mut self, error: String);
    fn try_optional_params(&mut self, num: f64, boo: bool, str: Option<String>) -> String;
    fn try_middle_param(&mut self, num: f64, boo: Option<bool>, str: String) -> String;
    fn try_optional_enum(&mut self, value: Option<Powertrain>) -> Option<Powertrain>;
    fn try_trailing_optional(&mut self, num: f64, str: String, boo: Option<bool>) -> bool;
    fn add1_hour(&mut self, date: f64) -> f64;
    fn current_date(&mut self) -> f64;
    fn calculate_fibonacci_sync(&mut self, value: f64) -> i64;
    fn calculate_fibonacci_async(&mut self, value: f64) -> i64;
    fn wait(&mut self, seconds: f64);
    fn promise_throws(&mut self);
    fn promise_returns_instantly(&mut self) -> f64;
    fn promise_returns_instantly_async(&mut self) -> f64;
    fn promise_that_resolves_void_instantly(&mut self);
    fn promise_that_resolves_to_undefined(&mut self) -> Option<f64>;
    fn await_and_get_promise(&mut self, promise: f64) -> f64;
    fn await_and_get_complex_promise(&mut self, promise: Car) -> Car;
    fn await_promise(&mut self, promise: ());
    fn call_callback(&mut self, callback: Box<dyn Fn()>);
    fn call_callback_that_returns_promise_void(&mut self, callback: Box<dyn Fn()>);
    fn call_all(&mut self, first: Box<dyn Fn()>, second: Box<dyn Fn()>, third: Box<dyn Fn()>);
    fn call_with_optional(&mut self, value: Option<f64>, callback: Box<dyn Fn(Option<f64>)>);
    fn call_sum_up_n_times(&mut self, callback: Box<dyn Fn() -> f64>, n: f64) -> f64;
    fn callback_async_promise(&mut self, callback: Box<dyn Fn() -> f64>) -> f64;
    fn callback_async_promise_buffer(
        &mut self,
        callback: Box<dyn Fn() -> NitroBuffer>,
    ) -> NitroBuffer;
    fn get_complex_callback(&mut self) -> Box<dyn Fn(f64)>;
    fn two_optional_callbacks(
        &mut self,
        value: f64,
        first: Option<Box<dyn Fn(f64)>>,
        second: Option<Box<dyn Fn(String)>>,
    );
    fn error_callback(&mut self, on_error: Box<dyn Fn(String)>);
    fn create_native_callback(
        &mut self,
        wrapping_js_callback: Box<dyn Fn(f64)>,
    ) -> Box<dyn Fn(f64)>;
    fn get_value_from_js_callback_and_wait(&mut self, get_value: Box<dyn Fn() -> f64>) -> f64;
    fn get_value_from_js_callback(
        &mut self,
        callback: Box<dyn Fn() -> String>,
        and_then_call: Box<dyn Fn(String)>,
    );
    fn get_car(&mut self) -> Car;
    fn is_car_electric(&mut self, car: Car) -> bool;
    fn get_driver(&mut self, car: Car) -> Option<Person>;
    fn bounce_car(&mut self, car: Car) -> Car;
    fn js_style_object_as_parameters(&mut self, params: JsStyleStruct);
    fn bounce_wrapped_js_style_struct(&mut self, value: WrappedJsStruct) -> WrappedJsStruct;
    fn bounce_optional_wrapper(&mut self, wrapper: OptionalWrapper) -> OptionalWrapper;
    fn bounce_optional_callback(&mut self, value: OptionalCallback) -> OptionalCallback;
    fn create_array_buffer(&mut self) -> NitroBuffer;
    fn create_array_buffer_from_native_buffer(&mut self, copy: bool) -> NitroBuffer;
    fn copy_buffer(&mut self, buffer: NitroBuffer) -> NitroBuffer;
    fn get_buffer_last_item(&mut self, buffer: NitroBuffer) -> f64;
    fn set_all_values_to(&mut self, buffer: NitroBuffer, value: f64);
    fn create_array_buffer_async(&mut self) -> NitroBuffer;
    fn bounce_array_buffer(&mut self, buffer: NitroBuffer) -> NitroBuffer;
    fn pass_variant(
        &mut self,
        either: Variant_bool_Vec_f64__Vec_String__String_f64,
    ) -> Variant_String_f64;
    fn get_variant_enum(&mut self, variant: Variant_bool_OldEnum) -> Variant_bool_OldEnum;
    fn get_variant_weird_numbers_enum(
        &mut self,
        variant: Variant_bool_WeirdNumbersEnum,
    ) -> Variant_bool_WeirdNumbersEnum;
    fn get_variant_objects(&mut self, variant: Variant_Car_Person) -> Variant_Car_Person;
    fn pass_named_variant(&mut self, variant: NamedVariant) -> NamedVariant;
    fn pass_all_empty_object_variant(
        &mut self,
        variant: Variant_Box_dyn_HybridBaseSpec__OptionalWrapper,
    ) -> Variant_Box_dyn_HybridBaseSpec__OptionalWrapper;
    fn bounce_complex_variant(&mut self, variant: CoreTypesVariant) -> CoreTypesVariant;
    fn create_child(&mut self) -> Box<dyn HybridChildSpec>;
    fn create_base(&mut self) -> Box<dyn HybridBaseSpec>;
    fn create_base_actual_child(&mut self) -> Box<dyn HybridBaseSpec>;
    fn bounce_child(&mut self, child: Box<dyn HybridChildSpec>) -> Box<dyn HybridChildSpec>;
    fn bounce_base(&mut self, base: Box<dyn HybridBaseSpec>) -> Box<dyn HybridBaseSpec>;
    fn bounce_child_base(&mut self, child: Box<dyn HybridChildSpec>) -> Box<dyn HybridBaseSpec>;
    fn cast_base(&mut self, base: Box<dyn HybridBaseSpec>) -> Box<dyn HybridChildSpec>;
    fn callback_sync(&mut self, callback: Box<dyn Fn() -> f64>) -> f64;
    fn get_is_view_blue(&mut self, view: Box<dyn HybridTestViewSpec>) -> bool;
    fn bounce_external_hybrid(
        &mut self,
        external_object: Box<dyn HybridSomeExternalObjectSpec>,
    ) -> Box<dyn HybridSomeExternalObjectSpec>;
    fn create_internal_object(&mut self) -> Box<dyn HybridSomeExternalObjectSpec>;
    fn bounce_external_struct(
        &mut self,
        external_struct: ExternalObjectStruct,
    ) -> ExternalObjectStruct;
    fn bounce_external_variant(&mut self, variant: StringOrExternal) -> StringOrExternal;
    fn create_external_variant_from_func(
        &mut self,
        factory: Box<dyn Fn() -> Box<dyn HybridSomeExternalObjectSpec>>,
    ) -> Box<dyn HybridSomeExternalObjectSpec>;

    /// Return the size of any external heap allocations, in bytes.
    /// This is used to inform the JavaScript GC about native memory pressure.
    fn memory_size(&self) -> usize {
        0
    }
}

// FFI shims for C++ bridge

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_this_object(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            Box::into_raw(Box::new(obj.get_this_object())) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_hybrid(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __opt: __Opt = match obj.get_optional_hybrid() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: Box::into_raw(Box::new(__v)) as *mut std::ffi::c_void,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_hybrid(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_hybrid({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(*Box::from_raw(
                        __s.value as *mut Box<dyn HybridTestObjectRustSpec>,
                    ))
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_number_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.get_number_value()
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_number_value(
    ptr: *mut std::ffi::c_void,
    value: f64,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_number_value(value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_bool_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_bool {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.get_bool_value()
        })) {
            Ok(__result) => __FfiResult_bool {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_bool {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_bool_value(
    ptr: *mut std::ffi::c_void,
    value: bool,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_bool_value(value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_string_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_cstr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                let __s = obj.get_string_value().replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            }
        })) {
            Ok(__result) => __FfiResult_cstr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_cstr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_string_value(
    ptr: *mut std::ffi::c_void,
    value: *const std::ffi::c_char,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_string_value(
                std::ffi::CStr::from_ptr(value)
                    .to_string_lossy()
                    .into_owned(),
            );
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_int64_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_i64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.get_int64_value()
        })) {
            Ok(__result) => __FfiResult_i64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_i64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_int64_value(
    ptr: *mut std::ffi::c_void,
    value: i64,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_int64_value(value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_uint64_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_u64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.get_uint64_value()
        })) {
            Ok(__result) => __FfiResult_u64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_u64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_uint64_value(
    ptr: *mut std::ffi::c_void,
    value: u64,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_uint64_value(value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_null_value(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.get_null_value()
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_null_value(
    ptr: *mut std::ffi::c_void,
    value: (),
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_null_value(value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_string(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *const std::ffi::c_char,
                }
                let __opt: __Opt = match obj.get_optional_string() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: {
                            let __s = __v.replace('\0', "");
                            std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                        },
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_string(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_string({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *const std::ffi::c_char,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(
                        std::ffi::CStr::from_ptr(__s.value)
                            .to_string_lossy()
                            .into_owned(),
                    )
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_string_or_undefined(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *const std::ffi::c_char,
                }
                let __opt: __Opt = match obj.get_string_or_undefined() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: {
                            let __s = __v.replace('\0', "");
                            std::ffi::CString::new(__s).unwrap_or_default().into_raw()
                        },
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_string_or_undefined(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_string_or_undefined({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *const std::ffi::c_char,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(
                        std::ffi::CStr::from_ptr(__s.value)
                            .to_string_lossy()
                            .into_owned(),
                    )
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_string_or_null(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            Box::into_raw(Box::new(obj.get_string_or_null())) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_string_or_null(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_string_or_null(*Box::from_raw(value as *mut Variant____String));
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_array(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __opt: __Opt = match obj.get_optional_array() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: Box::into_raw(Box::new(__v)) as *mut std::ffi::c_void,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_array(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_array({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(*Box::from_raw(__s.value as *mut Vec<String>))
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_enum(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __opt: __Opt = match obj.get_optional_enum() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: __v as i32,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_enum(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_enum({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(Powertrain::from_i32(__s.value).unwrap_or_else(|| {
                        panic!("[Nitro] Invalid Powertrain discriminant: {}", __s.value)
                    }))
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_old_enum(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __opt: __Opt = match obj.get_optional_old_enum() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: __v as i32,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_old_enum(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_old_enum({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(OldEnum::from_i32(__s.value).unwrap_or_else(|| {
                        panic!("[Nitro] Invalid OldEnum discriminant: {}", __s.value)
                    }))
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_optional_callback(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __opt: __Opt = match obj.get_optional_callback() {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: Box::into_raw(Box::new(__v)) as *mut std::ffi::c_void,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_optional_callback(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_optional_callback({
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some({
                        let __wrapper = Box::from_raw(
                            __s.value as *mut super::Func_void_double::Func_void_double,
                        );
                        let __cb: Box<dyn Fn(f64)> =
                            Box::new(move |__p0: f64| unsafe { __wrapper.call(__p0) });
                        __cb
                    })
                } else {
                    None
                }
            });
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_some_variant(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            Box::into_raw(Box::new(obj.get_some_variant())) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_some_variant(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.set_some_variant(*Box::from_raw(value as *mut Variant_String_f64));
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_new_test_object(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.new_test_object();
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_variant_hybrid(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant =
                *Box::from_raw(variant as *mut Variant_Box_dyn_HybridTestObjectRustSpec__Person);
            let __result = obj.get_variant_hybrid(__variant);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_simple_func(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.simple_func();
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_add_numbers(
    ptr: *mut std::ffi::c_void,
    a: f64,
    b: f64,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.add_numbers(a, b)
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_add_strings(
    ptr: *mut std::ffi::c_void,
    a: *const std::ffi::c_char,
    b: *const std::ffi::c_char,
) -> __FfiResult_cstr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __a = std::ffi::CStr::from_ptr(a).to_string_lossy().into_owned();
            let __b = std::ffi::CStr::from_ptr(b).to_string_lossy().into_owned();
            let __result = obj.add_strings(__a, __b);
            {
                let __s = __result.replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            }
        })) {
            Ok(__result) => __FfiResult_cstr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_cstr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_multiple_arguments(
    ptr: *mut std::ffi::c_void,
    num: f64,
    str: *const std::ffi::c_char,
    boo: bool,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __str = std::ffi::CStr::from_ptr(str).to_string_lossy().into_owned();
            obj.multiple_arguments(num, __str, boo);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_null(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.bounce_null();
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_strings(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<String>);
            let __result = obj.bounce_strings(__array);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_numbers(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<f64>);
            let __result = obj.bounce_numbers(__array);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_structs(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<Person>);
            let __result = obj.bounce_structs(__array);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_partial_struct(
    ptr: *mut std::ffi::c_void,
    person: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __person = *Box::from_raw(person as *mut PartialPerson);
            let __result = obj.bounce_partial_struct(__person);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_sum_up_all_passengers(
    ptr: *mut std::ffi::c_void,
    cars: *mut std::ffi::c_void,
) -> __FfiResult_cstr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __cars = *Box::from_raw(cars as *mut Vec<Car>);
            let __result = obj.sum_up_all_passengers(__cars);
            {
                let __s = __result.replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            }
        })) {
            Ok(__result) => __FfiResult_cstr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_cstr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_enums(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<Powertrain>);
            let __result = obj.bounce_enums(__array);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_complex_enum_callback(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<Powertrain>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::Func_void_std__vector_Powertrain_::Func_void_std__vector_Powertrain_);
                let __cb: Box<dyn Fn(Vec<Powertrain>)> =
                    Box::new(move |__p0: Vec<Powertrain>| unsafe { __wrapper.call(__p0) });
                __cb
            };
            obj.complex_enum_callback(__array, __callback);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_hybrid_objects(
    ptr: *mut std::ffi::c_void,
    array: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array = *Box::from_raw(array as *mut Vec<Box<dyn HybridChildSpec>>);
            let __result = obj.bounce_hybrid_objects(__array);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_functions(
    ptr: *mut std::ffi::c_void,
    functions: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __functions = *Box::from_raw(functions as *mut Vec<Box<dyn Fn()>>);
            let __result = obj.bounce_functions(__functions);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_maps(
    ptr: *mut std::ffi::c_void,
    maps: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __maps = *Box::from_raw(maps as *mut Vec<*mut std::ffi::c_void>);
            let __result = obj.bounce_maps(__maps);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_promises(
    ptr: *mut std::ffi::c_void,
    promises: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __promises = *Box::from_raw(promises as *mut Vec<f64>);
            let __result = obj.bounce_promises(__promises);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_array_buffers(
    ptr: *mut std::ffi::c_void,
    array_buffers: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __array_buffers = *Box::from_raw(array_buffers as *mut Vec<NitroBuffer>);
            let __result = obj.bounce_array_buffers(__array_buffers);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_map(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.create_map();
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_map_roundtrip(
    ptr: *mut std::ffi::c_void,
    map: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map = *Box::from_raw(map as *mut *mut std::ffi::c_void);
            let __result = obj.map_roundtrip(__map);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_map_keys(
    ptr: *mut std::ffi::c_void,
    map: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map = *Box::from_raw(map as *mut *mut std::ffi::c_void);
            let __result = obj.get_map_keys(__map);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_merge_maps(
    ptr: *mut std::ffi::c_void,
    a: *mut std::ffi::c_void,
    b: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __a = *Box::from_raw(a as *mut *mut std::ffi::c_void);
            let __b = *Box::from_raw(b as *mut *mut std::ffi::c_void);
            let __result = obj.merge_maps(__a, __b);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_copy_any_map(
    ptr: *mut std::ffi::c_void,
    map: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map = *Box::from_raw(map as *mut *mut std::ffi::c_void);
            let __result = obj.copy_any_map(__map);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_map(
    ptr: *mut std::ffi::c_void,
    map: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map = *Box::from_raw(map as *mut HashMap<String, Variant_bool_f64>);
            let __result = obj.bounce_map(__map);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_simple_map(
    ptr: *mut std::ffi::c_void,
    map: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map = *Box::from_raw(map as *mut HashMap<String, f64>);
            let __result = obj.bounce_simple_map(__map);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_extract_map(
    ptr: *mut std::ffi::c_void,
    map_wrapper: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __map_wrapper = *Box::from_raw(map_wrapper as *mut MapWrapper);
            let __result = obj.extract_map(__map_wrapper);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_func_that_throws(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.func_that_throws()
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_func_that_throws_before_promise(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.func_that_throws_before_promise();
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_throw_error(
    ptr: *mut std::ffi::c_void,
    error: *const std::ffi::c_char,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __error = std::ffi::CStr::from_ptr(error)
                .to_string_lossy()
                .into_owned();
            obj.throw_error(__error);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_try_optional_params(
    ptr: *mut std::ffi::c_void,
    num: f64,
    boo: bool,
    str: *mut std::ffi::c_void,
) -> __FfiResult_cstr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __str = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *const std::ffi::c_char,
                }
                let __s = *Box::from_raw(str as *mut __Opt);
                if __s.has_value != 0 {
                    Some(
                        std::ffi::CStr::from_ptr(__s.value)
                            .to_string_lossy()
                            .into_owned(),
                    )
                } else {
                    None
                }
            };
            let __result = obj.try_optional_params(num, boo, __str);
            {
                let __s = __result.replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            }
        })) {
            Ok(__result) => __FfiResult_cstr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_cstr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_try_middle_param(
    ptr: *mut std::ffi::c_void,
    num: f64,
    boo: *mut std::ffi::c_void,
    str: *const std::ffi::c_char,
) -> __FfiResult_cstr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __boo = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: bool,
                }
                let __s = *Box::from_raw(boo as *mut __Opt);
                if __s.has_value != 0 {
                    Some(__s.value)
                } else {
                    None
                }
            };
            let __str = std::ffi::CStr::from_ptr(str).to_string_lossy().into_owned();
            let __result = obj.try_middle_param(num, __boo, __str);
            {
                let __s = __result.replace('\0', "");
                std::ffi::CString::new(__s).unwrap_or_default().into_raw()
            }
        })) {
            Ok(__result) => __FfiResult_cstr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_cstr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_try_optional_enum(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __value = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(Powertrain::from_i32(__s.value).unwrap_or_else(|| {
                        panic!("[Nitro] Invalid Powertrain discriminant: {}", __s.value)
                    }))
                } else {
                    None
                }
            };
            let __result = obj.try_optional_enum(__value);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: i32,
                }
                let __opt: __Opt = match __result {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: __v as i32,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_try_trailing_optional(
    ptr: *mut std::ffi::c_void,
    num: f64,
    str: *const std::ffi::c_char,
    boo: *mut std::ffi::c_void,
) -> __FfiResult_bool {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __str = std::ffi::CStr::from_ptr(str).to_string_lossy().into_owned();
            let __boo = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: bool,
                }
                let __s = *Box::from_raw(boo as *mut __Opt);
                if __s.has_value != 0 {
                    Some(__s.value)
                } else {
                    None
                }
            };
            obj.try_trailing_optional(num, __str, __boo)
        })) {
            Ok(__result) => __FfiResult_bool {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_bool {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_add1_hour(
    ptr: *mut std::ffi::c_void,
    date: f64,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __date = date;
            let __result = obj.add1_hour(__date);
            __result
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_current_date(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.current_date();
            __result
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_calculate_fibonacci_sync(
    ptr: *mut std::ffi::c_void,
    value: f64,
) -> __FfiResult_i64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.calculate_fibonacci_sync(value)
        })) {
            Ok(__result) => __FfiResult_i64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_i64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_calculate_fibonacci_async(
    ptr: *mut std::ffi::c_void,
    value: f64,
) -> __FfiResult_i64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.calculate_fibonacci_async(value)
        })) {
            Ok(__result) => __FfiResult_i64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_i64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_wait(
    ptr: *mut std::ffi::c_void,
    seconds: f64,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.wait(seconds);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_promise_throws(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.promise_throws();
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_promise_returns_instantly(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.promise_returns_instantly()
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_promise_returns_instantly_async(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.promise_returns_instantly_async()
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_promise_that_resolves_void_instantly(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            obj.promise_that_resolves_void_instantly();
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_promise_that_resolves_to_undefined(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.promise_that_resolves_to_undefined();
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: f64,
                }
                let __opt: __Opt = match __result {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: __v,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_await_and_get_promise(
    ptr: *mut std::ffi::c_void,
    promise: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __promise = *Box::from_raw(promise as *mut f64);
            obj.await_and_get_promise(__promise)
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_await_and_get_complex_promise(
    ptr: *mut std::ffi::c_void,
    promise: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __promise = *Box::from_raw(promise as *mut Car);
            let __result = obj.await_and_get_complex_promise(__promise);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_await_promise(
    ptr: *mut std::ffi::c_void,
    promise: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __promise = *Box::from_raw(promise as *mut ());
            obj.await_promise(__promise);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_call_callback(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::Func_void::Func_void);
                let __cb: Box<dyn Fn()> = Box::new(move || unsafe { __wrapper.call() });
                __cb
            };
            obj.call_callback(__callback);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_call_callback_that_returns_promise_void(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::Func_std__shared_ptr_Promise_std__shared_ptr_Promise_void____::Func_std__shared_ptr_Promise_std__shared_ptr_Promise_void____);
                let __cb: Box<dyn Fn()> = Box::new(move || unsafe { __wrapper.call() });
                __cb
            };
            obj.call_callback_that_returns_promise_void(__callback);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_call_all(
    ptr: *mut std::ffi::c_void,
    first: *mut std::ffi::c_void,
    second: *mut std::ffi::c_void,
    third: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __first = {
                let __wrapper = Box::from_raw(first as *mut super::Func_void::Func_void);
                let __cb: Box<dyn Fn()> = Box::new(move || unsafe { __wrapper.call() });
                __cb
            };
            let __second = {
                let __wrapper = Box::from_raw(second as *mut super::Func_void::Func_void);
                let __cb: Box<dyn Fn()> = Box::new(move || unsafe { __wrapper.call() });
                __cb
            };
            let __third = {
                let __wrapper = Box::from_raw(third as *mut super::Func_void::Func_void);
                let __cb: Box<dyn Fn()> = Box::new(move || unsafe { __wrapper.call() });
                __cb
            };
            obj.call_all(__first, __second, __third);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_call_with_optional(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __value = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: f64,
                }
                let __s = *Box::from_raw(value as *mut __Opt);
                if __s.has_value != 0 {
                    Some(__s.value)
                } else {
                    None
                }
            };
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::Func_void_std__optional_double_::Func_void_std__optional_double_);
                let __cb: Box<dyn Fn(Option<f64>)> =
                    Box::new(move |__p0: Option<f64>| unsafe { __wrapper.call(__p0) });
                __cb
            };
            obj.call_with_optional(__value, __callback);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_call_sum_up_n_times(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
    n: f64,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::Func_std__shared_ptr_Promise_double__::Func_std__shared_ptr_Promise_double__);
                let __cb: Box<dyn Fn() -> f64> =
                    Box::new(move || -> f64 { unsafe { __wrapper.call() } });
                __cb
            };
            obj.call_sum_up_n_times(__callback, n)
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_callback_async_promise(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::Func_std__shared_ptr_Promise_std__shared_ptr_Promise_double____::Func_std__shared_ptr_Promise_std__shared_ptr_Promise_double____);
                let __cb: Box<dyn Fn() -> f64> =
                    Box::new(move || -> f64 { unsafe { __wrapper.call() } });
                __cb
            };
            obj.callback_async_promise(__callback)
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_callback_async_promise_buffer(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer_____::Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer_____);
                let __cb: Box<dyn Fn() -> NitroBuffer> =
                    Box::new(move || -> NitroBuffer { unsafe { __wrapper.call() } });
                __cb
            };
            let __result = obj.callback_async_promise_buffer(__callback);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_complex_callback(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.get_complex_callback();
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_two_optional_callbacks(
    ptr: *mut std::ffi::c_void,
    value: f64,
    first: *mut std::ffi::c_void,
    second: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __first = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __s = *Box::from_raw(first as *mut __Opt);
                if __s.has_value != 0 {
                    Some({
                        let __wrapper = Box::from_raw(
                            __s.value as *mut super::Func_void_double::Func_void_double,
                        );
                        let __cb: Box<dyn Fn(f64)> =
                            Box::new(move |__p0: f64| unsafe { __wrapper.call(__p0) });
                        __cb
                    })
                } else {
                    None
                }
            };
            let __second = {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __s = *Box::from_raw(second as *mut __Opt);
                if __s.has_value != 0 {
                    Some({
                        let __wrapper = Box::from_raw(
                            __s.value as *mut super::Func_void_std__string::Func_void_std__string,
                        );
                        let __cb: Box<dyn Fn(String)> =
                            Box::new(move |__p0: String| unsafe { __wrapper.call(__p0) });
                        __cb
                    })
                } else {
                    None
                }
            };
            obj.two_optional_callbacks(value, __first, __second);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_error_callback(
    ptr: *mut std::ffi::c_void,
    on_error: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __on_error = {
                let __wrapper = Box::from_raw(
                    on_error
                        as *mut super::Func_void_std__exception_ptr::Func_void_std__exception_ptr,
                );
                let __cb: Box<dyn Fn(String)> =
                    Box::new(move |__p0: String| unsafe { __wrapper.call(__p0) });
                __cb
            };
            obj.error_callback(__on_error);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_native_callback(
    ptr: *mut std::ffi::c_void,
    wrapping_js_callback: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __wrapping_js_callback = {
                let __wrapper = Box::from_raw(
                    wrapping_js_callback as *mut super::Func_void_double::Func_void_double,
                );
                let __cb: Box<dyn Fn(f64)> =
                    Box::new(move |__p0: f64| unsafe { __wrapper.call(__p0) });
                __cb
            };
            let __result = obj.create_native_callback(__wrapping_js_callback);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_value_from_js_callback_and_wait(
    ptr: *mut std::ffi::c_void,
    get_value: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __get_value = {
                let __wrapper = Box::from_raw(get_value as *mut super::Func_std__shared_ptr_Promise_double__::Func_std__shared_ptr_Promise_double__);
                let __cb: Box<dyn Fn() -> f64> =
                    Box::new(move || -> f64 { unsafe { __wrapper.call() } });
                __cb
            };
            obj.get_value_from_js_callback_and_wait(__get_value)
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_value_from_js_callback(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
    and_then_call: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::Func_std__shared_ptr_Promise_std__string__::Func_std__shared_ptr_Promise_std__string__);
                let __cb: Box<dyn Fn() -> String> =
                    Box::new(move || -> String { unsafe { __wrapper.call() } });
                __cb
            };
            let __and_then_call = {
                let __wrapper = Box::from_raw(
                    and_then_call as *mut super::Func_void_std__string::Func_void_std__string,
                );
                let __cb: Box<dyn Fn(String)> =
                    Box::new(move |__p0: String| unsafe { __wrapper.call(__p0) });
                __cb
            };
            obj.get_value_from_js_callback(__callback, __and_then_call);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_car(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.get_car();
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_is_car_electric(
    ptr: *mut std::ffi::c_void,
    car: *mut std::ffi::c_void,
) -> __FfiResult_bool {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __car = *Box::from_raw(car as *mut Car);
            obj.is_car_electric(__car)
        })) {
            Ok(__result) => __FfiResult_bool {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_bool {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_driver(
    ptr: *mut std::ffi::c_void,
    car: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __car = *Box::from_raw(car as *mut Car);
            let __result = obj.get_driver(__car);
            {
                #[repr(C)]
                struct __Opt {
                    has_value: u8,
                    value: *mut std::ffi::c_void,
                }
                let __opt: __Opt = match __result {
                    Some(__v) => __Opt {
                        has_value: 1,
                        value: Box::into_raw(Box::new(__v)) as *mut std::ffi::c_void,
                    },
                    None => __Opt {
                        has_value: 0,
                        value: unsafe { std::mem::zeroed() }, /* SAFETY: value is never read when has_value=0; all FFI types are zero-safe */
                    },
                };
                Box::into_raw(Box::new(__opt)) as *mut std::ffi::c_void
            }
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_car(
    ptr: *mut std::ffi::c_void,
    car: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __car = *Box::from_raw(car as *mut Car);
            let __result = obj.bounce_car(__car);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_js_style_object_as_parameters(
    ptr: *mut std::ffi::c_void,
    params: *mut std::ffi::c_void,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __params = *Box::from_raw(params as *mut JsStyleStruct);
            obj.js_style_object_as_parameters(__params);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_wrapped_js_style_struct(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __value = *Box::from_raw(value as *mut WrappedJsStruct);
            let __result = obj.bounce_wrapped_js_style_struct(__value);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_optional_wrapper(
    ptr: *mut std::ffi::c_void,
    wrapper: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __wrapper = *Box::from_raw(wrapper as *mut OptionalWrapper);
            let __result = obj.bounce_optional_wrapper(__wrapper);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_optional_callback(
    ptr: *mut std::ffi::c_void,
    value: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __value = *Box::from_raw(value as *mut OptionalCallback);
            let __result = obj.bounce_optional_callback(__value);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_array_buffer(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.create_array_buffer();
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_array_buffer_from_native_buffer(
    ptr: *mut std::ffi::c_void,
    copy: bool,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.create_array_buffer_from_native_buffer(copy);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_copy_buffer(
    ptr: *mut std::ffi::c_void,
    buffer: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __buffer = *Box::from_raw(buffer as *mut super::NitroBuffer::NitroBuffer);
            let __result = obj.copy_buffer(__buffer);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_buffer_last_item(
    ptr: *mut std::ffi::c_void,
    buffer: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __buffer = *Box::from_raw(buffer as *mut super::NitroBuffer::NitroBuffer);
            obj.get_buffer_last_item(__buffer)
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_set_all_values_to(
    ptr: *mut std::ffi::c_void,
    buffer: *mut std::ffi::c_void,
    value: f64,
) -> __FfiResult_void {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __buffer = *Box::from_raw(buffer as *mut super::NitroBuffer::NitroBuffer);
            obj.set_all_values_to(__buffer, value);
        })) {
            Ok(_) => __FfiResult_void {
                is_ok: 1,
                error: std::ptr::null_mut(),
            },
            Err(__panic) => __FfiResult_void {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_array_buffer_async(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.create_array_buffer_async();
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_array_buffer(
    ptr: *mut std::ffi::c_void,
    buffer: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __buffer = *Box::from_raw(buffer as *mut super::NitroBuffer::NitroBuffer);
            let __result = obj.bounce_array_buffer(__buffer);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_pass_variant(
    ptr: *mut std::ffi::c_void,
    either: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __either =
                *Box::from_raw(either as *mut Variant_bool_Vec_f64__Vec_String__String_f64);
            let __result = obj.pass_variant(__either);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_variant_enum(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut Variant_bool_OldEnum);
            let __result = obj.get_variant_enum(__variant);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_variant_weird_numbers_enum(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut Variant_bool_WeirdNumbersEnum);
            let __result = obj.get_variant_weird_numbers_enum(__variant);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_variant_objects(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut Variant_Car_Person);
            let __result = obj.get_variant_objects(__variant);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_pass_named_variant(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut NamedVariant);
            let __result = obj.pass_named_variant(__variant);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_pass_all_empty_object_variant(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant =
                *Box::from_raw(variant as *mut Variant_Box_dyn_HybridBaseSpec__OptionalWrapper);
            let __result = obj.pass_all_empty_object_variant(__variant);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_complex_variant(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut CoreTypesVariant);
            let __result = obj.bounce_complex_variant(__variant);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_child(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.create_child();
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_base(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.create_base();
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_base_actual_child(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.create_base_actual_child();
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_child(
    ptr: *mut std::ffi::c_void,
    child: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __child = *Box::from_raw(child as *mut Box<dyn HybridChildSpec>);
            let __result = obj.bounce_child(__child);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_base(
    ptr: *mut std::ffi::c_void,
    base: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __base = *Box::from_raw(base as *mut Box<dyn HybridBaseSpec>);
            let __result = obj.bounce_base(__base);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_child_base(
    ptr: *mut std::ffi::c_void,
    child: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __child = *Box::from_raw(child as *mut Box<dyn HybridChildSpec>);
            let __result = obj.bounce_child_base(__child);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_cast_base(
    ptr: *mut std::ffi::c_void,
    base: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __base = *Box::from_raw(base as *mut Box<dyn HybridBaseSpec>);
            let __result = obj.cast_base(__base);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_callback_sync(
    ptr: *mut std::ffi::c_void,
    callback: *mut std::ffi::c_void,
) -> __FfiResult_f64 {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __callback = {
                let __wrapper = Box::from_raw(callback as *mut super::Func_double::Func_double);
                let __cb: Box<dyn Fn() -> f64> =
                    Box::new(move || -> f64 { unsafe { __wrapper.call() } });
                __cb
            };
            obj.callback_sync(__callback)
        })) {
            Ok(__result) => __FfiResult_f64 {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_f64 {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_get_is_view_blue(
    ptr: *mut std::ffi::c_void,
    view: *mut std::ffi::c_void,
) -> __FfiResult_bool {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __view = *Box::from_raw(view as *mut Box<dyn HybridTestViewSpec>);
            obj.get_is_view_blue(__view)
        })) {
            Ok(__result) => __FfiResult_bool {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_bool {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_external_hybrid(
    ptr: *mut std::ffi::c_void,
    external_object: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __external_object =
                *Box::from_raw(external_object as *mut Box<dyn HybridSomeExternalObjectSpec>);
            let __result = obj.bounce_external_hybrid(__external_object);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_internal_object(
    ptr: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __result = obj.create_internal_object();
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_external_struct(
    ptr: *mut std::ffi::c_void,
    external_struct: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __external_struct = *Box::from_raw(external_struct as *mut ExternalObjectStruct);
            let __result = obj.bounce_external_struct(__external_struct);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_bounce_external_variant(
    ptr: *mut std::ffi::c_void,
    variant: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __variant = *Box::from_raw(variant as *mut StringOrExternal);
            let __result = obj.bounce_external_variant(__variant);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_create_external_variant_from_func(
    ptr: *mut std::ffi::c_void,
    factory: *mut std::ffi::c_void,
) -> __FfiResult_ptr {
    unsafe {
        match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let obj = &mut *(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
            let __factory = {
                let __wrapper = Box::from_raw(factory as *mut super::Func_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_::Func_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_);
                let __cb: Box<dyn Fn() -> Box<dyn HybridSomeExternalObjectSpec>> =
                    Box::new(move || -> Box<dyn HybridSomeExternalObjectSpec> {
                        unsafe { __wrapper.call() }
                    });
                __cb
            };
            let __result = obj.create_external_variant_from_func(__factory);
            Box::into_raw(Box::new(__result)) as *mut std::ffi::c_void
        })) {
            Ok(__result) => __FfiResult_ptr {
                is_ok: 1,
                error: std::ptr::null_mut(),
                value: __result,
            },
            Err(__panic) => __FfiResult_ptr {
                is_ok: 0,
                error: super::lib::__nitro_panic_to_cstring(__panic),
                value: std::mem::zeroed(),
            },
        }
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_memory_size(ptr: *mut std::ffi::c_void) -> usize {
    unsafe {
        let obj = &*(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
        obj.memory_size()
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HybridTestObjectRustSpec_destroy(ptr: *mut std::ffi::c_void) {
    unsafe {
        let _ = Box::from_raw(ptr as *mut Box<dyn HybridTestObjectRustSpec>);
    }
}
