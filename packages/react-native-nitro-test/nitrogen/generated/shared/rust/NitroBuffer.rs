//
// NitroBuffer.rs
// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
// https://github.com/mrousavy/nitro
// Copyright Â© Marc Rousavy @ Margelo
//
#![allow(
    non_camel_case_types,
    non_snake_case,
    dead_code,
    unused_imports,
    clippy::all
)]

use std::ffi::c_void;

/// A zero-copy buffer type for passing ArrayBuffer data across the FFI boundary.
///
/// On the C++ side, a `NitroBuffer` is created from a `shared_ptr<ArrayBuffer>`:
/// - `data` points directly to the ArrayBuffer's memory
/// - `len` is the byte length
/// - `handle` is an opaque pointer to the boxed `shared_ptr` (prevents deallocation)
/// - `release_fn` frees the `handle` when the NitroBuffer is dropped
///
/// On the Rust side, you can access the data as a slice without copying.
/// If you need an owned `Vec<u8>`, use `to_vec()` which will copy.
#[repr(C)]
pub struct NitroBuffer {
    data: *mut u8,
    len: usize,
    handle: *mut c_void,
    release_fn: unsafe extern "C" fn(*mut c_void),
}

// SAFETY: NitroBuffer owns its handle and the C++ shared_ptr it points to
// is thread-safe (reference counting is atomic). The data pointer remains
// valid as long as the handle is alive.
unsafe impl Send for NitroBuffer {}
unsafe impl Sync for NitroBuffer {}

impl NitroBuffer {
    /// Create a NitroBuffer that takes ownership of a Vec<u8>.
    pub fn from_vec(mut vec: Vec<u8>) -> Self {
        let data = vec.as_mut_ptr();
        let len = vec.len();
        let handle = Box::into_raw(Box::new(vec)) as *mut c_void;

        unsafe extern "C" fn release_vec(handle: *mut c_void) {
            unsafe {
                drop(Box::from_raw(handle as *mut Vec<u8>));
            }
        }

        NitroBuffer {
            data,
            len,
            handle,
            release_fn: release_vec,
        }
    }

    /// Get an immutable slice of the buffer's data.
    ///
    /// # Safety
    /// The caller must ensure this NitroBuffer has not been dropped
    /// and the data pointer is still valid.
    pub unsafe fn as_slice(&self) -> &[u8] {
        unsafe { std::slice::from_raw_parts(self.data, self.len) }
    }

    /// Get a mutable slice of the buffer's data.
    ///
    /// # Safety
    /// The caller must ensure this NitroBuffer has not been dropped,
    /// the data pointer is still valid, and there are no other references
    /// to this data.
    pub unsafe fn as_mut_slice(&mut self) -> &mut [u8] {
        unsafe { std::slice::from_raw_parts_mut(self.data, self.len) }
    }

    /// Copy the buffer's data into a new owned Vec<u8>.
    pub fn to_vec(&self) -> Vec<u8> {
        unsafe { self.as_slice().to_vec() }
    }

    /// Get the length of the buffer in bytes.
    pub fn len(&self) -> usize {
        self.len
    }

    /// Check if the buffer is empty.
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    /// Get a raw pointer to the buffer's data.
    pub fn as_ptr(&self) -> *const u8 {
        self.data
    }

    /// Get a mutable raw pointer to the buffer's data.
    pub fn as_mut_ptr(&mut self) -> *mut u8 {
        self.data
    }
}

impl Drop for NitroBuffer {
    fn drop(&mut self) {
        unsafe {
            (self.release_fn)(self.handle);
        }
    }
}
