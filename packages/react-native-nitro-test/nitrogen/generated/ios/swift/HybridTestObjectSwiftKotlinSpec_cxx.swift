///
/// HybridTestObjectSwiftKotlinSpec_cxx.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

import Foundation
import NitroModules
import NitroTestExternal

/**
 * A class implementation that bridges HybridTestObjectSwiftKotlinSpec over to C++.
 * In C++, we cannot use Swift protocols - so we need to wrap it in a class to make it strongly defined.
 *
 * Also, some Swift types need to be bridged with special handling:
 * - Enums need to be wrapped in Structs, otherwise they cannot be accessed bi-directionally (Swift bug: https://github.com/swiftlang/swift/issues/75330)
 * - Other HybridObjects need to be wrapped/unwrapped from the Swift TCxx wrapper
 * - Throwing methods need to be wrapped with a Result<T, Error> type, as exceptions cannot be propagated to C++
 */
open class HybridTestObjectSwiftKotlinSpec_cxx {
  /**
   * The Swift <> C++ bridge's namespace (`margelo::nitro::test::bridge::swift`)
   * from `NitroTest-Swift-Cxx-Bridge.hpp`.
   * This contains specialized C++ templates, and C++ helper functions that can be accessed from Swift.
   */
  public typealias bridge = margelo.nitro.test.bridge.swift

  /**
   * Holds an instance of the `HybridTestObjectSwiftKotlinSpec` Swift protocol.
   */
  private var __implementation: any HybridTestObjectSwiftKotlinSpec

  /**
   * Holds a weak pointer to the C++ class that wraps the Swift class.
   */
  private var __cxxPart: bridge.std__weak_ptr_HybridTestObjectSwiftKotlinSpec_

  /**
   * Create a new `HybridTestObjectSwiftKotlinSpec_cxx` that wraps the given `HybridTestObjectSwiftKotlinSpec`.
   * All properties and methods bridge to C++ types.
   */
  public init(_ implementation: any HybridTestObjectSwiftKotlinSpec) {
    self.__implementation = implementation
    self.__cxxPart = .init()
    /* no base class */
  }

  /**
   * Get the actual `HybridTestObjectSwiftKotlinSpec` instance this class wraps.
   */
  @inline(__always)
  public func getHybridTestObjectSwiftKotlinSpec() -> any HybridTestObjectSwiftKotlinSpec {
    return __implementation
  }

  /**
   * Casts this instance to a retained unsafe raw pointer.
   * This acquires one additional strong reference on the object!
   */
  public func toUnsafe() -> UnsafeMutableRawPointer {
    return Unmanaged.passRetained(self).toOpaque()
  }

  /**
   * Casts an unsafe pointer to a `HybridTestObjectSwiftKotlinSpec_cxx`.
   * The pointer has to be a retained opaque `Unmanaged<HybridTestObjectSwiftKotlinSpec_cxx>`.
   * This removes one strong reference from the object!
   */
  public class func fromUnsafe(_ pointer: UnsafeMutableRawPointer) -> HybridTestObjectSwiftKotlinSpec_cxx {
    return Unmanaged<HybridTestObjectSwiftKotlinSpec_cxx>.fromOpaque(pointer).takeRetainedValue()
  }

  /**
   * Gets (or creates) the C++ part of this Hybrid Object.
   * The C++ part is a `std::shared_ptr<HybridTestObjectSwiftKotlinSpec>`.
   */
  public func getCxxPart() -> bridge.std__shared_ptr_HybridTestObjectSwiftKotlinSpec_ {
    let cachedCxxPart = self.__cxxPart.lock()
    if Bool(fromCxx: cachedCxxPart) {
      return cachedCxxPart
    } else {
      let newCxxPart = bridge.create_std__shared_ptr_HybridTestObjectSwiftKotlinSpec_(self.toUnsafe())
      __cxxPart = bridge.weakify_std__shared_ptr_HybridTestObjectSwiftKotlinSpec_(newCxxPart)
      return newCxxPart
    }
  }

  

  /**
   * Get the memory size of the Swift class (plus size of any other allocations)
   * so the JS VM can properly track it and garbage-collect the JS object if needed.
   */
  @inline(__always)
  public var memorySize: Int {
    return MemoryHelper.getSizeOf(self.__implementation) + self.__implementation.memorySize
  }

  /**
   * Compares this object with the given [other] object for reference equality.
   */
  @inline(__always)
  public func equals(other: HybridTestObjectSwiftKotlinSpec_cxx) -> Bool {
    return self.__implementation === other.__implementation
  }

  /**
   * Call dispose() on the Swift class.
   * This _may_ be called manually from JS.
   */
  @inline(__always)
  public func dispose() {
    self.__implementation.dispose()
  }

  /**
   * Call toString() on the Swift class.
   */
  @inline(__always)
  public func toString() -> String {
    return self.__implementation.toString()
  }

  // Properties
  public final var thisObject: HybridTestObjectSwiftKotlinSpec_cxx {
    @inline(__always)
    get {
      return self.__implementation.thisObject.getCxxWrapper()
    }
  }
  
  public final var optionalHybrid: (any HybridTestObjectSwiftKotlinSpec)? {
    @inline(__always)
    get {
      return self.__implementation.optionalHybrid
    }
    @inline(__always)
    set {
      self.__implementation.optionalHybrid = newValue
    }
  }
  
  public final var numberValue: Double {
    @inline(__always)
    get {
      return self.__implementation.numberValue
    }
    @inline(__always)
    set {
      self.__implementation.numberValue = newValue
    }
  }
  
  public final var boolValue: Bool {
    @inline(__always)
    get {
      return self.__implementation.boolValue
    }
    @inline(__always)
    set {
      self.__implementation.boolValue = newValue
    }
  }
  
  public final var stringValue: String {
    @inline(__always)
    get {
      return self.__implementation.stringValue
    }
    @inline(__always)
    set {
      self.__implementation.stringValue = newValue
    }
  }
  
  public final var bigintValue: Int64 {
    @inline(__always)
    get {
      return self.__implementation.bigintValue
    }
    @inline(__always)
    set {
      self.__implementation.bigintValue = newValue
    }
  }
  
  public final var nullValue: NullType {
    @inline(__always)
    get {
      return self.__implementation.nullValue
    }
    @inline(__always)
    set {
      self.__implementation.nullValue = newValue
    }
  }
  
  public final var optionalString: String? {
    @inline(__always)
    get {
      return self.__implementation.optionalString
    }
    @inline(__always)
    set {
      self.__implementation.optionalString = newValue
    }
  }
  
  public final var stringOrUndefined: String? {
    @inline(__always)
    get {
      return self.__implementation.stringOrUndefined
    }
    @inline(__always)
    set {
      self.__implementation.stringOrUndefined = newValue
    }
  }
  
  public final var stringOrNull: Variant_NullType_String {
    @inline(__always)
    get {
      return self.__implementation.stringOrNull
    }
    @inline(__always)
    set {
      self.__implementation.stringOrNull = newValue
    }
  }
  
  public final var optionalArray: [String]? {
    @inline(__always)
    get {
      return self.__implementation.optionalArray
    }
    @inline(__always)
    set {
      self.__implementation.optionalArray = newValue
    }
  }
  
  public final var optionalEnum: Powertrain? {
    @inline(__always)
    get {
      return self.__implementation.optionalEnum
    }
    @inline(__always)
    set {
      self.__implementation.optionalEnum = newValue
    }
  }
  
  public final var optionalOldEnum: OldEnum? {
    @inline(__always)
    get {
      return self.__implementation.optionalOldEnum
    }
    @inline(__always)
    set {
      self.__implementation.optionalOldEnum = newValue
    }
  }
  
  public final var optionalCallback: ((_ value: Double) -> Void)? {
    @inline(__always)
    get {
      return self.__implementation.optionalCallback
    }
    @inline(__always)
    set {
      self.__implementation.optionalCallback = newValue
    }
  }
  
  public final var someVariant: Variant_String_Double {
    @inline(__always)
    get {
      return self.__implementation.someVariant
    }
    @inline(__always)
    set {
      self.__implementation.someVariant = newValue
    }
  }

  // Methods
  @inline(__always)
  public final func newTestObject() -> HybridTestObjectSwiftKotlinSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.newTestObject()
    return __result.getCxxWrapper()
  }
  
  @inline(__always)
  public final func getVariantHybrid(variant: Variant__any_HybridTestObjectSwiftKotlinSpec__Person) -> Variant__any_HybridTestObjectSwiftKotlinSpec__Person {
    // TODO: Remove try!
    let __result = try! self.__implementation.getVariantHybrid(variant: variant)
    return __result
  }
  
  @inline(__always)
  public final func simpleFunc() -> Void {
    // TODO: Remove try!
    try! self.__implementation.simpleFunc()
  }
  
  @inline(__always)
  public final func addNumbers(a: Double, b: Double) -> Double {
    // TODO: Remove try!
    let __result = try! self.__implementation.addNumbers(a: a, b: b)
    return __result
  }
  
  @inline(__always)
  public final func addStrings(a: String, b: String) -> String {
    // TODO: Remove try!
    let __result = try! self.__implementation.addStrings(a: a, b: b)
    return __result
  }
  
  @inline(__always)
  public final func multipleArguments(num: Double, str: String, boo: Bool) -> Void {
    // TODO: Remove try!
    try! self.__implementation.multipleArguments(num: num, str: str, boo: boo)
  }
  
  @inline(__always)
  public final func bounceNull(value: NullType) -> NullType {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceNull(value: value)
    return __result
  }
  
  @inline(__always)
  public final func bounceStrings(array: [String]) -> [String] {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceStrings(array: array)
    return __result
  }
  
  @inline(__always)
  public final func bounceNumbers(array: [Double]) -> [Double] {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceNumbers(array: array)
    return __result
  }
  
  @inline(__always)
  public final func bounceStructs(array: [Person]) -> [Person] {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceStructs(array: array)
    return __result
  }
  
  @inline(__always)
  public final func bouncePartialStruct(person: PartialPerson) -> PartialPerson {
    // TODO: Remove try!
    let __result = try! self.__implementation.bouncePartialStruct(person: person)
    return __result
  }
  
  @inline(__always)
  public final func sumUpAllPassengers(cars: [Car]) -> String {
    // TODO: Remove try!
    let __result = try! self.__implementation.sumUpAllPassengers(cars: cars)
    return __result
  }
  
  @inline(__always)
  public final func bounceEnums(array: [Powertrain]) -> [Powertrain] {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceEnums(array: array)
    return __result
  }
  
  @inline(__always)
  public final func complexEnumCallback(array: [Powertrain], callback: Func__Powertrain__Void) -> Void {
    // TODO: Remove try!
    try! self.__implementation.complexEnumCallback(array: array, callback: callback.closure)
  }
  
  @inline(__always)
  public final func bounceHybridObjects(array: [HybridChildSpec_cxx]) -> [HybridChildSpec_cxx] {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceHybridObjects(array: array)
    return __result
  }
  
  @inline(__always)
  public final func bounceFunctions(functions: [Func_Void]) -> [Func_Void] {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceFunctions(functions: functions)
    return __result
  }
  
  @inline(__always)
  public final func bounceMaps(maps: [margelo.nitro.SwiftAnyMap]) -> [margelo.nitro.SwiftAnyMap] {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceMaps(maps: maps)
    return __result
  }
  
  @inline(__always)
  public final func bouncePromises(promises: [Promise<Double>]) -> [Promise<Double>] {
    // TODO: Remove try!
    let __result = try! self.__implementation.bouncePromises(promises: promises)
    return __result
  }
  
  @inline(__always)
  public final func bounceArrayBuffers(arrayBuffers: [ArrayBuffer]) -> [ArrayBuffer] {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceArrayBuffers(arrayBuffers: arrayBuffers)
    return __result
  }
  
  @inline(__always)
  public final func createMap() -> margelo.nitro.SwiftAnyMap {
    // TODO: Remove try!
    let __result = try! self.__implementation.createMap()
    return margelo.nitro.SwiftAnyMap(__result)
  }
  
  @inline(__always)
  public final func mapRoundtrip(map: margelo.nitro.SwiftAnyMap) -> margelo.nitro.SwiftAnyMap {
    // TODO: Remove try!
    let __result = try! self.__implementation.mapRoundtrip(map: map.getSwiftPart())
    return margelo.nitro.SwiftAnyMap(__result)
  }
  
  @inline(__always)
  public final func getMapKeys(map: margelo.nitro.SwiftAnyMap) -> [String] {
    // TODO: Remove try!
    let __result = try! self.__implementation.getMapKeys(map: map.getSwiftPart())
    return __result
  }
  
  @inline(__always)
  public final func mergeMaps(a: margelo.nitro.SwiftAnyMap, b: margelo.nitro.SwiftAnyMap) -> margelo.nitro.SwiftAnyMap {
    // TODO: Remove try!
    let __result = try! self.__implementation.mergeMaps(a: a.getSwiftPart(), b: b.getSwiftPart())
    return margelo.nitro.SwiftAnyMap(__result)
  }
  
  @inline(__always)
  public final func copyAnyMap(map: margelo.nitro.SwiftAnyMap) -> margelo.nitro.SwiftAnyMap {
    // TODO: Remove try!
    let __result = try! self.__implementation.copyAnyMap(map: map.getSwiftPart())
    return margelo.nitro.SwiftAnyMap(__result)
  }
  
  @inline(__always)
  public final func bounceMap(map: Dictionary<String, Variant_Bool_Double>) -> Dictionary<String, Variant_Bool_Double> {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceMap(map: map)
    return __result
  }
  
  @inline(__always)
  public final func bounceSimpleMap(map: Dictionary<String, Double>) -> Dictionary<String, Double> {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceSimpleMap(map: map)
    return __result
  }
  
  @inline(__always)
  public final func extractMap(mapWrapper: MapWrapper) -> Dictionary<String, String> {
    // TODO: Remove try!
    let __result = try! self.__implementation.extractMap(mapWrapper: mapWrapper)
    return __result
  }
  
  @inline(__always)
  public final func funcThatThrows() -> Double {
    // TODO: Remove try!
    let __result = try! self.__implementation.funcThatThrows()
    return __result
  }
  
  @inline(__always)
  public final func funcThatThrowsBeforePromise() -> Promise<Void> {
    // TODO: Remove try!
    let __result = try! self.__implementation.funcThatThrowsBeforePromise()
    return __result
  }
  
  @inline(__always)
  public final func throwError(error: Error) -> Void {
    // TODO: Remove try!
    try! self.__implementation.throwError(error: error)
  }
  
  @inline(__always)
  public final func tryOptionalParams(num: Double, boo: Bool, str: String?) -> String {
    // TODO: Remove try!
    let __result = try! self.__implementation.tryOptionalParams(num: num, boo: boo, str: str)
    return __result
  }
  
  @inline(__always)
  public final func tryMiddleParam(num: Double, boo: Bool?, str: String) -> String {
    // TODO: Remove try!
    let __result = try! self.__implementation.tryMiddleParam(num: num, boo: boo, str: str)
    return __result
  }
  
  @inline(__always)
  public final func tryOptionalEnum(value: Powertrain?) -> Powertrain? {
    // TODO: Remove try!
    let __result = try! self.__implementation.tryOptionalEnum(value: value)
    return __result
  }
  
  @inline(__always)
  public final func tryTrailingOptional(num: Double, str: String, boo: Bool?) -> Bool {
    // TODO: Remove try!
    let __result = try! self.__implementation.tryTrailingOptional(num: num, str: str, boo: boo)
    return __result
  }
  
  @inline(__always)
  public final func add1Hour(date: Date) -> Date {
    // TODO: Remove try!
    let __result = try! self.__implementation.add1Hour(date: date)
    return __result
  }
  
  @inline(__always)
  public final func currentDate() -> Date {
    // TODO: Remove try!
    let __result = try! self.__implementation.currentDate()
    return __result
  }
  
  @inline(__always)
  public final func calculateFibonacciSync(value: Double) -> Int64 {
    // TODO: Remove try!
    let __result = try! self.__implementation.calculateFibonacciSync(value: value)
    return __result
  }
  
  @inline(__always)
  public final func calculateFibonacciAsync(value: Double) -> Promise<Int64> {
    // TODO: Remove try!
    let __result = try! self.__implementation.calculateFibonacciAsync(value: value)
    return __result
  }
  
  @inline(__always)
  public final func wait(seconds: Double) -> Promise<Void> {
    // TODO: Remove try!
    let __result = try! self.__implementation.wait(seconds: seconds)
    return __result
  }
  
  @inline(__always)
  public final func promiseThrows() -> Promise<Void> {
    // TODO: Remove try!
    let __result = try! self.__implementation.promiseThrows()
    return __result
  }
  
  @inline(__always)
  public final func promiseReturnsInstantly() -> Promise<Double> {
    // TODO: Remove try!
    let __result = try! self.__implementation.promiseReturnsInstantly()
    return __result
  }
  
  @inline(__always)
  public final func promiseReturnsInstantlyAsync() -> Promise<Double> {
    // TODO: Remove try!
    let __result = try! self.__implementation.promiseReturnsInstantlyAsync()
    return __result
  }
  
  @inline(__always)
  public final func promiseThatResolvesVoidInstantly() -> Promise<Void> {
    // TODO: Remove try!
    let __result = try! self.__implementation.promiseThatResolvesVoidInstantly()
    return __result
  }
  
  @inline(__always)
  public final func promiseThatResolvesToUndefined() -> Promise<Double?> {
    // TODO: Remove try!
    let __result = try! self.__implementation.promiseThatResolvesToUndefined()
    return __result
  }
  
  @inline(__always)
  public final func awaitAndGetPromise(promise: Promise<Double>) -> Promise<Double> {
    // TODO: Remove try!
    let __result = try! self.__implementation.awaitAndGetPromise(promise: promise)
    return __result
  }
  
  @inline(__always)
  public final func awaitAndGetComplexPromise(promise: Promise<Car>) -> Promise<Car> {
    // TODO: Remove try!
    let __result = try! self.__implementation.awaitAndGetComplexPromise(promise: promise)
    return __result
  }
  
  @inline(__always)
  public final func awaitPromise(promise: Promise<Void>) -> Promise<Void> {
    // TODO: Remove try!
    let __result = try! self.__implementation.awaitPromise(promise: promise)
    return __result
  }
  
  @inline(__always)
  public final func callCallback(callback: Func_Void) -> Void {
    // TODO: Remove try!
    try! self.__implementation.callCallback(callback: callback.closure)
  }
  
  @inline(__always)
  public final func callCallbackThatReturnsPromiseVoid(callback: Func_Promise_Promise_Void__) -> Promise<Void> {
    // TODO: Remove try!
    let __result = try! self.__implementation.callCallbackThatReturnsPromiseVoid(callback: callback.closure)
    return __result
  }
  
  @inline(__always)
  public final func callAll(first: Func_Void, second: Func_Void, third: Func_Void) -> Void {
    // TODO: Remove try!
    try! self.__implementation.callAll(first: first.closure, second: second.closure, third: third.closure)
  }
  
  @inline(__always)
  public final func callWithOptional(value: Double?, callback: Func_Double__Void) -> Void {
    // TODO: Remove try!
    try! self.__implementation.callWithOptional(value: value, callback: callback.closure)
  }
  
  @inline(__always)
  public final func callSumUpNTimes(callback: Func_Promise_Double_, n: Double) -> Promise<Double> {
    // TODO: Remove try!
    let __result = try! self.__implementation.callSumUpNTimes(callback: callback.closure, n: n)
    return __result
  }
  
  @inline(__always)
  public final func callbackAsyncPromise(callback: Func_Promise_Promise_Double__) -> Promise<Double> {
    // TODO: Remove try!
    let __result = try! self.__implementation.callbackAsyncPromise(callback: callback.closure)
    return __result
  }
  
  @inline(__always)
  public final func callbackAsyncPromiseBuffer(callback: Func_Promise_Promise_ArrayBuffer__) -> Promise<ArrayBuffer> {
    // TODO: Remove try!
    let __result = try! self.__implementation.callbackAsyncPromiseBuffer(callback: callback.closure)
    return __result
  }
  
  @inline(__always)
  public final func getComplexCallback() -> Func_Double_Void {
    // TODO: Remove try!
    let __result = try! self.__implementation.getComplexCallback()
    return Func_Double_Void(__result)
  }
  
  @inline(__always)
  public final func twoOptionalCallbacks(value: Double, first: ((_ value: Double) -> Void)?, second: ((_ value: String) -> Void)?) -> Void {
    // TODO: Remove try!
    try! self.__implementation.twoOptionalCallbacks(value: value, first: first, second: second)
  }
  
  @inline(__always)
  public final func errorCallback(onError: Func_Error_Void) -> Void {
    // TODO: Remove try!
    try! self.__implementation.errorCallback(onError: onError.closure)
  }
  
  @inline(__always)
  public final func createNativeCallback(wrappingJsCallback: Func_Double_Void) -> Func_Double_Void {
    // TODO: Remove try!
    let __result = try! self.__implementation.createNativeCallback(wrappingJsCallback: wrappingJsCallback.closure)
    return Func_Double_Void(__result)
  }
  
  @inline(__always)
  public final func getValueFromJSCallbackAndWait(getValue: Func_Promise_Double_) -> Promise<Double> {
    // TODO: Remove try!
    let __result = try! self.__implementation.getValueFromJSCallbackAndWait(getValue: getValue.closure)
    return __result
  }
  
  @inline(__always)
  public final func getValueFromJsCallback(callback: Func_Promise_String_, andThenCall: Func_String_Void) -> Promise<Void> {
    // TODO: Remove try!
    let __result = try! self.__implementation.getValueFromJsCallback(callback: callback.closure, andThenCall: andThenCall.closure)
    return __result
  }
  
  @inline(__always)
  public final func getCar() -> Car {
    // TODO: Remove try!
    let __result = try! self.__implementation.getCar()
    return __result
  }
  
  @inline(__always)
  public final func isCarElectric(car: Car) -> Bool {
    // TODO: Remove try!
    let __result = try! self.__implementation.isCarElectric(car: car)
    return __result
  }
  
  @inline(__always)
  public final func getDriver(car: Car) -> Person? {
    // TODO: Remove try!
    let __result = try! self.__implementation.getDriver(car: car)
    return __result
  }
  
  @inline(__always)
  public final func bounceCar(car: Car) -> Car {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceCar(car: car)
    return __result
  }
  
  @inline(__always)
  public final func jsStyleObjectAsParameters(params: JsStyleStruct) -> Void {
    // TODO: Remove try!
    try! self.__implementation.jsStyleObjectAsParameters(params: params)
  }
  
  @inline(__always)
  public final func bounceWrappedJsStyleStruct(value: WrappedJsStruct) -> WrappedJsStruct {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceWrappedJsStyleStruct(value: value)
    return __result
  }
  
  @inline(__always)
  public final func bounceOptionalWrapper(wrapper: OptionalWrapper) -> OptionalWrapper {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceOptionalWrapper(wrapper: wrapper)
    return __result
  }
  
  @inline(__always)
  public final func bounceOptionalCallback(value: OptionalCallback) -> OptionalCallback {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceOptionalCallback(value: value)
    return __result
  }
  
  @inline(__always)
  public final func createArrayBuffer() -> ArrayBuffer {
    // TODO: Remove try!
    let __result = try! self.__implementation.createArrayBuffer()
    return __result
  }
  
  @inline(__always)
  public final func createArrayBufferFromNativeBuffer(copy: Bool) -> ArrayBuffer {
    // TODO: Remove try!
    let __result = try! self.__implementation.createArrayBufferFromNativeBuffer(copy: copy)
    return __result
  }
  
  @inline(__always)
  public final func copyBuffer(buffer: ArrayBuffer) -> ArrayBuffer {
    // TODO: Remove try!
    let __result = try! self.__implementation.copyBuffer(buffer: buffer)
    return __result
  }
  
  @inline(__always)
  public final func getBufferLastItem(buffer: ArrayBuffer) -> Double {
    // TODO: Remove try!
    let __result = try! self.__implementation.getBufferLastItem(buffer: buffer)
    return __result
  }
  
  @inline(__always)
  public final func setAllValuesTo(buffer: ArrayBuffer, value: Double) -> Void {
    // TODO: Remove try!
    try! self.__implementation.setAllValuesTo(buffer: buffer, value: value)
  }
  
  @inline(__always)
  public final func createArrayBufferAsync() -> Promise<ArrayBuffer> {
    // TODO: Remove try!
    let __result = try! self.__implementation.createArrayBufferAsync()
    return __result
  }
  
  @inline(__always)
  public final func bounceArrayBuffer(buffer: ArrayBuffer) -> ArrayBuffer {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceArrayBuffer(buffer: buffer)
    return __result
  }
  
  @inline(__always)
  public final func passVariant(either: Variant_Bool__Double___String__String_Double) -> Variant_String_Double {
    // TODO: Remove try!
    let __result = try! self.__implementation.passVariant(either: either)
    return __result
  }
  
  @inline(__always)
  public final func getVariantEnum(variant: Variant_Bool_OldEnum) -> Variant_Bool_OldEnum {
    // TODO: Remove try!
    let __result = try! self.__implementation.getVariantEnum(variant: variant)
    return __result
  }
  
  @inline(__always)
  public final func getVariantWeirdNumbersEnum(variant: Variant_Bool_WeirdNumbersEnum) -> Variant_Bool_WeirdNumbersEnum {
    // TODO: Remove try!
    let __result = try! self.__implementation.getVariantWeirdNumbersEnum(variant: variant)
    return __result
  }
  
  @inline(__always)
  public final func getVariantObjects(variant: Variant_Car_Person) -> Variant_Car_Person {
    // TODO: Remove try!
    let __result = try! self.__implementation.getVariantObjects(variant: variant)
    return __result
  }
  
  @inline(__always)
  public final func passNamedVariant(variant: NamedVariant) -> NamedVariant {
    // TODO: Remove try!
    let __result = try! self.__implementation.passNamedVariant(variant: variant)
    return __result
  }
  
  @inline(__always)
  public final func passAllEmptyObjectVariant(variant: Variant__any_HybridBaseSpec__OptionalWrapper) -> Variant__any_HybridBaseSpec__OptionalWrapper {
    // TODO: Remove try!
    let __result = try! self.__implementation.passAllEmptyObjectVariant(variant: variant)
    return __result
  }
  
  @inline(__always)
  public final func bounceComplexVariant(variant: CoreTypesVariant) -> CoreTypesVariant {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceComplexVariant(variant: variant)
    return __result
  }
  
  @inline(__always)
  public final func createChild() -> HybridChildSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.createChild()
    return __result.getCxxWrapper()
  }
  
  @inline(__always)
  public final func createBase() -> HybridBaseSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.createBase()
    return __result.getCxxWrapper()
  }
  
  @inline(__always)
  public final func createBaseActualChild() -> HybridBaseSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.createBaseActualChild()
    return __result.getCxxWrapper()
  }
  
  @inline(__always)
  public final func bounceChild(child: HybridChildSpec_cxx) -> HybridChildSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceChild(child: child.getHybridChildSpec())
    return __result.getCxxWrapper()
  }
  
  @inline(__always)
  public final func bounceBase(base: HybridBaseSpec_cxx) -> HybridBaseSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceBase(base: base.getHybridBaseSpec())
    return __result.getCxxWrapper()
  }
  
  @inline(__always)
  public final func bounceChildBase(child: HybridChildSpec_cxx) -> HybridBaseSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceChildBase(child: child.getHybridChildSpec())
    return __result.getCxxWrapper()
  }
  
  @inline(__always)
  public final func castBase(base: HybridBaseSpec_cxx) -> HybridChildSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.castBase(base: base.getHybridBaseSpec())
    return __result.getCxxWrapper()
  }
  
  @inline(__always)
  public final func callbackSync(callback: Func_Double) -> Double {
    // TODO: Remove try!
    let __result = try! self.__implementation.callbackSync(callback: callback.closure)
    return __result
  }
  
  @inline(__always)
  public final func getIsViewBlue(view: HybridTestViewSpec_cxx) -> Bool {
    // TODO: Remove try!
    let __result = try! self.__implementation.getIsViewBlue(view: view.getHybridTestViewSpec())
    return __result
  }
  
  @inline(__always)
  public final func bounceExternalHybrid(externalObject: HybridSomeExternalObjectSpec_cxx) -> HybridSomeExternalObjectSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceExternalHybrid(externalObject: externalObject.getHybridSomeExternalObjectSpec())
    return __result.getCxxWrapper()
  }
  
  @inline(__always)
  public final func createInternalObject() -> HybridSomeExternalObjectSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.createInternalObject()
    return __result.getCxxWrapper()
  }
  
  @inline(__always)
  public final func bounceExternalStruct(externalStruct: ExternalObjectStruct) -> ExternalObjectStruct {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceExternalStruct(externalStruct: externalStruct)
    return __result
  }
  
  @inline(__always)
  public final func bounceExternalVariant(variant: StringOrExternal) -> StringOrExternal {
    // TODO: Remove try!
    let __result = try! self.__implementation.bounceExternalVariant(variant: variant)
    return __result
  }
  
  @inline(__always)
  public final func createExternalVariantFromFunc(factory: Func__any_HybridSomeExternalObjectSpec_) -> HybridSomeExternalObjectSpec_cxx {
    // TODO: Remove try!
    let __result = try! self.__implementation.createExternalVariantFromFunc(factory: factory.closure)
    return __result.getCxxWrapper()
  }
}
