///
/// HybridTestObjectSwiftKotlinSpec_cxx.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

import Foundation
import NitroModules
import NitroTestExternal

/**
 * A class implementation that bridges HybridTestObjectSwiftKotlinSpec over to C++.
 * In C++, we cannot use Swift protocols - so we need to wrap it in a class to make it strongly defined.
 *
 * Also, some Swift types need to be bridged with special handling:
 * - Enums need to be wrapped in Structs, otherwise they cannot be accessed bi-directionally (Swift bug: https://github.com/swiftlang/swift/issues/75330)
 * - Other HybridObjects need to be wrapped/unwrapped from the Swift TCxx wrapper
 * - Throwing methods need to be wrapped with a Result<T, Error> type, as exceptions cannot be propagated to C++
 */
open class HybridTestObjectSwiftKotlinSpec_cxx {
  /**
   * The Swift <> C++ bridge's namespace (`margelo::nitro::test::bridge::swift`)
   * from `NitroTest-Swift-Cxx-Bridge.hpp`.
   * This contains specialized C++ templates, and C++ helper functions that can be accessed from Swift.
   */
  public typealias bridge = margelo.nitro.test.bridge.swift

  /**
   * Holds an instance of the `HybridTestObjectSwiftKotlinSpec` Swift protocol.
   */
  private var __implementation: any HybridTestObjectSwiftKotlinSpec

  /**
   * Holds a weak pointer to the C++ class that wraps the Swift class.
   */
  private var __cxxPart: bridge.std__weak_ptr_HybridTestObjectSwiftKotlinSpec_

  /**
   * Create a new `HybridTestObjectSwiftKotlinSpec_cxx` that wraps the given `HybridTestObjectSwiftKotlinSpec`.
   * All properties and methods bridge to C++ types.
   */
  public init(_ implementation: any HybridTestObjectSwiftKotlinSpec) {
    self.__implementation = implementation
    self.__cxxPart = .init()
    /* no base class */
  }

  /**
   * Get the actual `HybridTestObjectSwiftKotlinSpec` instance this class wraps.
   */
  @inline(__always)
  public func getHybridTestObjectSwiftKotlinSpec() -> any HybridTestObjectSwiftKotlinSpec {
    return __implementation
  }

  /**
   * Casts this instance to a retained unsafe raw pointer.
   * This acquires one additional strong reference on the object!
   */
  public func toUnsafe() -> UnsafeMutableRawPointer {
    return Unmanaged.passRetained(self).toOpaque()
  }

  /**
   * Casts an unsafe pointer to a `HybridTestObjectSwiftKotlinSpec_cxx`.
   * The pointer has to be a retained opaque `Unmanaged<HybridTestObjectSwiftKotlinSpec_cxx>`.
   * This removes one strong reference from the object!
   */
  public class func fromUnsafe(_ pointer: UnsafeMutableRawPointer) -> HybridTestObjectSwiftKotlinSpec_cxx {
    return Unmanaged<HybridTestObjectSwiftKotlinSpec_cxx>.fromOpaque(pointer).takeRetainedValue()
  }

  /**
   * Gets (or creates) the C++ part of this Hybrid Object.
   * The C++ part is a `std::shared_ptr<HybridTestObjectSwiftKotlinSpec>`.
   */
  public func getCxxPart() -> bridge.std__shared_ptr_HybridTestObjectSwiftKotlinSpec_ {
    let cachedCxxPart = self.__cxxPart.lock()
    if Bool(fromCxx: cachedCxxPart) {
      return cachedCxxPart
    } else {
      let newCxxPart = bridge.create_std__shared_ptr_HybridTestObjectSwiftKotlinSpec_(self.toUnsafe())
      __cxxPart = bridge.weakify_std__shared_ptr_HybridTestObjectSwiftKotlinSpec_(newCxxPart)
      return newCxxPart
    }
  }

  

  /**
   * Get the memory size of the Swift class (plus size of any other allocations)
   * so the JS VM can properly track it and garbage-collect the JS object if needed.
   */
  @inline(__always)
  public var memorySize: Int {
    return MemoryHelper.getSizeOf(self.__implementation) + self.__implementation.memorySize
  }

  /**
   * Compares this object with the given [other] object for reference equality.
   */
  @inline(__always)
  public func equals(other: HybridTestObjectSwiftKotlinSpec_cxx) -> Bool {
    return self.__implementation === other.__implementation
  }

  /**
   * Call dispose() on the Swift class.
   * This _may_ be called manually from JS.
   */
  @inline(__always)
  public func dispose() {
    self.__implementation.dispose()
  }

  /**
   * Call toString() on the Swift class.
   */
  @inline(__always)
  public func toString() -> String {
    return self.__implementation.toString()
  }

  // Properties
  public final var thisObject: (any HybridTestObjectSwiftKotlinSpec) {
    @inline(__always)
    get {
      return self.__implementation.thisObject
    }
  }
  
  public final var optionalHybrid: (any HybridTestObjectSwiftKotlinSpec)? {
    @inline(__always)
    get {
      return self.__implementation.optionalHybrid
    }
    @inline(__always)
    set {
      self.__implementation.optionalHybrid = newValue
    }
  }
  
  public final var numberValue: Double {
    @inline(__always)
    get {
      return self.__implementation.numberValue
    }
    @inline(__always)
    set {
      self.__implementation.numberValue = newValue
    }
  }
  
  public final var boolValue: Bool {
    @inline(__always)
    get {
      return self.__implementation.boolValue
    }
    @inline(__always)
    set {
      self.__implementation.boolValue = newValue
    }
  }
  
  public final var stringValue: String {
    @inline(__always)
    get {
      return self.__implementation.stringValue
    }
    @inline(__always)
    set {
      self.__implementation.stringValue = newValue
    }
  }
  
  public final var bigintValue: Int64 {
    @inline(__always)
    get {
      return self.__implementation.bigintValue
    }
    @inline(__always)
    set {
      self.__implementation.bigintValue = newValue
    }
  }
  
  public final var nullValue: NullType {
    @inline(__always)
    get {
      return self.__implementation.nullValue
    }
    @inline(__always)
    set {
      self.__implementation.nullValue = newValue
    }
  }
  
  public final var optionalString: String? {
    @inline(__always)
    get {
      return self.__implementation.optionalString
    }
    @inline(__always)
    set {
      self.__implementation.optionalString = newValue
    }
  }
  
  public final var stringOrUndefined: String? {
    @inline(__always)
    get {
      return self.__implementation.stringOrUndefined
    }
    @inline(__always)
    set {
      self.__implementation.stringOrUndefined = newValue
    }
  }
  
  public final var stringOrNull: Variant_NullType_String {
    @inline(__always)
    get {
      return self.__implementation.stringOrNull
    }
    @inline(__always)
    set {
      self.__implementation.stringOrNull = newValue
    }
  }
  
  public final var optionalArray: [String]? {
    @inline(__always)
    get {
      return self.__implementation.optionalArray
    }
    @inline(__always)
    set {
      self.__implementation.optionalArray = newValue
    }
  }
  
  public final var optionalEnum: Powertrain? {
    @inline(__always)
    get {
      return self.__implementation.optionalEnum
    }
    @inline(__always)
    set {
      self.__implementation.optionalEnum = newValue
    }
  }
  
  public final var optionalOldEnum: OldEnum? {
    @inline(__always)
    get {
      return self.__implementation.optionalOldEnum
    }
    @inline(__always)
    set {
      self.__implementation.optionalOldEnum = newValue
    }
  }
  
  public final var optionalCallback: ((_ value: Double) -> Void)? {
    @inline(__always)
    get {
      return self.__implementation.optionalCallback
    }
    @inline(__always)
    set {
      self.__implementation.optionalCallback = newValue
    }
  }
  
  public final var someVariant: Variant_String_Double {
    @inline(__always)
    get {
      return self.__implementation.someVariant
    }
    @inline(__always)
    set {
      self.__implementation.someVariant = newValue
    }
  }

  // Methods
  @inline(__always)
  public final func newTestObject() -> (any HybridTestObjectSwiftKotlinSpec) {
    do {
      let __result = try self.__implementation.newTestObject()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_HybridTestObjectSwiftKotlinSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_HybridTestObjectSwiftKotlinSpec__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getVariantHybrid(variant: Variant__any_HybridTestObjectSwiftKotlinSpec__Person) -> Variant__any_HybridTestObjectSwiftKotlinSpec__Person {
    do {
      let __result = try self.__implementation.getVariantHybrid(variant: variant)
      let __resultCpp = __result
      return bridge.create_Result_std__variant_std__shared_ptr_HybridTestObjectSwiftKotlinSpec___Person__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__variant_std__shared_ptr_HybridTestObjectSwiftKotlinSpec___Person__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func simpleFunc() -> Void {
    do {
      try self.__implementation.simpleFunc()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func addNumbers(a: Double, b: Double) -> Double {
    do {
      let __result = try self.__implementation.addNumbers(a: a, b: b)
      let __resultCpp = __result
      return bridge.create_Result_double_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_double_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func addStrings(a: String, b: String) -> String {
    do {
      let __result = try self.__implementation.addStrings(a: a, b: b)
      let __resultCpp = __result
      return bridge.create_Result_std__string_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__string_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func multipleArguments(num: Double, str: String, boo: Bool) -> Void {
    do {
      try self.__implementation.multipleArguments(num: num, str: str, boo: boo)
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceNull(value: NullType) -> NullType {
    do {
      let __result = try self.__implementation.bounceNull(value: value)
      let __resultCpp = __result
      return bridge.create_Result_nitro__NullType_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_nitro__NullType_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceStrings(array: [String]) -> [String] {
    do {
      let __result = try self.__implementation.bounceStrings(array: array)
      let __resultCpp = __result
      return bridge.create_Result_std__vector_std__string__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__vector_std__string__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceNumbers(array: [Double]) -> [Double] {
    do {
      let __result = try self.__implementation.bounceNumbers(array: array)
      let __resultCpp = __result
      return bridge.create_Result_std__vector_double__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__vector_double__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceStructs(array: [Person]) -> [Person] {
    do {
      let __result = try self.__implementation.bounceStructs(array: array)
      let __resultCpp = __result
      return bridge.create_Result_std__vector_Person__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__vector_Person__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bouncePartialStruct(person: PartialPerson) -> PartialPerson {
    do {
      let __result = try self.__implementation.bouncePartialStruct(person: person)
      let __resultCpp = __result
      return bridge.create_Result_PartialPerson_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_PartialPerson_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func sumUpAllPassengers(cars: [Car]) -> String {
    do {
      let __result = try self.__implementation.sumUpAllPassengers(cars: cars)
      let __resultCpp = __result
      return bridge.create_Result_std__string_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__string_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceEnums(array: [Powertrain]) -> [Powertrain] {
    do {
      let __result = try self.__implementation.bounceEnums(array: array)
      let __resultCpp = __result
      return bridge.create_Result_std__vector_Powertrain__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__vector_Powertrain__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func complexEnumCallback(array: [Powertrain], callback: Func__Powertrain__Void) -> Void {
    do {
      try self.__implementation.complexEnumCallback(array: array, callback: callback.closure)
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceHybridObjects(array: [(any HybridChildSpec)]) -> [(any HybridChildSpec)] {
    do {
      let __result = try self.__implementation.bounceHybridObjects(array: array)
      let __resultCpp = __result
      return bridge.create_Result_std__vector_std__shared_ptr_HybridChildSpec___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__vector_std__shared_ptr_HybridChildSpec___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceFunctions(functions: [() -> Void]) -> [() -> Void] {
    do {
      let __result = try self.__implementation.bounceFunctions(functions: functions)
      let __resultCpp = __result
      return bridge.create_Result_std__vector_std__function_void_____(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__vector_std__function_void_____(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceMaps(maps: [AnyMap]) -> [AnyMap] {
    do {
      let __result = try self.__implementation.bounceMaps(maps: maps)
      let __resultCpp = __result
      return bridge.create_Result_std__vector_std__shared_ptr_AnyMap___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__vector_std__shared_ptr_AnyMap___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bouncePromises(promises: [Promise<Double>]) -> [Promise<Double>] {
    do {
      let __result = try self.__implementation.bouncePromises(promises: promises)
      let __resultCpp = __result
      return bridge.create_Result_std__vector_std__shared_ptr_Promise_double____(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__vector_std__shared_ptr_Promise_double____(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceArrayBuffers(arrayBuffers: [ArrayBuffer]) -> [ArrayBuffer] {
    do {
      let __result = try self.__implementation.bounceArrayBuffers(arrayBuffers: arrayBuffers)
      let __resultCpp = __result
      return bridge.create_Result_std__vector_std__shared_ptr_ArrayBuffer___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__vector_std__shared_ptr_ArrayBuffer___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createMap() -> AnyMap {
    do {
      let __result = try self.__implementation.createMap()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_AnyMap__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_AnyMap__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func mapRoundtrip(map: AnyMap) -> AnyMap {
    do {
      let __result = try self.__implementation.mapRoundtrip(map: map)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_AnyMap__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_AnyMap__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getMapKeys(map: AnyMap) -> [String] {
    do {
      let __result = try self.__implementation.getMapKeys(map: map)
      let __resultCpp = __result
      return bridge.create_Result_std__vector_std__string__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__vector_std__string__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func mergeMaps(a: AnyMap, b: AnyMap) -> AnyMap {
    do {
      let __result = try self.__implementation.mergeMaps(a: a, b: b)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_AnyMap__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_AnyMap__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func copyAnyMap(map: AnyMap) -> AnyMap {
    do {
      let __result = try self.__implementation.copyAnyMap(map: map)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_AnyMap__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_AnyMap__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceMap(map: Dictionary<String, Variant_Bool_Double>) -> Dictionary<String, Variant_Bool_Double> {
    do {
      let __result = try self.__implementation.bounceMap(map: map)
      let __resultCpp = __result
      return bridge.create_Result_std__unordered_map_std__string__std__variant_bool__double___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__unordered_map_std__string__std__variant_bool__double___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceSimpleMap(map: Dictionary<String, Double>) -> Dictionary<String, Double> {
    do {
      let __result = try self.__implementation.bounceSimpleMap(map: map)
      let __resultCpp = __result
      return bridge.create_Result_std__unordered_map_std__string__double__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__unordered_map_std__string__double__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func extractMap(mapWrapper: MapWrapper) -> Dictionary<String, String> {
    do {
      let __result = try self.__implementation.extractMap(mapWrapper: mapWrapper)
      let __resultCpp = __result
      return bridge.create_Result_std__unordered_map_std__string__std__string__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__unordered_map_std__string__std__string__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func funcThatThrows() -> Double {
    do {
      let __result = try self.__implementation.funcThatThrows()
      let __resultCpp = __result
      return bridge.create_Result_double_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_double_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func funcThatThrowsBeforePromise() -> Promise<Void> {
    do {
      let __result = try self.__implementation.funcThatThrowsBeforePromise()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_void___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_void___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func throwError(error: Error) -> Void {
    do {
      try self.__implementation.throwError(error: error)
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func tryOptionalParams(num: Double, boo: Bool, str: String?) -> String {
    do {
      let __result = try self.__implementation.tryOptionalParams(num: num, boo: boo, str: str)
      let __resultCpp = __result
      return bridge.create_Result_std__string_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__string_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func tryMiddleParam(num: Double, boo: Bool?, str: String) -> String {
    do {
      let __result = try self.__implementation.tryMiddleParam(num: num, boo: boo, str: str)
      let __resultCpp = __result
      return bridge.create_Result_std__string_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__string_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func tryOptionalEnum(value: Powertrain?) -> Powertrain? {
    do {
      let __result = try self.__implementation.tryOptionalEnum(value: value)
      let __resultCpp = __result
      return bridge.create_Result_std__optional_Powertrain__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__optional_Powertrain__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func tryTrailingOptional(num: Double, str: String, boo: Bool?) -> Bool {
    do {
      let __result = try self.__implementation.tryTrailingOptional(num: num, str: str, boo: boo)
      let __resultCpp = __result
      return bridge.create_Result_bool_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_bool_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func add1Hour(date: Date) -> Date {
    do {
      let __result = try self.__implementation.add1Hour(date: date)
      let __resultCpp = __result
      return bridge.create_Result_std__chrono__system_clock__time_point_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__chrono__system_clock__time_point_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func currentDate() -> Date {
    do {
      let __result = try self.__implementation.currentDate()
      let __resultCpp = __result
      return bridge.create_Result_std__chrono__system_clock__time_point_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__chrono__system_clock__time_point_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func calculateFibonacciSync(value: Double) -> Int64 {
    do {
      let __result = try self.__implementation.calculateFibonacciSync(value: value)
      let __resultCpp = __result
      return bridge.create_Result_int64_t_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_int64_t_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func calculateFibonacciAsync(value: Double) -> Promise<Int64> {
    do {
      let __result = try self.__implementation.calculateFibonacciAsync(value: value)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_int64_t___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_int64_t___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func wait(seconds: Double) -> Promise<Void> {
    do {
      let __result = try self.__implementation.wait(seconds: seconds)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_void___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_void___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func promiseThrows() -> Promise<Void> {
    do {
      let __result = try self.__implementation.promiseThrows()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_void___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_void___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func promiseReturnsInstantly() -> Promise<Double> {
    do {
      let __result = try self.__implementation.promiseReturnsInstantly()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_double___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_double___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func promiseReturnsInstantlyAsync() -> Promise<Double> {
    do {
      let __result = try self.__implementation.promiseReturnsInstantlyAsync()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_double___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_double___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func promiseThatResolvesVoidInstantly() -> Promise<Void> {
    do {
      let __result = try self.__implementation.promiseThatResolvesVoidInstantly()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_void___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_void___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func promiseThatResolvesToUndefined() -> Promise<Double?> {
    do {
      let __result = try self.__implementation.promiseThatResolvesToUndefined()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_std__optional_double____(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_std__optional_double____(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func awaitAndGetPromise(promise: Promise<Double>) -> Promise<Double> {
    do {
      let __result = try self.__implementation.awaitAndGetPromise(promise: promise)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_double___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_double___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func awaitAndGetComplexPromise(promise: Promise<Car>) -> Promise<Car> {
    do {
      let __result = try self.__implementation.awaitAndGetComplexPromise(promise: promise)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_Car___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_Car___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func awaitPromise(promise: Promise<Void>) -> Promise<Void> {
    do {
      let __result = try self.__implementation.awaitPromise(promise: promise)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_void___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_void___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func callCallback(callback: Func_Void) -> Void {
    do {
      try self.__implementation.callCallback(callback: callback.closure)
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func callCallbackThatReturnsPromiseVoid(callback: Func_Promise_Promise_Void__) -> Promise<Void> {
    do {
      let __result = try self.__implementation.callCallbackThatReturnsPromiseVoid(callback: callback.closure)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_void___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_void___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func callAll(first: Func_Void, second: Func_Void, third: Func_Void) -> Void {
    do {
      try self.__implementation.callAll(first: first.closure, second: second.closure, third: third.closure)
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func callWithOptional(value: Double?, callback: Func_Double__Void) -> Void {
    do {
      try self.__implementation.callWithOptional(value: value, callback: callback.closure)
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func callSumUpNTimes(callback: Func_Promise_Double_, n: Double) -> Promise<Double> {
    do {
      let __result = try self.__implementation.callSumUpNTimes(callback: callback.closure, n: n)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_double___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_double___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func callbackAsyncPromise(callback: Func_Promise_Promise_Double__) -> Promise<Double> {
    do {
      let __result = try self.__implementation.callbackAsyncPromise(callback: callback.closure)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_double___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_double___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func callbackAsyncPromiseBuffer(callback: Func_Promise_Promise_ArrayBuffer__) -> Promise<ArrayBuffer> {
    do {
      let __result = try self.__implementation.callbackAsyncPromiseBuffer(callback: callback.closure)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer____(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer____(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getComplexCallback() -> (_ value: Double) -> Void {
    do {
      let __result = try self.__implementation.getComplexCallback()
      let __resultCpp = Func_Double_Void(__result)
      return bridge.create_Result_std__function_void_double____value______(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__function_void_double____value______(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func twoOptionalCallbacks(value: Double, first: ((_ value: Double) -> Void)?, second: ((_ value: String) -> Void)?) -> Void {
    do {
      try self.__implementation.twoOptionalCallbacks(value: value, first: first, second: second)
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func errorCallback(onError: Func_Error_Void) -> Void {
    do {
      try self.__implementation.errorCallback(onError: onError.closure)
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createNativeCallback(wrappingJsCallback: Func_Double_Void) -> (_ num: Double) -> Void {
    do {
      let __result = try self.__implementation.createNativeCallback(wrappingJsCallback: wrappingJsCallback.closure)
      let __resultCpp = Func_Double_Void(__result)
      return bridge.create_Result_std__function_void_double____num______(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__function_void_double____num______(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getValueFromJSCallbackAndWait(getValue: Func_Promise_Double_) -> Promise<Double> {
    do {
      let __result = try self.__implementation.getValueFromJSCallbackAndWait(getValue: getValue.closure)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_double___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_double___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getValueFromJsCallback(callback: Func_Promise_String_, andThenCall: Func_String_Void) -> Promise<Void> {
    do {
      let __result = try self.__implementation.getValueFromJsCallback(callback: callback.closure, andThenCall: andThenCall.closure)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_void___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_void___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getCar() -> Car {
    do {
      let __result = try self.__implementation.getCar()
      let __resultCpp = __result
      return bridge.create_Result_Car_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_Car_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func isCarElectric(car: Car) -> Bool {
    do {
      let __result = try self.__implementation.isCarElectric(car: car)
      let __resultCpp = __result
      return bridge.create_Result_bool_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_bool_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getDriver(car: Car) -> Person? {
    do {
      let __result = try self.__implementation.getDriver(car: car)
      let __resultCpp = __result
      return bridge.create_Result_std__optional_Person__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__optional_Person__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceCar(car: Car) -> Car {
    do {
      let __result = try self.__implementation.bounceCar(car: car)
      let __resultCpp = __result
      return bridge.create_Result_Car_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_Car_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func jsStyleObjectAsParameters(params: JsStyleStruct) -> Void {
    do {
      try self.__implementation.jsStyleObjectAsParameters(params: params)
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceWrappedJsStyleStruct(value: WrappedJsStruct) -> WrappedJsStruct {
    do {
      let __result = try self.__implementation.bounceWrappedJsStyleStruct(value: value)
      let __resultCpp = __result
      return bridge.create_Result_WrappedJsStruct_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_WrappedJsStruct_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceOptionalWrapper(wrapper: OptionalWrapper) -> OptionalWrapper {
    do {
      let __result = try self.__implementation.bounceOptionalWrapper(wrapper: wrapper)
      let __resultCpp = __result
      return bridge.create_Result_OptionalWrapper_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_OptionalWrapper_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceOptionalCallback(value: OptionalCallback) -> OptionalCallback {
    do {
      let __result = try self.__implementation.bounceOptionalCallback(value: value)
      let __resultCpp = __result
      return bridge.create_Result_OptionalCallback_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_OptionalCallback_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createArrayBuffer() -> ArrayBuffer {
    do {
      let __result = try self.__implementation.createArrayBuffer()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_ArrayBuffer__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_ArrayBuffer__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createArrayBufferFromNativeBuffer(copy: Bool) -> ArrayBuffer {
    do {
      let __result = try self.__implementation.createArrayBufferFromNativeBuffer(copy: copy)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_ArrayBuffer__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_ArrayBuffer__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func copyBuffer(buffer: ArrayBuffer) -> ArrayBuffer {
    do {
      let __result = try self.__implementation.copyBuffer(buffer: buffer)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_ArrayBuffer__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_ArrayBuffer__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getBufferLastItem(buffer: ArrayBuffer) -> Double {
    do {
      let __result = try self.__implementation.getBufferLastItem(buffer: buffer)
      let __resultCpp = __result
      return bridge.create_Result_double_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_double_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setAllValuesTo(buffer: ArrayBuffer, value: Double) -> Void {
    do {
      try self.__implementation.setAllValuesTo(buffer: buffer, value: value)
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createArrayBufferAsync() -> Promise<ArrayBuffer> {
    do {
      let __result = try self.__implementation.createArrayBufferAsync()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer____(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer____(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceArrayBuffer(buffer: ArrayBuffer) -> ArrayBuffer {
    do {
      let __result = try self.__implementation.bounceArrayBuffer(buffer: buffer)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_ArrayBuffer__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_ArrayBuffer__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func passVariant(either: Variant_Bool__Double___String__String_Double) -> Variant_String_Double {
    do {
      let __result = try self.__implementation.passVariant(either: either)
      let __resultCpp = __result
      return bridge.create_Result_std__variant_std__string__double__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__variant_std__string__double__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getVariantEnum(variant: Variant_Bool_OldEnum) -> Variant_Bool_OldEnum {
    do {
      let __result = try self.__implementation.getVariantEnum(variant: variant)
      let __resultCpp = __result
      return bridge.create_Result_std__variant_bool__OldEnum__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__variant_bool__OldEnum__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getVariantWeirdNumbersEnum(variant: Variant_Bool_WeirdNumbersEnum) -> Variant_Bool_WeirdNumbersEnum {
    do {
      let __result = try self.__implementation.getVariantWeirdNumbersEnum(variant: variant)
      let __resultCpp = __result
      return bridge.create_Result_std__variant_bool__WeirdNumbersEnum__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__variant_bool__WeirdNumbersEnum__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getVariantObjects(variant: Variant_Car_Person) -> Variant_Car_Person {
    do {
      let __result = try self.__implementation.getVariantObjects(variant: variant)
      let __resultCpp = __result
      return bridge.create_Result_std__variant_Car__Person__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__variant_Car__Person__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func passNamedVariant(variant: NamedVariant) -> NamedVariant {
    do {
      let __result = try self.__implementation.passNamedVariant(variant: variant)
      let __resultCpp = __result
      return bridge.create_Result_std__variant_std__string__Car__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__variant_std__string__Car__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func passAllEmptyObjectVariant(variant: Variant__any_HybridBaseSpec__OptionalWrapper) -> Variant__any_HybridBaseSpec__OptionalWrapper {
    do {
      let __result = try self.__implementation.passAllEmptyObjectVariant(variant: variant)
      let __resultCpp = __result
      return bridge.create_Result_std__variant_std__shared_ptr_HybridBaseSpec___OptionalWrapper__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__variant_std__shared_ptr_HybridBaseSpec___OptionalWrapper__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceComplexVariant(variant: CoreTypesVariant) -> CoreTypesVariant {
    do {
      let __result = try self.__implementation.bounceComplexVariant(variant: variant)
      let __resultCpp = __result
      return bridge.create_Result_std__variant_std__shared_ptr_ArrayBuffer___std__function_void_double____value_______WrappedJsStruct__std__shared_ptr_Promise_double____std__chrono__system_clock__time_point__std__shared_ptr_AnyMap___(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__variant_std__shared_ptr_ArrayBuffer___std__function_void_double____value_______WrappedJsStruct__std__shared_ptr_Promise_double____std__chrono__system_clock__time_point__std__shared_ptr_AnyMap___(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createChild() -> (any HybridChildSpec) {
    do {
      let __result = try self.__implementation.createChild()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_HybridChildSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_HybridChildSpec__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createBase() -> (any HybridBaseSpec) {
    do {
      let __result = try self.__implementation.createBase()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_HybridBaseSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_HybridBaseSpec__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createBaseActualChild() -> (any HybridBaseSpec) {
    do {
      let __result = try self.__implementation.createBaseActualChild()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_HybridBaseSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_HybridBaseSpec__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceChild(child: (any HybridChildSpec)) -> (any HybridChildSpec) {
    do {
      let __result = try self.__implementation.bounceChild(child: child)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_HybridChildSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_HybridChildSpec__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceBase(base: (any HybridBaseSpec)) -> (any HybridBaseSpec) {
    do {
      let __result = try self.__implementation.bounceBase(base: base)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_HybridBaseSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_HybridBaseSpec__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceChildBase(child: (any HybridChildSpec)) -> (any HybridBaseSpec) {
    do {
      let __result = try self.__implementation.bounceChildBase(child: child)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_HybridBaseSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_HybridBaseSpec__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func castBase(base: (any HybridBaseSpec)) -> (any HybridChildSpec) {
    do {
      let __result = try self.__implementation.castBase(base: base)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_HybridChildSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_HybridChildSpec__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func callbackSync(callback: Func_Double) -> Double {
    do {
      let __result = try self.__implementation.callbackSync(callback: callback.closure)
      let __resultCpp = __result
      return bridge.create_Result_double_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_double_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getIsViewBlue(view: (any HybridTestViewSpec)) -> Bool {
    do {
      let __result = try self.__implementation.getIsViewBlue(view: view)
      let __resultCpp = __result
      return bridge.create_Result_bool_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_bool_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceExternalHybrid(externalObject: (any HybridSomeExternalObjectSpec)) -> (any HybridSomeExternalObjectSpec) {
    do {
      let __result = try self.__implementation.bounceExternalHybrid(externalObject: externalObject)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createInternalObject() -> (any HybridSomeExternalObjectSpec) {
    do {
      let __result = try self.__implementation.createInternalObject()
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceExternalStruct(externalStruct: ExternalObjectStruct) -> ExternalObjectStruct {
    do {
      let __result = try self.__implementation.bounceExternalStruct(externalStruct: externalStruct)
      let __resultCpp = __result
      return bridge.create_Result_ExternalObjectStruct_(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_ExternalObjectStruct_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func bounceExternalVariant(variant: StringOrExternal) -> StringOrExternal {
    do {
      let __result = try self.__implementation.bounceExternalVariant(variant: variant)
      let __resultCpp = __result
      return bridge.create_Result_std__variant_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec___std__string__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__variant_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec___std__string__(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createExternalVariantFromFunc(factory: Func__any_HybridSomeExternalObjectSpec_) -> (any HybridSomeExternalObjectSpec) {
    do {
      let __result = try self.__implementation.createExternalVariantFromFunc(factory: factory.closure)
      let __resultCpp = __result
      return bridge.create_Result_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec__(__resultCpp)
    } catch (let __error) {
      let __exceptionPtr = __error
      return bridge.create_Result_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec__(__exceptionPtr)
    }
  }
}
