///
/// NitroTest-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `Car` to properly resolve imports.
namespace margelo::nitro::test { struct Car; }
// Forward declaration of `HybridBaseSpec` to properly resolve imports.
namespace margelo::nitro::test { class HybridBaseSpec; }
// Forward declaration of `HybridChildSpec` to properly resolve imports.
namespace margelo::nitro::test { class HybridChildSpec; }
// Forward declaration of `HybridPlatformObjectSpec` to properly resolve imports.
namespace margelo::nitro::test { class HybridPlatformObjectSpec; }
// Forward declaration of `HybridRecyclableTestViewSpec` to properly resolve imports.
namespace margelo::nitro::test { class HybridRecyclableTestViewSpec; }
// Forward declaration of `HybridSomeExternalObjectSpec` to properly resolve imports.
namespace margelo::nitro::test::external { class HybridSomeExternalObjectSpec; }
// Forward declaration of `HybridTestObjectSwiftKotlinSpec` to properly resolve imports.
namespace margelo::nitro::test { class HybridTestObjectSwiftKotlinSpec; }
// Forward declaration of `HybridTestViewSpec` to properly resolve imports.
namespace margelo::nitro::test { class HybridTestViewSpec; }
// Forward declaration of `Person` to properly resolve imports.
namespace margelo::nitro::test { struct Person; }
// Forward declaration of `Powertrain` to properly resolve imports.
namespace margelo::nitro::test { enum class Powertrain; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridBaseSpec_cxx` to properly resolve imports.
namespace NitroTest { class HybridBaseSpec_cxx; }
// Forward declaration of `HybridChildSpec_cxx` to properly resolve imports.
namespace NitroTest { class HybridChildSpec_cxx; }
// Forward declaration of `HybridPlatformObjectSpec_cxx` to properly resolve imports.
namespace NitroTest { class HybridPlatformObjectSpec_cxx; }
// Forward declaration of `HybridRecyclableTestViewSpec_cxx` to properly resolve imports.
namespace NitroTest { class HybridRecyclableTestViewSpec_cxx; }
// Forward declaration of `HybridSomeExternalObjectSpec_cxx` to properly resolve imports.
namespace NitroTestExternal { class HybridSomeExternalObjectSpec_cxx; }
// Forward declaration of `HybridTestObjectSwiftKotlinSpec_cxx` to properly resolve imports.
namespace NitroTest { class HybridTestObjectSwiftKotlinSpec_cxx; }
// Forward declaration of `HybridTestViewSpec_cxx` to properly resolve imports.
namespace NitroTest { class HybridTestViewSpec_cxx; }

// Include C++ defined types
#include "Car.hpp"
#include "HybridBaseSpec.hpp"
#include "HybridChildSpec.hpp"
#include "HybridPlatformObjectSpec.hpp"
#include "HybridRecyclableTestViewSpec.hpp"
#include "HybridTestObjectSwiftKotlinSpec.hpp"
#include "HybridTestViewSpec.hpp"
#include "Person.hpp"
#include "Powertrain.hpp"
#include <NitroModules/ArrayBuffer.hpp>
#include <NitroModules/Promise.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <NitroTestExternal/HybridSomeExternalObjectSpec.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::test::bridge::swift {

  using std__shared_ptr_HybridBaseSpec_ = std::shared_ptr<HybridBaseSpec>;
  std::shared_ptr<HybridBaseSpec> create_std__shared_ptr_HybridBaseSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridBaseSpec_(std__shared_ptr_HybridBaseSpec_ cppType);
  
  using std__weak_ptr_HybridBaseSpec_ = std::weak_ptr<HybridBaseSpec>;
  inline std__weak_ptr_HybridBaseSpec_ weakify_std__shared_ptr_HybridBaseSpec_(const std::shared_ptr<HybridBaseSpec>& strong) noexcept { return strong; }
  
  using std__shared_ptr_HybridChildSpec_ = std::shared_ptr<HybridChildSpec>;
  std::shared_ptr<HybridChildSpec> create_std__shared_ptr_HybridChildSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridChildSpec_(std__shared_ptr_HybridChildSpec_ cppType);
  
  inline std::shared_ptr<HybridBaseSpec> upcast_Child_to_Base(std::shared_ptr<HybridChildSpec> child) noexcept { return child; }
  
  using std__weak_ptr_HybridChildSpec_ = std::weak_ptr<HybridChildSpec>;
  inline std__weak_ptr_HybridChildSpec_ weakify_std__shared_ptr_HybridChildSpec_(const std::shared_ptr<HybridChildSpec>& strong) noexcept { return strong; }
  
  using std__shared_ptr_HybridPlatformObjectSpec_ = std::shared_ptr<HybridPlatformObjectSpec>;
  std::shared_ptr<HybridPlatformObjectSpec> create_std__shared_ptr_HybridPlatformObjectSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridPlatformObjectSpec_(std__shared_ptr_HybridPlatformObjectSpec_ cppType);
  
  using std__weak_ptr_HybridPlatformObjectSpec_ = std::weak_ptr<HybridPlatformObjectSpec>;
  inline std__weak_ptr_HybridPlatformObjectSpec_ weakify_std__shared_ptr_HybridPlatformObjectSpec_(const std::shared_ptr<HybridPlatformObjectSpec>& strong) noexcept { return strong; }
  
  using std__shared_ptr_HybridRecyclableTestViewSpec_ = std::shared_ptr<HybridRecyclableTestViewSpec>;
  std::shared_ptr<HybridRecyclableTestViewSpec> create_std__shared_ptr_HybridRecyclableTestViewSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridRecyclableTestViewSpec_(std__shared_ptr_HybridRecyclableTestViewSpec_ cppType);
  
  using std__weak_ptr_HybridRecyclableTestViewSpec_ = std::weak_ptr<HybridRecyclableTestViewSpec>;
  inline std__weak_ptr_HybridRecyclableTestViewSpec_ weakify_std__shared_ptr_HybridRecyclableTestViewSpec_(const std::shared_ptr<HybridRecyclableTestViewSpec>& strong) noexcept { return strong; }
  
  using std__shared_ptr_HybridTestObjectSwiftKotlinSpec_ = std::shared_ptr<HybridTestObjectSwiftKotlinSpec>;
  std::shared_ptr<HybridTestObjectSwiftKotlinSpec> create_std__shared_ptr_HybridTestObjectSwiftKotlinSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridTestObjectSwiftKotlinSpec_(std__shared_ptr_HybridTestObjectSwiftKotlinSpec_ cppType);
  
  using std__weak_ptr_HybridTestObjectSwiftKotlinSpec_ = std::weak_ptr<HybridTestObjectSwiftKotlinSpec>;
  inline std__weak_ptr_HybridTestObjectSwiftKotlinSpec_ weakify_std__shared_ptr_HybridTestObjectSwiftKotlinSpec_(const std::shared_ptr<HybridTestObjectSwiftKotlinSpec>& strong) noexcept { return strong; }
  
  using Func_void_double = std::function<void(double /* value */)>;
  
  using Func_void_std__vector_Powertrain_ = std::function<void(const std::vector<Powertrain>& /* array */)>;
  
  using Func_void = std::function<void()>;
  
  using std__shared_ptr_Promise_double__ = std::shared_ptr<Promise<double>>;
  
  using Func_void_std__exception_ptr = std::function<void(const std::exception_ptr& /* error */)>;
  
  using std__shared_ptr_Promise_void__ = std::shared_ptr<Promise<void>>;
  
  using std__shared_ptr_Promise_int64_t__ = std::shared_ptr<Promise<int64_t>>;
  
  using Func_void_int64_t = std::function<void(int64_t /* result */)>;
  
  using std__shared_ptr_Promise_std__optional_double___ = std::shared_ptr<Promise<std::optional<double>>>;
  
  using Func_void_std__optional_double_ = std::function<void(std::optional<double> /* result */)>;
  
  using std__shared_ptr_Promise_Car__ = std::shared_ptr<Promise<Car>>;
  
  using Func_void_Car = std::function<void(const Car& /* result */)>;
  
  using Func_std__shared_ptr_Promise_std__shared_ptr_Promise_void____ = std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>()>;
  
  using std__shared_ptr_Promise_std__shared_ptr_Promise_void____ = std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>;
  
  using Func_void_std__shared_ptr_Promise_void__ = std::function<void(const std::shared_ptr<Promise<void>>& /* result */)>;
  
  using Func_std__shared_ptr_Promise_double__ = std::function<std::shared_ptr<Promise<double>>()>;
  
  using Func_std__shared_ptr_Promise_std__shared_ptr_Promise_double____ = std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>()>;
  
  using std__shared_ptr_Promise_std__shared_ptr_Promise_double____ = std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>;
  
  using Func_void_std__shared_ptr_Promise_double__ = std::function<void(const std::shared_ptr<Promise<double>>& /* result */)>;
  
  using std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer___ = std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>;
  
  using Func_void_std__shared_ptr_ArrayBuffer_ = std::function<void(const std::shared_ptr<ArrayBuffer>& /* result */)>;
  
  using Func_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer_____ = std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>()>;
  
  using std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer_____ = std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>;
  
  using Func_void_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer___ = std::function<void(const std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>& /* result */)>;
  
  using Func_void_std__string = std::function<void(const std::string& /* value */)>;
  
  using Func_std__shared_ptr_Promise_std__string__ = std::function<std::shared_ptr<Promise<std::string>>()>;
  
  using std__shared_ptr_Promise_std__string__ = std::shared_ptr<Promise<std::string>>;
  
  using Func_double = std::function<double()>;
  
  using std__shared_ptr_HybridTestViewSpec_ = std::shared_ptr<HybridTestViewSpec>;
  std::shared_ptr<HybridTestViewSpec> create_std__shared_ptr_HybridTestViewSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridTestViewSpec_(std__shared_ptr_HybridTestViewSpec_ cppType);
  
  using std__weak_ptr_HybridTestViewSpec_ = std::weak_ptr<HybridTestViewSpec>;
  inline std__weak_ptr_HybridTestViewSpec_ weakify_std__shared_ptr_HybridTestViewSpec_(const std::shared_ptr<HybridTestViewSpec>& strong) noexcept { return strong; }
  
  using std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_ = std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>;
  std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec> create_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_(std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_ cppType);
  
  using std__weak_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_ = std::weak_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>;
  inline std__weak_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_ weakify_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_(const std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>& strong) noexcept { return strong; }
  
  using Func_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_ = std::function<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>()>;

} // namespace margelo::nitro::test::bridge::swift
