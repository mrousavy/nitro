///
/// NitroTestAutolinking.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

import NitroModules

// TODO: Use empty enums once Swift supports exporting them as namespaces
//       See: https://github.com/swiftlang/swift/pull/83616
public final class NitroTestAutolinking {
  public typealias bridge = margelo.nitro.test.bridge.swift
  
  public static func createASCIIString(bytes: UnsafeRawPointer, length: Int) -> String {
    return String(unsafeUninitializedCapacity: length) { buffer in
      memcpy(buffer.baseAddress, bytes, length)
      return length
    }
  }
  public static func createUTF16String(bytes: UnsafePointer<UInt16>, length: Int) -> String {
    return String(utf16CodeUnits: bytes, count: length)
  }
  
  public static func convertStringToJS(runtime: inout facebook.jsi.Runtime, string: String) -> bridge.UnsafeJsiStringWrapper {
    if string.isEmpty {
      // A) Empty string, no need for accessing data
      return bridge.UnsafeJsiStringWrapper(consuming: facebook.jsi.String.createFromAscii(&runtime, "", 0))
    }
    
    if #available(iOS 26.0, *) {
      let utf8 = string.utf8Span
      return utf8.span.withUnsafeBytes { buffer in
        if utf8.isKnownASCII {
          // B) It's all ASCII - we can access the bytes and use jsi::String's ASCII fast-path
          return bridge.UnsafeJsiStringWrapper(consuming: facebook.jsi.String.createFromAscii(&runtime, buffer.baseAddress!, buffer.count))
        } else {
          // C) It's not ASCII, so let's use the UTF8 decoder from JSI, which internally likely transcodes to UTF16.
          //    We cannot use a UTF16 fast-path here, since Swift doesn't natively stores Strings in contiguous UTF16 memory,
          //    so UTF8 is the best we can do.
          return bridge.UnsafeJsiStringWrapper(consuming: facebook.jsi.String.createFromUtf8(&runtime, buffer.baseAddress!, buffer.count))
        }
      }
    } else {
      // D) We can't access neither UTF16 nor UTF8 as zero-copy, we have to do a potential UTF8 copy and have JSI decode the UTF8.
      var maybeCopy = string
      return maybeCopy.withUTF8 { buffer in
        return bridge.UnsafeJsiStringWrapper(consuming: facebook.jsi.String.createFromUtf8(&runtime, buffer.baseAddress!, buffer.count))
      }
    }
  }

  public static func createTestObjectSwiftKotlin() -> bridge.std__shared_ptr_HybridTestObjectSwiftKotlinSpec_ {
    let hybridObject = HybridTestObjectSwift()
    return { () -> bridge.std__shared_ptr_HybridTestObjectSwiftKotlinSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isTestObjectSwiftKotlinRecyclable() -> Bool {
    return HybridTestObjectSwift.self is any RecyclableView.Type
  }
  
  public static func createBase() -> bridge.std__shared_ptr_HybridBaseSpec_ {
    let hybridObject = HybridBase()
    return { () -> bridge.std__shared_ptr_HybridBaseSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isBaseRecyclable() -> Bool {
    return HybridBase.self is any RecyclableView.Type
  }
  
  public static func createChild() -> bridge.std__shared_ptr_HybridChildSpec_ {
    let hybridObject = HybridChild()
    return { () -> bridge.std__shared_ptr_HybridChildSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isChildRecyclable() -> Bool {
    return HybridChild.self is any RecyclableView.Type
  }
  
  public static func createPlatformObject() -> bridge.std__shared_ptr_HybridPlatformObjectSpec_ {
    let hybridObject = HybridPlatformObject()
    return { () -> bridge.std__shared_ptr_HybridPlatformObjectSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isPlatformObjectRecyclable() -> Bool {
    return HybridPlatformObject.self is any RecyclableView.Type
  }
  
  public static func createTestView() -> bridge.std__shared_ptr_HybridTestViewSpec_ {
    let hybridObject = HybridTestView()
    return { () -> bridge.std__shared_ptr_HybridTestViewSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isTestViewRecyclable() -> Bool {
    return HybridTestView.self is any RecyclableView.Type
  }
  
  public static func createRecyclableTestView() -> bridge.std__shared_ptr_HybridRecyclableTestViewSpec_ {
    let hybridObject = HybridRecyclableTestView()
    return { () -> bridge.std__shared_ptr_HybridRecyclableTestViewSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isRecyclableTestViewRecyclable() -> Bool {
    return HybridRecyclableTestView.self is any RecyclableView.Type
  }
}
