///
/// NitroTestAutolinking.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

import NitroModules

// TODO: Use empty enums once Swift supports exporting them as namespaces
//       See: https://github.com/swiftlang/swift/pull/83616
public final class NitroTestAutolinking {
  public typealias bridge = margelo.nitro.test.bridge.swift
  
  public static func createASCIIString(bytes: UnsafeRawPointer, length: Int) -> String {
    return String(unsafeUninitializedCapacity: length) { buffer in
      memcpy(buffer.baseAddress, bytes, length)
      return length
    }
  }
  public static func createUTF16String(bytes: UnsafePointer<UInt16>, length: Int) -> String {
    return String(utf16CodeUnits: bytes, count: length)
  }
  
  public static func convertStringToJS(runtime: inout facebook.jsi.Runtime, string: String) -> bridge.UnsafeJsiStringWrapper {
    if string.isEmpty {
      // A) Empty string, no need for accessing data
      return bridge.UnsafeJsiStringWrapper(consuming: facebook.jsi.String.createFromAscii(&runtime, "", 0))
    }
    
    if #available(iOS 26.0, *),
       string.utf8Span.isKnownASCII {
      // B) It's all ASCII - we can access the bytes and use jsi::String's ASCII fast-path
      let span = string.utf8Span.span
      return span.withUnsafeBytes { buffer in
        return bridge.UnsafeJsiStringWrapper(consuming: facebook.jsi.String.createFromAscii(&runtime, buffer.baseAddress!, span.count))
      }
    } else {
      // C) It's not ASCII, so let's try to no-copy access the UTF16 bytes - also a fast-path in jsi::String
      if let utf16JsString = string.utf16.withContiguousStorageIfAvailable({ buffer in
        return bridge.UnsafeJsiStringWrapper(consuming: facebook.jsi.String.createFromUtf16(&runtime, buffer.baseAddress!, string.count))
      }) {
        return utf16JsString
      }
      
      if #available(iOS 26.0, *) {
        // D) The UTF16 bytes couldn't be zero-copy accessed, so we have to access the Span's UTF8 data (no-copy) + decode.
        let span = string.utf8Span.span
        return span.withUnsafeBytes { buffer in
          let utf8 = buffer.bindMemory(to: UInt8.self)
          return transcodeUTF8ToUTF16JSString(runtime: &runtime, utf8: utf8)
        }
      } else {
        // E) We can't access neither UTF16 nor UTF8 as zero-copy, we have to do a potential UTF8 copy + decode.
        var maybeCopy = string
        return maybeCopy.withUTF8 { u8 in
          transcodeUTF8ToUTF16JSString(runtime: &runtime, utf8: u8)
        }
      }
    }
  }
  
  @inline(__always)
  private static func transcodeUTF8ToUTF16JSString(
    runtime: inout facebook.jsi.Runtime,
    utf8: UnsafeBufferPointer<UInt8>
  ) -> bridge.UnsafeJsiStringWrapper {
    withUnsafeTemporaryAllocation(of: UInt16.self, capacity: utf8.count) { buffer in
      var charactersCount = 0
      let iterator = utf8.makeIterator()

      // Transcode each UTF8 character to UTF16
      _ = transcode(iterator, from: Unicode.UTF8.self, to: Unicode.UTF16.self, stoppingOnError: false) { u16 in
        buffer[charactersCount] = u16
        charactersCount += 1
      }

      return bridge.UnsafeJsiStringWrapper(
        consuming: facebook.jsi.String.createFromUtf16(&runtime, buffer.baseAddress!, charactersCount)
      )
    }
  }

  public static func createTestObjectSwiftKotlin() -> bridge.std__shared_ptr_HybridTestObjectSwiftKotlinSpec_ {
    let hybridObject = HybridTestObjectSwift()
    return { () -> bridge.std__shared_ptr_HybridTestObjectSwiftKotlinSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isTestObjectSwiftKotlinRecyclable() -> Bool {
    return HybridTestObjectSwift.self is any RecyclableView.Type
  }
  
  public static func createBase() -> bridge.std__shared_ptr_HybridBaseSpec_ {
    let hybridObject = HybridBase()
    return { () -> bridge.std__shared_ptr_HybridBaseSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isBaseRecyclable() -> Bool {
    return HybridBase.self is any RecyclableView.Type
  }
  
  public static func createChild() -> bridge.std__shared_ptr_HybridChildSpec_ {
    let hybridObject = HybridChild()
    return { () -> bridge.std__shared_ptr_HybridChildSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isChildRecyclable() -> Bool {
    return HybridChild.self is any RecyclableView.Type
  }
  
  public static func createPlatformObject() -> bridge.std__shared_ptr_HybridPlatformObjectSpec_ {
    let hybridObject = HybridPlatformObject()
    return { () -> bridge.std__shared_ptr_HybridPlatformObjectSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isPlatformObjectRecyclable() -> Bool {
    return HybridPlatformObject.self is any RecyclableView.Type
  }
  
  public static func createTestView() -> bridge.std__shared_ptr_HybridTestViewSpec_ {
    let hybridObject = HybridTestView()
    return { () -> bridge.std__shared_ptr_HybridTestViewSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isTestViewRecyclable() -> Bool {
    return HybridTestView.self is any RecyclableView.Type
  }
  
  public static func createRecyclableTestView() -> bridge.std__shared_ptr_HybridRecyclableTestViewSpec_ {
    let hybridObject = HybridRecyclableTestView()
    return { () -> bridge.std__shared_ptr_HybridRecyclableTestViewSpec_ in
      let __cxxWrapped = hybridObject.getCxxWrapper()
      return __cxxWrapped.getCxxPart()
    }()
  }
  
  public static func isRecyclableTestViewRecyclable() -> Bool {
    return HybridRecyclableTestView.self is any RecyclableView.Type
  }
}
