///
/// JCar.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

#pragma once

#include <fbjni/fbjni.h>
#include "Car.hpp"

#include "JPerson.hpp"
#include "JPowertrain.hpp"
#include "JVariant_String_Double.hpp"
#include "Person.hpp"
#include "Powertrain.hpp"
#include <optional>
#include <string>
#include <variant>
#include <vector>

namespace margelo::nitro::test {

  using namespace facebook;

  /**
   * The C++ JNI bridge between the C++ struct "Car" and the the Kotlin data class "Car".
   */
  struct JCar final: public jni::JavaClass<JCar> {
  public:
    static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/test/Car;";

  public:
    /**
     * Convert this Java/Kotlin-based struct to the C++ struct Car by copying all values to C++.
     */
    [[maybe_unused]]
    [[nodiscard]]
    Car toCpp() const {
      static const auto clazz = javaClassStatic();
      static const auto fieldYear = clazz->getField<double>("year");
      double year = this->getFieldValue(fieldYear);
      static const auto fieldMake = clazz->getField<jni::JString>("make");
      jni::local_ref<jni::JString> make = this->getFieldValue(fieldMake);
      static const auto fieldModel = clazz->getField<jni::JString>("model");
      jni::local_ref<jni::JString> model = this->getFieldValue(fieldModel);
      static const auto fieldPower = clazz->getField<double>("power");
      double power = this->getFieldValue(fieldPower);
      static const auto fieldPowertrain = clazz->getField<JPowertrain>("powertrain");
      jni::local_ref<JPowertrain> powertrain = this->getFieldValue(fieldPowertrain);
      static const auto fieldDriver = clazz->getField<JPerson>("driver");
      jni::local_ref<JPerson> driver = this->getFieldValue(fieldDriver);
      static const auto fieldPassengers = clazz->getField<jni::JArrayClass<JPerson>>("passengers");
      jni::local_ref<jni::JArrayClass<JPerson>> passengers = this->getFieldValue(fieldPassengers);
      static const auto fieldIsFast = clazz->getField<jni::JBoolean>("isFast");
      jni::local_ref<jni::JBoolean> isFast = this->getFieldValue(fieldIsFast);
      static const auto fieldFavouriteTrack = clazz->getField<jni::JString>("favouriteTrack");
      jni::local_ref<jni::JString> favouriteTrack = this->getFieldValue(fieldFavouriteTrack);
      static const auto fieldPerformanceScores = clazz->getField<jni::JArrayDouble>("performanceScores");
      jni::local_ref<jni::JArrayDouble> performanceScores = this->getFieldValue(fieldPerformanceScores);
      static const auto fieldSomeVariant = clazz->getField<JVariant_String_Double>("someVariant");
      jni::local_ref<JVariant_String_Double> someVariant = this->getFieldValue(fieldSomeVariant);
      return Car(
        year,
        make->toStdString(),
        model->toStdString(),
        power,
        powertrain->toCpp(),
        driver != nullptr ? std::make_optional(driver->toCpp()) : std::nullopt,
        [&]() {
          size_t __size = passengers->size();
          std::vector<Person> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = passengers->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }(),
        isFast != nullptr ? std::make_optional(static_cast<bool>(isFast->value())) : std::nullopt,
        favouriteTrack != nullptr ? std::make_optional(favouriteTrack->toStdString()) : std::nullopt,
        [&]() {
          size_t __size = performanceScores->size();
          std::vector<double> __vector(__size);
          performanceScores->getRegion(0, __size, __vector.data());
          return __vector;
        }(),
        someVariant != nullptr ? std::make_optional(someVariant->toCpp()) : std::nullopt
      );
    }

  public:
    /**
     * Create a Java/Kotlin-based struct by copying all values from the given C++ struct to Java.
     */
    [[maybe_unused]]
    static jni::local_ref<JCar::javaobject> fromCpp(const Car& value) {
      using JSignature = JCar(double, jni::alias_ref<jni::JString>, jni::alias_ref<jni::JString>, double, jni::alias_ref<JPowertrain>, jni::alias_ref<JPerson>, jni::alias_ref<jni::JArrayClass<JPerson>>, jni::alias_ref<jni::JBoolean>, jni::alias_ref<jni::JString>, jni::alias_ref<jni::JArrayDouble>, jni::alias_ref<JVariant_String_Double>);
      static const auto clazz = javaClassStatic();
      static const auto create = clazz->getStaticMethod<JSignature>("fromCpp");
      return create(
        clazz,
        value.year,
        jni::make_jstring(value.make),
        jni::make_jstring(value.model),
        value.power,
        JPowertrain::fromCpp(value.powertrain),
        value.driver.has_value() ? JPerson::fromCpp(value.driver.value()) : nullptr,
        [&]() {
          size_t __size = value.passengers.size();
          jni::local_ref<jni::JArrayClass<JPerson>> __array = jni::JArrayClass<JPerson>::newArray(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            const auto& __element = value.passengers[__i];
            __array->setElement(__i, *JPerson::fromCpp(__element));
          }
          return __array;
        }(),
        value.isFast.has_value() ? jni::JBoolean::valueOf(value.isFast.value()) : nullptr,
        value.favouriteTrack.has_value() ? jni::make_jstring(value.favouriteTrack.value()) : nullptr,
        [&]() {
          size_t __size = value.performanceScores.size();
          jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
          __array->setRegion(0, __size, value.performanceScores.data());
          return __array;
        }(),
        value.someVariant.has_value() ? JVariant_String_Double::fromCpp(value.someVariant.value()) : nullptr
      );
    }
  };

} // namespace margelo::nitro::test
