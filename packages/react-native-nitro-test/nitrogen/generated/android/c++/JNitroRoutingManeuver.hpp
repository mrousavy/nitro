///
/// JNitroRoutingManeuver.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

#include <fbjni/fbjni.h>
#include "NitroRoutingManeuver.hpp"

#include "AssetImage.hpp"
#include "AutoText.hpp"
#include "Distance.hpp"
#include "DistanceUnits.hpp"
#include "DurationWithTimeZone.hpp"
#include "ForkType.hpp"
#include "GlyphImage.hpp"
#include "ImageLane.hpp"
#include "JAssetImage.hpp"
#include "JAutoText.hpp"
#include "JDistance.hpp"
#include "JDistanceUnits.hpp"
#include "JDurationWithTimeZone.hpp"
#include "JForkType.hpp"
#include "JFunc_void.hpp"
#include "JGlyphImage.hpp"
#include "JImageLane.hpp"
#include "JKeepType.hpp"
#include "JLaneGuidance.hpp"
#include "JManeuverType.hpp"
#include "JNitroAttributedString.hpp"
#include "JNitroAttributedStringImage.hpp"
#include "JNitroColor.hpp"
#include "JNitroImage.hpp"
#include "JOffRampType.hpp"
#include "JOnRampType.hpp"
#include "JPreferredImageLane.hpp"
#include "JTrafficSide.hpp"
#include "JTravelEstimates.hpp"
#include "JTurnType.hpp"
#include "JVariant_AssetImage_GlyphImage.hpp"
#include "JVariant_PreferredImageLane_ImageLane.hpp"
#include "KeepType.hpp"
#include "LaneGuidance.hpp"
#include "ManeuverType.hpp"
#include "NitroAttributedString.hpp"
#include "NitroAttributedStringImage.hpp"
#include "NitroColor.hpp"
#include "OffRampType.hpp"
#include "OnRampType.hpp"
#include "PreferredImageLane.hpp"
#include "TrafficSide.hpp"
#include "TravelEstimates.hpp"
#include "TurnType.hpp"
#include <NitroModules/JNICallable.hpp>
#include <functional>
#include <optional>
#include <string>
#include <variant>
#include <vector>

namespace margelo::nitro::test {

  using namespace facebook;

  /**
   * The C++ JNI bridge between the C++ struct "NitroRoutingManeuver" and the the Kotlin data class "NitroRoutingManeuver".
   */
  struct JNitroRoutingManeuver final: public jni::JavaClass<JNitroRoutingManeuver> {
  public:
    static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/test/NitroRoutingManeuver;";

  public:
    /**
     * Convert this Java/Kotlin-based struct to the C++ struct NitroRoutingManeuver by copying all values to C++.
     */
    [[maybe_unused]]
    [[nodiscard]]
    NitroRoutingManeuver toCpp() const {
      static const auto clazz = javaClassStatic();
      static const auto fieldAttributedInstructionVariants = clazz->getField<jni::JArrayClass<JNitroAttributedString>>("attributedInstructionVariants");
      jni::local_ref<jni::JArrayClass<JNitroAttributedString>> attributedInstructionVariants = this->getFieldValue(fieldAttributedInstructionVariants);
      static const auto fieldSymbolImage = clazz->getField<JNitroImage>("symbolImage");
      jni::local_ref<JNitroImage> symbolImage = this->getFieldValue(fieldSymbolImage);
      static const auto fieldJunctionImage = clazz->getField<JVariant_AssetImage_GlyphImage>("junctionImage");
      jni::local_ref<JVariant_AssetImage_GlyphImage> junctionImage = this->getFieldValue(fieldJunctionImage);
      static const auto fieldTurnType = clazz->getField<JTurnType>("turnType");
      jni::local_ref<JTurnType> turnType = this->getFieldValue(fieldTurnType);
      static const auto fieldAngle = clazz->getField<jni::JDouble>("angle");
      jni::local_ref<jni::JDouble> angle = this->getFieldValue(fieldAngle);
      static const auto fieldElementAngles = clazz->getField<jni::JArrayDouble>("elementAngles");
      jni::local_ref<jni::JArrayDouble> elementAngles = this->getFieldValue(fieldElementAngles);
      static const auto fieldExitNumber = clazz->getField<jni::JDouble>("exitNumber");
      jni::local_ref<jni::JDouble> exitNumber = this->getFieldValue(fieldExitNumber);
      static const auto fieldOffRampType = clazz->getField<JOffRampType>("offRampType");
      jni::local_ref<JOffRampType> offRampType = this->getFieldValue(fieldOffRampType);
      static const auto fieldOnRampType = clazz->getField<JOnRampType>("onRampType");
      jni::local_ref<JOnRampType> onRampType = this->getFieldValue(fieldOnRampType);
      static const auto fieldForkType = clazz->getField<JForkType>("forkType");
      jni::local_ref<JForkType> forkType = this->getFieldValue(fieldForkType);
      static const auto fieldKeepType = clazz->getField<JKeepType>("keepType");
      jni::local_ref<JKeepType> keepType = this->getFieldValue(fieldKeepType);
      static const auto fieldLinkedLaneGuidance = clazz->getField<JLaneGuidance>("linkedLaneGuidance");
      jni::local_ref<JLaneGuidance> linkedLaneGuidance = this->getFieldValue(fieldLinkedLaneGuidance);
      static const auto fieldCardBackgroundColor = clazz->getField<JNitroColor>("cardBackgroundColor");
      jni::local_ref<JNitroColor> cardBackgroundColor = this->getFieldValue(fieldCardBackgroundColor);
      static const auto fieldId = clazz->getField<jni::JString>("id");
      jni::local_ref<jni::JString> id = this->getFieldValue(fieldId);
      static const auto fieldTravelEstimates = clazz->getField<JTravelEstimates>("travelEstimates");
      jni::local_ref<JTravelEstimates> travelEstimates = this->getFieldValue(fieldTravelEstimates);
      static const auto fieldTrafficSide = clazz->getField<JTrafficSide>("trafficSide");
      jni::local_ref<JTrafficSide> trafficSide = this->getFieldValue(fieldTrafficSide);
      static const auto fieldManeuverType = clazz->getField<JManeuverType>("maneuverType");
      jni::local_ref<JManeuverType> maneuverType = this->getFieldValue(fieldManeuverType);
      static const auto fieldRoadName = clazz->getField<jni::JArrayClass<jni::JString>>("roadName");
      jni::local_ref<jni::JArrayClass<jni::JString>> roadName = this->getFieldValue(fieldRoadName);
      static const auto fieldHighwayExitLabel = clazz->getField<jni::JString>("highwayExitLabel");
      jni::local_ref<jni::JString> highwayExitLabel = this->getFieldValue(fieldHighwayExitLabel);
      return NitroRoutingManeuver(
        [&]() {
          size_t __size = attributedInstructionVariants->size();
          std::vector<NitroAttributedString> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = attributedInstructionVariants->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }(),
        symbolImage->toCpp(),
        junctionImage != nullptr ? std::make_optional(junctionImage->toCpp()) : std::nullopt,
        turnType != nullptr ? std::make_optional(turnType->toCpp()) : std::nullopt,
        angle != nullptr ? std::make_optional(angle->value()) : std::nullopt,
        elementAngles != nullptr ? std::make_optional([&]() {
          size_t __size = elementAngles->size();
          std::vector<double> __vector(__size);
          elementAngles->getRegion(0, __size, __vector.data());
          return __vector;
        }()) : std::nullopt,
        exitNumber != nullptr ? std::make_optional(exitNumber->value()) : std::nullopt,
        offRampType != nullptr ? std::make_optional(offRampType->toCpp()) : std::nullopt,
        onRampType != nullptr ? std::make_optional(onRampType->toCpp()) : std::nullopt,
        forkType != nullptr ? std::make_optional(forkType->toCpp()) : std::nullopt,
        keepType != nullptr ? std::make_optional(keepType->toCpp()) : std::nullopt,
        linkedLaneGuidance != nullptr ? std::make_optional(linkedLaneGuidance->toCpp()) : std::nullopt,
        cardBackgroundColor->toCpp(),
        id->toStdString(),
        travelEstimates->toCpp(),
        trafficSide->toCpp(),
        maneuverType->toCpp(),
        roadName != nullptr ? std::make_optional([&]() {
          size_t __size = roadName->size();
          std::vector<std::string> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = roadName->getElement(__i);
            __vector.push_back(__element->toStdString());
          }
          return __vector;
        }()) : std::nullopt,
        highwayExitLabel != nullptr ? std::make_optional(highwayExitLabel->toStdString()) : std::nullopt
      );
    }

  public:
    /**
     * Create a Java/Kotlin-based struct by copying all values from the given C++ struct to Java.
     */
    [[maybe_unused]]
    static jni::local_ref<JNitroRoutingManeuver::javaobject> fromCpp(const NitroRoutingManeuver& value) {
      using JSignature = JNitroRoutingManeuver(jni::alias_ref<jni::JArrayClass<JNitroAttributedString>>, jni::alias_ref<JNitroImage>, jni::alias_ref<JVariant_AssetImage_GlyphImage>, jni::alias_ref<JTurnType>, jni::alias_ref<jni::JDouble>, jni::alias_ref<jni::JArrayDouble>, jni::alias_ref<jni::JDouble>, jni::alias_ref<JOffRampType>, jni::alias_ref<JOnRampType>, jni::alias_ref<JForkType>, jni::alias_ref<JKeepType>, jni::alias_ref<JLaneGuidance>, jni::alias_ref<JNitroColor>, jni::alias_ref<jni::JString>, jni::alias_ref<JTravelEstimates>, jni::alias_ref<JTrafficSide>, jni::alias_ref<JManeuverType>, jni::alias_ref<jni::JArrayClass<jni::JString>>, jni::alias_ref<jni::JString>);
      static const auto clazz = javaClassStatic();
      static const auto create = clazz->getStaticMethod<JSignature>("fromCpp");
      return create(
        clazz,
        [&]() {
          size_t __size = value.attributedInstructionVariants.size();
          jni::local_ref<jni::JArrayClass<JNitroAttributedString>> __array = jni::JArrayClass<JNitroAttributedString>::newArray(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            const auto& __element = value.attributedInstructionVariants[__i];
            auto __elementJni = JNitroAttributedString::fromCpp(__element);
            __array->setElement(__i, *__elementJni);
          }
          return __array;
        }(),
        JNitroImage::fromCpp(value.symbolImage),
        value.junctionImage.has_value() ? JVariant_AssetImage_GlyphImage::fromCpp(value.junctionImage.value()) : nullptr,
        value.turnType.has_value() ? JTurnType::fromCpp(value.turnType.value()) : nullptr,
        value.angle.has_value() ? jni::JDouble::valueOf(value.angle.value()) : nullptr,
        value.elementAngles.has_value() ? [&]() {
          size_t __size = value.elementAngles.value().size();
          jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
          __array->setRegion(0, __size, value.elementAngles.value().data());
          return __array;
        }() : nullptr,
        value.exitNumber.has_value() ? jni::JDouble::valueOf(value.exitNumber.value()) : nullptr,
        value.offRampType.has_value() ? JOffRampType::fromCpp(value.offRampType.value()) : nullptr,
        value.onRampType.has_value() ? JOnRampType::fromCpp(value.onRampType.value()) : nullptr,
        value.forkType.has_value() ? JForkType::fromCpp(value.forkType.value()) : nullptr,
        value.keepType.has_value() ? JKeepType::fromCpp(value.keepType.value()) : nullptr,
        value.linkedLaneGuidance.has_value() ? JLaneGuidance::fromCpp(value.linkedLaneGuidance.value()) : nullptr,
        JNitroColor::fromCpp(value.cardBackgroundColor),
        jni::make_jstring(value.id),
        JTravelEstimates::fromCpp(value.travelEstimates),
        JTrafficSide::fromCpp(value.trafficSide),
        JManeuverType::fromCpp(value.maneuverType),
        value.roadName.has_value() ? [&]() {
          size_t __size = value.roadName.value().size();
          jni::local_ref<jni::JArrayClass<jni::JString>> __array = jni::JArrayClass<jni::JString>::newArray(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            const auto& __element = value.roadName.value()[__i];
            auto __elementJni = jni::make_jstring(__element);
            __array->setElement(__i, *__elementJni);
          }
          return __array;
        }() : nullptr,
        value.highwayExitLabel.has_value() ? jni::make_jstring(value.highwayExitLabel.value()) : nullptr
      );
    }
  };

} // namespace margelo::nitro::test
