///
/// JLaneGuidance.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

#include <fbjni/fbjni.h>
#include "LaneGuidance.hpp"

#include "AssetImage.hpp"
#include "GlyphImage.hpp"
#include "ImageLane.hpp"
#include "JAssetImage.hpp"
#include "JGlyphImage.hpp"
#include "JImageLane.hpp"
#include "JNitroColor.hpp"
#include "JNitroImage.hpp"
#include "JPreferredImageLane.hpp"
#include "JVariant_PreferredImageLane_ImageLane.hpp"
#include "NitroColor.hpp"
#include "PreferredImageLane.hpp"
#include <optional>
#include <string>
#include <variant>
#include <vector>

namespace margelo::nitro::test {

  using namespace facebook;

  /**
   * The C++ JNI bridge between the C++ struct "LaneGuidance" and the the Kotlin data class "LaneGuidance".
   */
  struct JLaneGuidance final: public jni::JavaClass<JLaneGuidance> {
  public:
    static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/test/LaneGuidance;";

  public:
    /**
     * Convert this Java/Kotlin-based struct to the C++ struct LaneGuidance by copying all values to C++.
     */
    [[maybe_unused]]
    [[nodiscard]]
    LaneGuidance toCpp() const {
      static const auto clazz = javaClassStatic();
      static const auto fieldInstructionVariants = clazz->getField<jni::JArrayClass<jni::JString>>("instructionVariants");
      jni::local_ref<jni::JArrayClass<jni::JString>> instructionVariants = this->getFieldValue(fieldInstructionVariants);
      static const auto fieldLanes = clazz->getField<jni::JArrayClass<JVariant_PreferredImageLane_ImageLane>>("lanes");
      jni::local_ref<jni::JArrayClass<JVariant_PreferredImageLane_ImageLane>> lanes = this->getFieldValue(fieldLanes);
      return LaneGuidance(
        [&]() {
          size_t __size = instructionVariants->size();
          std::vector<std::string> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = instructionVariants->getElement(__i);
            __vector.push_back(__element->toStdString());
          }
          return __vector;
        }(),
        [&]() {
          size_t __size = lanes->size();
          std::vector<std::variant<PreferredImageLane, ImageLane>> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = lanes->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }()
      );
    }

  public:
    /**
     * Create a Java/Kotlin-based struct by copying all values from the given C++ struct to Java.
     */
    [[maybe_unused]]
    static jni::local_ref<JLaneGuidance::javaobject> fromCpp(const LaneGuidance& value) {
      using JSignature = JLaneGuidance(jni::alias_ref<jni::JArrayClass<jni::JString>>, jni::alias_ref<jni::JArrayClass<JVariant_PreferredImageLane_ImageLane>>);
      static const auto clazz = javaClassStatic();
      static const auto create = clazz->getStaticMethod<JSignature>("fromCpp");
      return create(
        clazz,
        [&]() {
          size_t __size = value.instructionVariants.size();
          jni::local_ref<jni::JArrayClass<jni::JString>> __array = jni::JArrayClass<jni::JString>::newArray(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            const auto& __element = value.instructionVariants[__i];
            auto __elementJni = jni::make_jstring(__element);
            __array->setElement(__i, *__elementJni);
          }
          return __array;
        }(),
        [&]() {
          size_t __size = value.lanes.size();
          jni::local_ref<jni::JArrayClass<JVariant_PreferredImageLane_ImageLane>> __array = jni::JArrayClass<JVariant_PreferredImageLane_ImageLane>::newArray(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            const auto& __element = value.lanes[__i];
            auto __elementJni = JVariant_PreferredImageLane_ImageLane::fromCpp(__element);
            __array->setElement(__i, *__elementJni);
          }
          return __array;
        }()
      );
    }
  };

} // namespace margelo::nitro::test
