///
/// JHybridTestObjectSwiftKotlinSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridTestObjectSwiftKotlinSpec.hpp"
#include <NitroModules/JNIConverter.hpp>

// Forward declaration of `HybridTestObjectSwiftKotlinSpec` to properly resolve imports.
namespace margelo::nitro::test { class HybridTestObjectSwiftKotlinSpec; }
// Forward declaration of `Powertrain` to properly resolve imports.
namespace margelo::nitro::test { enum class Powertrain; }
// Forward declaration of `OldEnum` to properly resolve imports.
namespace margelo::nitro::test { enum class OldEnum; }
// Forward declaration of `Person` to properly resolve imports.
namespace margelo::nitro::test { struct Person; }
// Forward declaration of `PartialPerson` to properly resolve imports.
namespace margelo::nitro::test { struct PartialPerson; }
// Forward declaration of `HybridChildSpec` to properly resolve imports.
namespace margelo::nitro::test { class HybridChildSpec; }
// Forward declaration of `Car` to properly resolve imports.
namespace margelo::nitro::test { struct Car; }
// Forward declaration of `WrappedJsStruct` to properly resolve imports.
namespace margelo::nitro::test { struct WrappedJsStruct; }
// Forward declaration of `JsStyleStruct` to properly resolve imports.
namespace margelo::nitro::test { struct JsStyleStruct; }
// Forward declaration of `OptionalWrapper` to properly resolve imports.
namespace margelo::nitro::test { struct OptionalWrapper; }
// Forward declaration of `OptionalCallback` to properly resolve imports.
namespace margelo::nitro::test { struct OptionalCallback; }
// Forward declaration of `WeirdNumbersEnum` to properly resolve imports.
namespace margelo::nitro::test { enum class WeirdNumbersEnum; }
// Forward declaration of `HybridBaseSpec` to properly resolve imports.
namespace margelo::nitro::test { class HybridBaseSpec; }
// Forward declaration of `HybridSomeExternalObjectSpec` to properly resolve imports.
namespace margelo::nitro::test::external { class HybridSomeExternalObjectSpec; }
// Forward declaration of `ExternalObjectStruct` to properly resolve imports.
namespace margelo::nitro::test { struct ExternalObjectStruct; }
// Forward declaration of `MapWrapper` to properly resolve imports.
namespace margelo::nitro::test { struct MapWrapper; }
// Forward declaration of `SecondMapWrapper` to properly resolve imports.
namespace margelo::nitro::test { struct SecondMapWrapper; }
// Forward declaration of `HybridTestViewSpec` to properly resolve imports.
namespace margelo::nitro::test { class HybridTestViewSpec; }

#include <memory>
#include "HybridTestObjectSwiftKotlinSpec.hpp"
#include "JHybridTestObjectSwiftKotlinSpec.hpp"
#include <optional>
#include <string>
#include <NitroModules/Null.hpp>
#include <NitroModules/JNull.hpp>
#include <variant>
#include "JVariant_NullType_String.hpp"
#include <vector>
#include "Powertrain.hpp"
#include "JPowertrain.hpp"
#include "OldEnum.hpp"
#include "JOldEnum.hpp"
#include <functional>
#include "JFunc_void_double.hpp"
#include <NitroModules/JNICallable.hpp>
#include "JVariant_String_Double.hpp"
#include "Person.hpp"
#include "JVariant_HybridTestObjectSwiftKotlinSpec_Person.hpp"
#include "JPerson.hpp"
#include "PartialPerson.hpp"
#include "JPartialPerson.hpp"
#include "HybridChildSpec.hpp"
#include "JHybridChildSpec.hpp"
#include "JFunc_void.hpp"
#include <NitroModules/AnyMap.hpp>
#include <NitroModules/JAnyMap.hpp>
#include <NitroModules/Promise.hpp>
#include <NitroModules/JPromise.hpp>
#include <NitroModules/ArrayBuffer.hpp>
#include <NitroModules/JArrayBuffer.hpp>
#include <unordered_map>
#include "JVariant_Boolean_Double.hpp"
#include <NitroModules/JUnit.hpp>
#include <chrono>
#include <NitroModules/JInstant.hpp>
#include "Car.hpp"
#include "JCar.hpp"
#include "WrappedJsStruct.hpp"
#include "JWrappedJsStruct.hpp"
#include "JsStyleStruct.hpp"
#include "JJsStyleStruct.hpp"
#include "OptionalWrapper.hpp"
#include "JOptionalWrapper.hpp"
#include "OptionalCallback.hpp"
#include "JOptionalCallback.hpp"
#include "JVariant_______Unit_Double.hpp"
#include "JVariant_Boolean_OldEnum.hpp"
#include "WeirdNumbersEnum.hpp"
#include "JVariant_Boolean_WeirdNumbersEnum.hpp"
#include "JWeirdNumbersEnum.hpp"
#include "JVariant_Car_Person.hpp"
#include "JNamedVariant.hpp"
#include "HybridBaseSpec.hpp"
#include "JVariant_HybridBaseSpec_OptionalWrapper.hpp"
#include "JHybridBaseSpec.hpp"
#include "JCoreTypesVariant.hpp"
#include <NitroTestExternal/HybridSomeExternalObjectSpec.hpp>
#include <NitroTestExternal/JHybridSomeExternalObjectSpec.hpp>
#include "ExternalObjectStruct.hpp"
#include "JExternalObjectStruct.hpp"
#include "JStringOrExternal.hpp"
#include "JFunc_void_std__vector_Powertrain_.hpp"
#include "MapWrapper.hpp"
#include "JMapWrapper.hpp"
#include "SecondMapWrapper.hpp"
#include "JSecondMapWrapper.hpp"
#include <exception>
#include "JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_void____.hpp"
#include "JFunc_void_std__optional_double_.hpp"
#include "JFunc_std__shared_ptr_Promise_double__.hpp"
#include "JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_double____.hpp"
#include "JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer_____.hpp"
#include "JFunc_void_std__string.hpp"
#include "JFunc_void_std__exception_ptr.hpp"
#include "JFunc_std__shared_ptr_Promise_std__string__.hpp"
#include "JVariant_Boolean_DoubleArray_Array_String__String_Double.hpp"
#include "JFunc_double.hpp"
#include "HybridTestViewSpec.hpp"
#include "JHybridTestViewSpec.hpp"
#include "JFunc_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_.hpp"

namespace margelo::nitro::test {

  jni::local_ref<JHybridTestObjectSwiftKotlinSpec::jhybriddata> JHybridTestObjectSwiftKotlinSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridTestObjectSwiftKotlinSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridTestObjectSwiftKotlinSpec::initHybrid),
    });
  }

  size_t JHybridTestObjectSwiftKotlinSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  void JHybridTestObjectSwiftKotlinSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  std::string JHybridTestObjectSwiftKotlinSpec::toString() {
    static const auto method = javaClassStatic()->getMethod<jni::JString()>("toString");
    auto javaString = method(_javaPart);
    return nitro::JNIConverter<std::string>::fromJNI(javaString);
  }

  // Properties
  std::shared_ptr<HybridTestObjectSwiftKotlinSpec> JHybridTestObjectSwiftKotlinSpec::getThisObject() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridTestObjectSwiftKotlinSpec::javaobject>()>("getThisObject");
    auto __result = method(_javaPart);
    return __result->cthis()->shared_cast<JHybridTestObjectSwiftKotlinSpec>();
  }
  std::optional<std::shared_ptr<HybridTestObjectSwiftKotlinSpec>> JHybridTestObjectSwiftKotlinSpec::getOptionalHybrid() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridTestObjectSwiftKotlinSpec::javaobject>()>("getOptionalHybrid");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->cthis()->shared_cast<JHybridTestObjectSwiftKotlinSpec>()) : std::nullopt;
  }
  void JHybridTestObjectSwiftKotlinSpec::setOptionalHybrid(const std::optional<std::shared_ptr<HybridTestObjectSwiftKotlinSpec>>& optionalHybrid) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JHybridTestObjectSwiftKotlinSpec::javaobject> /* optionalHybrid */)>("setOptionalHybrid");
    method(_javaPart, optionalHybrid.has_value() ? std::dynamic_pointer_cast<JHybridTestObjectSwiftKotlinSpec>(optionalHybrid.value())->getJavaPart() : nullptr);
  }
  double JHybridTestObjectSwiftKotlinSpec::getNumberValue() {
    static const auto method = javaClassStatic()->getMethod<double()>("getNumberValue");
    auto __result = method(_javaPart);
    return __result;
  }
  void JHybridTestObjectSwiftKotlinSpec::setNumberValue(double numberValue) {
    static const auto method = javaClassStatic()->getMethod<void(double /* numberValue */)>("setNumberValue");
    method(_javaPart, numberValue);
  }
  bool JHybridTestObjectSwiftKotlinSpec::getBoolValue() {
    static const auto method = javaClassStatic()->getMethod<jboolean()>("getBoolValue");
    auto __result = method(_javaPart);
    return static_cast<bool>(__result);
  }
  void JHybridTestObjectSwiftKotlinSpec::setBoolValue(bool boolValue) {
    static const auto method = javaClassStatic()->getMethod<void(jboolean /* boolValue */)>("setBoolValue");
    method(_javaPart, boolValue);
  }
  std::string JHybridTestObjectSwiftKotlinSpec::getStringValue() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getStringValue");
    auto __result = method(_javaPart);
    return __result->toStdString();
  }
  void JHybridTestObjectSwiftKotlinSpec::setStringValue(const std::string& stringValue) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* stringValue */)>("setStringValue");
    method(_javaPart, jni::make_jstring(stringValue));
  }
  int64_t JHybridTestObjectSwiftKotlinSpec::getBigintValue() {
    static const auto method = javaClassStatic()->getMethod<int64_t()>("getBigintValue");
    auto __result = method(_javaPart);
    return __result;
  }
  void JHybridTestObjectSwiftKotlinSpec::setBigintValue(int64_t bigintValue) {
    static const auto method = javaClassStatic()->getMethod<void(int64_t /* bigintValue */)>("setBigintValue");
    method(_javaPart, bigintValue);
  }
  nitro::NullType JHybridTestObjectSwiftKotlinSpec::getNullValue() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JNull>()>("getNullValue");
    auto __result = method(_javaPart);
    return nitro::null;
  }
  void JHybridTestObjectSwiftKotlinSpec::setNullValue(nitro::NullType nullValue) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JNull> /* nullValue */)>("setNullValue");
    method(_javaPart, JNull::null());
  }
  std::optional<std::string> JHybridTestObjectSwiftKotlinSpec::getOptionalString() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getOptionalString");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridTestObjectSwiftKotlinSpec::setOptionalString(const std::optional<std::string>& optionalString) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* optionalString */)>("setOptionalString");
    method(_javaPart, optionalString.has_value() ? jni::make_jstring(optionalString.value()) : nullptr);
  }
  std::optional<std::string> JHybridTestObjectSwiftKotlinSpec::getStringOrUndefined() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getStringOrUndefined");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridTestObjectSwiftKotlinSpec::setStringOrUndefined(const std::optional<std::string>& stringOrUndefined) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* stringOrUndefined */)>("setStringOrUndefined");
    method(_javaPart, stringOrUndefined.has_value() ? jni::make_jstring(stringOrUndefined.value()) : nullptr);
  }
  std::variant<nitro::NullType, std::string> JHybridTestObjectSwiftKotlinSpec::getStringOrNull() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVariant_NullType_String>()>("getStringOrNull");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  void JHybridTestObjectSwiftKotlinSpec::setStringOrNull(const std::variant<nitro::NullType, std::string>& stringOrNull) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVariant_NullType_String> /* stringOrNull */)>("setStringOrNull");
    method(_javaPart, JVariant_NullType_String::fromCpp(stringOrNull));
  }
  std::optional<std::vector<std::string>> JHybridTestObjectSwiftKotlinSpec::getOptionalArray() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<jni::JString>>()>("getOptionalArray");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<std::string> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toStdString());
      }
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridTestObjectSwiftKotlinSpec::setOptionalArray(const std::optional<std::vector<std::string>>& optionalArray) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayClass<jni::JString>> /* optionalArray */)>("setOptionalArray");
    method(_javaPart, optionalArray.has_value() ? [&]() {
      size_t __size = optionalArray.value().size();
      jni::local_ref<jni::JArrayClass<jni::JString>> __array = jni::JArrayClass<jni::JString>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = optionalArray.value()[__i];
        auto __elementJni = jni::make_jstring(__element);
        __array->setElement(__i, *__elementJni);
      }
      return __array;
    }() : nullptr);
  }
  std::optional<Powertrain> JHybridTestObjectSwiftKotlinSpec::getOptionalEnum() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPowertrain>()>("getOptionalEnum");
    auto __result = method(_javaPart);
    return JNIConverter<std::optional<Powertrain>>::fromJNI<JPowertrain>(__result);
  }
  void JHybridTestObjectSwiftKotlinSpec::setOptionalEnum(std::optional<Powertrain> optionalEnum) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JPowertrain> /* optionalEnum */)>("setOptionalEnum");
    method(_javaPart, JNIConverter<std::optional<JPowertrain>>::toJNI<JPowertrain>(optionalEnum));
  }
  std::optional<OldEnum> JHybridTestObjectSwiftKotlinSpec::getOptionalOldEnum() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JOldEnum>()>("getOptionalOldEnum");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridTestObjectSwiftKotlinSpec::setOptionalOldEnum(std::optional<OldEnum> optionalOldEnum) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JOldEnum> /* optionalOldEnum */)>("setOptionalOldEnum");
    method(_javaPart, optionalOldEnum.has_value() ? JOldEnum::fromCpp(optionalOldEnum.value()) : nullptr);
  }
  std::optional<std::function<void(double /* value */)>> JHybridTestObjectSwiftKotlinSpec::getOptionalCallback() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_double::javaobject>()>("getOptionalCallback_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(double /* value */)> {
      if (__result->isInstanceOf(JFunc_void_double_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_double_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return JNICallable<JFunc_void_double, void(double)>(std::move(__resultRef));
      }
    }()) : std::nullopt;
  }
  void JHybridTestObjectSwiftKotlinSpec::setOptionalCallback(const std::optional<std::function<void(double /* value */)>>& optionalCallback) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_double::javaobject> /* optionalCallback */)>("setOptionalCallback_cxx");
    method(_javaPart, optionalCallback.has_value() ? JFunc_void_double_cxx::fromCpp(optionalCallback.value()) : nullptr);
  }
  std::variant<std::string, double> JHybridTestObjectSwiftKotlinSpec::getSomeVariant() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVariant_String_Double>()>("getSomeVariant");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  void JHybridTestObjectSwiftKotlinSpec::setSomeVariant(const std::variant<std::string, double>& someVariant) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVariant_String_Double> /* someVariant */)>("setSomeVariant");
    method(_javaPart, JVariant_String_Double::fromCpp(someVariant));
  }

  // Methods
  std::shared_ptr<HybridTestObjectSwiftKotlinSpec> JHybridTestObjectSwiftKotlinSpec::newTestObject() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridTestObjectSwiftKotlinSpec::javaobject>()>("newTestObject");
    auto __result = method(_javaPart);
    return __result->cthis()->shared_cast<JHybridTestObjectSwiftKotlinSpec>();
  }
  std::variant<std::shared_ptr<HybridTestObjectSwiftKotlinSpec>, Person> JHybridTestObjectSwiftKotlinSpec::getVariantHybrid(const std::variant<std::shared_ptr<HybridTestObjectSwiftKotlinSpec>, Person>& variant) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVariant_HybridTestObjectSwiftKotlinSpec_Person>(jni::alias_ref<JVariant_HybridTestObjectSwiftKotlinSpec_Person> /* variant */)>("getVariantHybrid");
    auto __result = method(_javaPart, JVariant_HybridTestObjectSwiftKotlinSpec_Person::fromCpp(variant));
    return __result->toCpp();
  }
  void JHybridTestObjectSwiftKotlinSpec::simpleFunc() {
    static const auto method = javaClassStatic()->getMethod<void()>("simpleFunc");
    method(_javaPart);
  }
  double JHybridTestObjectSwiftKotlinSpec::addNumbers(double a, double b) {
    static const auto method = javaClassStatic()->getMethod<double(double /* a */, double /* b */)>("addNumbers");
    auto __result = method(_javaPart, a, b);
    return __result;
  }
  std::string JHybridTestObjectSwiftKotlinSpec::addStrings(const std::string& a, const std::string& b) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>(jni::alias_ref<jni::JString> /* a */, jni::alias_ref<jni::JString> /* b */)>("addStrings");
    auto __result = method(_javaPart, jni::make_jstring(a), jni::make_jstring(b));
    return __result->toStdString();
  }
  void JHybridTestObjectSwiftKotlinSpec::multipleArguments(double num, const std::string& str, bool boo) {
    static const auto method = javaClassStatic()->getMethod<void(double /* num */, jni::alias_ref<jni::JString> /* str */, jboolean /* boo */)>("multipleArguments");
    method(_javaPart, num, jni::make_jstring(str), boo);
  }
  nitro::NullType JHybridTestObjectSwiftKotlinSpec::bounceNull(nitro::NullType value) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JNull>(jni::alias_ref<JNull> /* value */)>("bounceNull");
    auto __result = method(_javaPart, JNull::null());
    return nitro::null;
  }
  std::vector<std::string> JHybridTestObjectSwiftKotlinSpec::bounceStrings(const std::vector<std::string>& array) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<jni::JString>>(jni::alias_ref<jni::JArrayClass<jni::JString>> /* array */)>("bounceStrings");
    auto __result = method(_javaPart, [&]() {
      size_t __size = array.size();
      jni::local_ref<jni::JArrayClass<jni::JString>> __array = jni::JArrayClass<jni::JString>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = array[__i];
        auto __elementJni = jni::make_jstring(__element);
        __array->setElement(__i, *__elementJni);
      }
      return __array;
    }());
    return [&]() {
      size_t __size = __result->size();
      std::vector<std::string> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toStdString());
      }
      return __vector;
    }();
  }
  std::vector<double> JHybridTestObjectSwiftKotlinSpec::bounceNumbers(const std::vector<double>& array) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>(jni::alias_ref<jni::JArrayDouble> /* array */)>("bounceNumbers");
    auto __result = method(_javaPart, [&]() {
      size_t __size = array.size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, array.data());
      return __array;
    }());
    return [&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }();
  }
  std::vector<Person> JHybridTestObjectSwiftKotlinSpec::bounceStructs(const std::vector<Person>& array) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JPerson>>(jni::alias_ref<jni::JArrayClass<JPerson>> /* array */)>("bounceStructs");
    auto __result = method(_javaPart, [&]() {
      size_t __size = array.size();
      jni::local_ref<jni::JArrayClass<JPerson>> __array = jni::JArrayClass<JPerson>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = array[__i];
        auto __elementJni = JPerson::fromCpp(__element);
        __array->setElement(__i, *__elementJni);
      }
      return __array;
    }());
    return [&]() {
      size_t __size = __result->size();
      std::vector<Person> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toCpp());
      }
      return __vector;
    }();
  }
  PartialPerson JHybridTestObjectSwiftKotlinSpec::bouncePartialStruct(const PartialPerson& person) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPartialPerson>(jni::alias_ref<JPartialPerson> /* person */)>("bouncePartialStruct");
    auto __result = method(_javaPart, JPartialPerson::fromCpp(person));
    return __result->toCpp();
  }
  std::string JHybridTestObjectSwiftKotlinSpec::sumUpAllPassengers(const std::vector<Car>& cars) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>(jni::alias_ref<jni::JArrayClass<JCar>> /* cars */)>("sumUpAllPassengers");
    auto __result = method(_javaPart, [&]() {
      size_t __size = cars.size();
      jni::local_ref<jni::JArrayClass<JCar>> __array = jni::JArrayClass<JCar>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = cars[__i];
        auto __elementJni = JCar::fromCpp(__element);
        __array->setElement(__i, *__elementJni);
      }
      return __array;
    }());
    return __result->toStdString();
  }
  std::vector<Powertrain> JHybridTestObjectSwiftKotlinSpec::bounceEnums(const std::vector<Powertrain>& array) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JPowertrain>>(jni::alias_ref<jni::JArrayClass<JPowertrain>> /* array */)>("bounceEnums");
    auto __result = method(_javaPart, [&]() {
      size_t __size = array.size();
      jni::local_ref<jni::JArrayClass<JPowertrain>> __array = jni::JArrayClass<JPowertrain>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = array[__i];
        auto __elementJni = JPowertrain::fromCpp(__element);
        __array->setElement(__i, *__elementJni);
      }
      return __array;
    }());
    return [&]() {
      size_t __size = __result->size();
      std::vector<Powertrain> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toCpp());
      }
      return __vector;
    }();
  }
  void JHybridTestObjectSwiftKotlinSpec::complexEnumCallback(const std::vector<Powertrain>& array, const std::function<void(const std::vector<Powertrain>& /* array */)>& callback) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayClass<JPowertrain>> /* array */, jni::alias_ref<JFunc_void_std__vector_Powertrain_::javaobject> /* callback */)>("complexEnumCallback_cxx");
    method(_javaPart, [&]() {
      size_t __size = array.size();
      jni::local_ref<jni::JArrayClass<JPowertrain>> __array = jni::JArrayClass<JPowertrain>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = array[__i];
        auto __elementJni = JPowertrain::fromCpp(__element);
        __array->setElement(__i, *__elementJni);
      }
      return __array;
    }(), JFunc_void_std__vector_Powertrain__cxx::fromCpp(callback));
  }
  std::vector<std::shared_ptr<HybridChildSpec>> JHybridTestObjectSwiftKotlinSpec::bounceHybridObjects(const std::vector<std::shared_ptr<HybridChildSpec>>& array) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JHybridChildSpec::javaobject>>(jni::alias_ref<jni::JArrayClass<JHybridChildSpec::javaobject>> /* array */)>("bounceHybridObjects");
    auto __result = method(_javaPart, [&]() {
      size_t __size = array.size();
      jni::local_ref<jni::JArrayClass<JHybridChildSpec::javaobject>> __array = jni::JArrayClass<JHybridChildSpec::javaobject>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = array[__i];
        auto __elementJni = std::dynamic_pointer_cast<JHybridChildSpec>(__element)->getJavaPart();
        __array->setElement(__i, __elementJni.get());
      }
      return __array;
    }());
    return [&]() {
      size_t __size = __result->size();
      std::vector<std::shared_ptr<HybridChildSpec>> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->cthis()->shared_cast<JHybridChildSpec>());
      }
      return __vector;
    }();
  }
  std::vector<std::function<void()>> JHybridTestObjectSwiftKotlinSpec::bounceFunctions(const std::vector<std::function<void()>>& functions) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JFunc_void::javaobject>>(jni::alias_ref<jni::JArrayClass<JFunc_void::javaobject>> /* functions */)>("bounceFunctions_cxx");
    auto __result = method(_javaPart, [&]() {
      size_t __size = functions.size();
      jni::local_ref<jni::JArrayClass<JFunc_void::javaobject>> __array = jni::JArrayClass<JFunc_void::javaobject>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = functions[__i];
        auto __elementJni = JFunc_void_cxx::fromCpp(__element);
        __array->setElement(__i, __elementJni.get());
      }
      return __array;
    }());
    return [&]() {
      size_t __size = __result->size();
      std::vector<std::function<void()>> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back([&]() -> std::function<void()> {
      if (__element->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__element);
        return downcast->cthis()->getFunction();
      } else {
        auto __elementRef = jni::make_global(__element);
        return JNICallable<JFunc_void, void()>(std::move(__elementRef));
      }
    }());
      }
      return __vector;
    }();
  }
  std::vector<std::shared_ptr<AnyMap>> JHybridTestObjectSwiftKotlinSpec::bounceMaps(const std::vector<std::shared_ptr<AnyMap>>& maps) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JAnyMap::javaobject>>(jni::alias_ref<jni::JArrayClass<JAnyMap::javaobject>> /* maps */)>("bounceMaps");
    auto __result = method(_javaPart, [&]() {
      size_t __size = maps.size();
      jni::local_ref<jni::JArrayClass<JAnyMap::javaobject>> __array = jni::JArrayClass<JAnyMap::javaobject>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = maps[__i];
        auto __elementJni = JAnyMap::create(__element);
        __array->setElement(__i, __elementJni.get());
      }
      return __array;
    }());
    return [&]() {
      size_t __size = __result->size();
      std::vector<std::shared_ptr<AnyMap>> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->cthis()->getMap());
      }
      return __vector;
    }();
  }
  std::vector<std::shared_ptr<Promise<double>>> JHybridTestObjectSwiftKotlinSpec::bouncePromises(const std::vector<std::shared_ptr<Promise<double>>>& promises) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JPromise::javaobject>>(jni::alias_ref<jni::JArrayClass<JPromise::javaobject>> /* promises */)>("bouncePromises");
    auto __result = method(_javaPart, [&]() {
      size_t __size = promises.size();
      jni::local_ref<jni::JArrayClass<JPromise::javaobject>> __array = jni::JArrayClass<JPromise::javaobject>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = promises[__i];
        auto __elementJni = [&]() {
          jni::local_ref<JPromise::javaobject> __localPromise = JPromise::create();
          jni::global_ref<JPromise::javaobject> __promise = jni::make_global(__localPromise);
          __element->addOnResolvedListener([=](const double& __result) {
            __promise->cthis()->resolve(jni::JDouble::valueOf(__result));
          });
          __element->addOnRejectedListener([=](const std::exception_ptr& __error) {
            auto __jniError = jni::getJavaExceptionForCppException(__error);
            __promise->cthis()->reject(__jniError);
          });
          return __localPromise;
        }();
        __array->setElement(__i, __elementJni.get());
      }
      return __array;
    }());
    return [&]() {
      size_t __size = __result->size();
      std::vector<std::shared_ptr<Promise<double>>> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back([&]() {
      auto __promise = Promise<double>::create();
      __element->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JDouble>(__boxedResult);
        __promise->resolve(__result->value());
      });
      __element->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }());
      }
      return __vector;
    }();
  }
  std::vector<std::shared_ptr<ArrayBuffer>> JHybridTestObjectSwiftKotlinSpec::bounceArrayBuffers(const std::vector<std::shared_ptr<ArrayBuffer>>& arrayBuffers) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JArrayBuffer::javaobject>>(jni::alias_ref<jni::JArrayClass<JArrayBuffer::javaobject>> /* arrayBuffers */)>("bounceArrayBuffers");
    auto __result = method(_javaPart, [&]() {
      size_t __size = arrayBuffers.size();
      jni::local_ref<jni::JArrayClass<JArrayBuffer::javaobject>> __array = jni::JArrayClass<JArrayBuffer::javaobject>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = arrayBuffers[__i];
        auto __elementJni = JArrayBuffer::wrap(__element);
        __array->setElement(__i, __elementJni.get());
      }
      return __array;
    }());
    return [&]() {
      size_t __size = __result->size();
      std::vector<std::shared_ptr<ArrayBuffer>> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->cthis()->getArrayBuffer());
      }
      return __vector;
    }();
  }
  std::shared_ptr<AnyMap> JHybridTestObjectSwiftKotlinSpec::createMap() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JAnyMap::javaobject>()>("createMap");
    auto __result = method(_javaPart);
    return __result->cthis()->getMap();
  }
  std::shared_ptr<AnyMap> JHybridTestObjectSwiftKotlinSpec::mapRoundtrip(const std::shared_ptr<AnyMap>& map) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JAnyMap::javaobject>(jni::alias_ref<JAnyMap::javaobject> /* map */)>("mapRoundtrip");
    auto __result = method(_javaPart, JAnyMap::create(map));
    return __result->cthis()->getMap();
  }
  std::vector<std::string> JHybridTestObjectSwiftKotlinSpec::getMapKeys(const std::shared_ptr<AnyMap>& map) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<jni::JString>>(jni::alias_ref<JAnyMap::javaobject> /* map */)>("getMapKeys");
    auto __result = method(_javaPart, JAnyMap::create(map));
    return [&]() {
      size_t __size = __result->size();
      std::vector<std::string> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toStdString());
      }
      return __vector;
    }();
  }
  std::shared_ptr<AnyMap> JHybridTestObjectSwiftKotlinSpec::mergeMaps(const std::shared_ptr<AnyMap>& a, const std::shared_ptr<AnyMap>& b) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JAnyMap::javaobject>(jni::alias_ref<JAnyMap::javaobject> /* a */, jni::alias_ref<JAnyMap::javaobject> /* b */)>("mergeMaps");
    auto __result = method(_javaPart, JAnyMap::create(a), JAnyMap::create(b));
    return __result->cthis()->getMap();
  }
  std::shared_ptr<AnyMap> JHybridTestObjectSwiftKotlinSpec::copyAnyMap(const std::shared_ptr<AnyMap>& map) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JAnyMap::javaobject>(jni::alias_ref<JAnyMap::javaobject> /* map */)>("copyAnyMap");
    auto __result = method(_javaPart, JAnyMap::create(map));
    return __result->cthis()->getMap();
  }
  std::unordered_map<std::string, std::variant<bool, double>> JHybridTestObjectSwiftKotlinSpec::bounceMap(const std::unordered_map<std::string, std::variant<bool, double>>& map) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JMap<jni::JString, JVariant_Boolean_Double>>(jni::alias_ref<jni::JMap<jni::JString, JVariant_Boolean_Double>> /* map */)>("bounceMap");
    auto __result = method(_javaPart, [&]() -> jni::local_ref<jni::JMap<jni::JString, JVariant_Boolean_Double>> {
      auto __map = jni::JHashMap<jni::JString, JVariant_Boolean_Double>::create(map.size());
      for (const auto& __entry : map) {
        __map->put(jni::make_jstring(__entry.first), JVariant_Boolean_Double::fromCpp(__entry.second));
      }
      return __map;
    }());
    return [&]() {
      std::unordered_map<std::string, std::variant<bool, double>> __map;
      __map.reserve(__result->size());
      for (const auto& __entry : *__result) {
        __map.emplace(__entry.first->toStdString(), __entry.second->toCpp());
      }
      return __map;
    }();
  }
  std::unordered_map<std::string, double> JHybridTestObjectSwiftKotlinSpec::bounceSimpleMap(const std::unordered_map<std::string, double>& map) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JMap<jni::JString, jni::JDouble>>(jni::alias_ref<jni::JMap<jni::JString, jni::JDouble>> /* map */)>("bounceSimpleMap");
    auto __result = method(_javaPart, [&]() -> jni::local_ref<jni::JMap<jni::JString, jni::JDouble>> {
      auto __map = jni::JHashMap<jni::JString, jni::JDouble>::create(map.size());
      for (const auto& __entry : map) {
        __map->put(jni::make_jstring(__entry.first), jni::JDouble::valueOf(__entry.second));
      }
      return __map;
    }());
    return [&]() {
      std::unordered_map<std::string, double> __map;
      __map.reserve(__result->size());
      for (const auto& __entry : *__result) {
        __map.emplace(__entry.first->toStdString(), __entry.second->value());
      }
      return __map;
    }();
  }
  std::unordered_map<std::string, std::string> JHybridTestObjectSwiftKotlinSpec::extractMap(const MapWrapper& mapWrapper) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JMap<jni::JString, jni::JString>>(jni::alias_ref<JMapWrapper> /* mapWrapper */)>("extractMap");
    auto __result = method(_javaPart, JMapWrapper::fromCpp(mapWrapper));
    return [&]() {
      std::unordered_map<std::string, std::string> __map;
      __map.reserve(__result->size());
      for (const auto& __entry : *__result) {
        __map.emplace(__entry.first->toStdString(), __entry.second->toStdString());
      }
      return __map;
    }();
  }
  double JHybridTestObjectSwiftKotlinSpec::funcThatThrows() {
    static const auto method = javaClassStatic()->getMethod<double()>("funcThatThrows");
    auto __result = method(_javaPart);
    return __result;
  }
  std::shared_ptr<Promise<void>> JHybridTestObjectSwiftKotlinSpec::funcThatThrowsBeforePromise() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("funcThatThrowsBeforePromise");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  void JHybridTestObjectSwiftKotlinSpec::throwError(const std::exception_ptr& error) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JThrowable> /* error */)>("throwError");
    method(_javaPart, jni::getJavaExceptionForCppException(error));
  }
  std::string JHybridTestObjectSwiftKotlinSpec::tryOptionalParams(double num, bool boo, const std::optional<std::string>& str) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>(double /* num */, jboolean /* boo */, jni::alias_ref<jni::JString> /* str */)>("tryOptionalParams");
    auto __result = method(_javaPart, num, boo, str.has_value() ? jni::make_jstring(str.value()) : nullptr);
    return __result->toStdString();
  }
  std::string JHybridTestObjectSwiftKotlinSpec::tryMiddleParam(double num, std::optional<bool> boo, const std::string& str) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>(double /* num */, jni::alias_ref<jni::JBoolean> /* boo */, jni::alias_ref<jni::JString> /* str */)>("tryMiddleParam");
    auto __result = method(_javaPart, num, boo.has_value() ? jni::JBoolean::valueOf(boo.value()) : nullptr, jni::make_jstring(str));
    return __result->toStdString();
  }
  std::optional<Powertrain> JHybridTestObjectSwiftKotlinSpec::tryOptionalEnum(std::optional<Powertrain> value) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPowertrain>(jni::alias_ref<JPowertrain> /* value */)>("tryOptionalEnum");
    auto __result = method(_javaPart, value.has_value() ? JPowertrain::fromCpp(value.value()) : nullptr);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  bool JHybridTestObjectSwiftKotlinSpec::tryTrailingOptional(double num, const std::string& str, std::optional<bool> boo) {
    static const auto method = javaClassStatic()->getMethod<jboolean(double /* num */, jni::alias_ref<jni::JString> /* str */, jni::alias_ref<jni::JBoolean> /* boo */)>("tryTrailingOptional");
    auto __result = method(_javaPart, num, jni::make_jstring(str), boo.has_value() ? jni::JBoolean::valueOf(boo.value()) : nullptr);
    return static_cast<bool>(__result);
  }
  std::chrono::system_clock::time_point JHybridTestObjectSwiftKotlinSpec::add1Hour(std::chrono::system_clock::time_point date) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JInstant>(jni::alias_ref<JInstant> /* date */)>("add1Hour");
    auto __result = method(_javaPart, JInstant::fromChrono(date));
    return __result->toChrono();
  }
  std::chrono::system_clock::time_point JHybridTestObjectSwiftKotlinSpec::currentDate() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JInstant>()>("currentDate");
    auto __result = method(_javaPart);
    return __result->toChrono();
  }
  int64_t JHybridTestObjectSwiftKotlinSpec::calculateFibonacciSync(double value) {
    static const auto method = javaClassStatic()->getMethod<int64_t(double /* value */)>("calculateFibonacciSync");
    auto __result = method(_javaPart, value);
    return __result;
  }
  std::shared_ptr<Promise<int64_t>> JHybridTestObjectSwiftKotlinSpec::calculateFibonacciAsync(double value) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(double /* value */)>("calculateFibonacciAsync");
    auto __result = method(_javaPart, value);
    return [&]() {
      auto __promise = Promise<int64_t>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JLong>(__boxedResult);
        __promise->resolve(__result->value());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<void>> JHybridTestObjectSwiftKotlinSpec::wait(double seconds) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(double /* seconds */)>("wait");
    auto __result = method(_javaPart, seconds);
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<void>> JHybridTestObjectSwiftKotlinSpec::promiseThrows() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("promiseThrows");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<double>> JHybridTestObjectSwiftKotlinSpec::promiseReturnsInstantly() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("promiseReturnsInstantly");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<double>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JDouble>(__boxedResult);
        __promise->resolve(__result->value());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<double>> JHybridTestObjectSwiftKotlinSpec::promiseReturnsInstantlyAsync() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("promiseReturnsInstantlyAsync");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<double>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JDouble>(__boxedResult);
        __promise->resolve(__result->value());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<void>> JHybridTestObjectSwiftKotlinSpec::promiseThatResolvesVoidInstantly() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("promiseThatResolvesVoidInstantly");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<double>>> JHybridTestObjectSwiftKotlinSpec::promiseThatResolvesToUndefined() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("promiseThatResolvesToUndefined");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::optional<double>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JDouble>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->value()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<double>> JHybridTestObjectSwiftKotlinSpec::awaitAndGetPromise(const std::shared_ptr<Promise<double>>& promise) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JPromise::javaobject> /* promise */)>("awaitAndGetPromise");
    auto __result = method(_javaPart, [&]() {
      jni::local_ref<JPromise::javaobject> __localPromise = JPromise::create();
      jni::global_ref<JPromise::javaobject> __promise = jni::make_global(__localPromise);
      promise->addOnResolvedListener([=](const double& __result) {
        __promise->cthis()->resolve(jni::JDouble::valueOf(__result));
      });
      promise->addOnRejectedListener([=](const std::exception_ptr& __error) {
        auto __jniError = jni::getJavaExceptionForCppException(__error);
        __promise->cthis()->reject(__jniError);
      });
      return __localPromise;
    }());
    return [&]() {
      auto __promise = Promise<double>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JDouble>(__boxedResult);
        __promise->resolve(__result->value());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<Car>> JHybridTestObjectSwiftKotlinSpec::awaitAndGetComplexPromise(const std::shared_ptr<Promise<Car>>& promise) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JPromise::javaobject> /* promise */)>("awaitAndGetComplexPromise");
    auto __result = method(_javaPart, [&]() {
      jni::local_ref<JPromise::javaobject> __localPromise = JPromise::create();
      jni::global_ref<JPromise::javaobject> __promise = jni::make_global(__localPromise);
      promise->addOnResolvedListener([=](const Car& __result) {
        __promise->cthis()->resolve(JCar::fromCpp(__result));
      });
      promise->addOnRejectedListener([=](const std::exception_ptr& __error) {
        auto __jniError = jni::getJavaExceptionForCppException(__error);
        __promise->cthis()->reject(__jniError);
      });
      return __localPromise;
    }());
    return [&]() {
      auto __promise = Promise<Car>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JCar>(__boxedResult);
        __promise->resolve(__result->toCpp());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<void>> JHybridTestObjectSwiftKotlinSpec::awaitPromise(const std::shared_ptr<Promise<void>>& promise) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JPromise::javaobject> /* promise */)>("awaitPromise");
    auto __result = method(_javaPart, [&]() {
      jni::local_ref<JPromise::javaobject> __localPromise = JPromise::create();
      jni::global_ref<JPromise::javaobject> __promise = jni::make_global(__localPromise);
      promise->addOnResolvedListener([=]() {
        __promise->cthis()->resolve(JUnit::instance());
      });
      promise->addOnRejectedListener([=](const std::exception_ptr& __error) {
        auto __jniError = jni::getJavaExceptionForCppException(__error);
        __promise->cthis()->reject(__jniError);
      });
      return __localPromise;
    }());
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  void JHybridTestObjectSwiftKotlinSpec::callCallback(const std::function<void()>& callback) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void::javaobject> /* callback */)>("callCallback_cxx");
    method(_javaPart, JFunc_void_cxx::fromCpp(callback));
  }
  std::shared_ptr<Promise<void>> JHybridTestObjectSwiftKotlinSpec::callCallbackThatReturnsPromiseVoid(const std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<void>>>>()>& callback) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_void____::javaobject> /* callback */)>("callCallbackThatReturnsPromiseVoid_cxx");
    auto __result = method(_javaPart, JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_void_____cxx::fromCpp(callback));
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  void JHybridTestObjectSwiftKotlinSpec::callAll(const std::function<void()>& first, const std::function<void()>& second, const std::function<void()>& third) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void::javaobject> /* first */, jni::alias_ref<JFunc_void::javaobject> /* second */, jni::alias_ref<JFunc_void::javaobject> /* third */)>("callAll_cxx");
    method(_javaPart, JFunc_void_cxx::fromCpp(first), JFunc_void_cxx::fromCpp(second), JFunc_void_cxx::fromCpp(third));
  }
  void JHybridTestObjectSwiftKotlinSpec::callWithOptional(std::optional<double> value, const std::function<void(std::optional<double> /* maybe */)>& callback) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* value */, jni::alias_ref<JFunc_void_std__optional_double_::javaobject> /* callback */)>("callWithOptional_cxx");
    method(_javaPart, value.has_value() ? jni::JDouble::valueOf(value.value()) : nullptr, JFunc_void_std__optional_double__cxx::fromCpp(callback));
  }
  std::shared_ptr<Promise<double>> JHybridTestObjectSwiftKotlinSpec::callSumUpNTimes(const std::function<std::shared_ptr<Promise<double>>()>& callback, double n) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JFunc_std__shared_ptr_Promise_double__::javaobject> /* callback */, double /* n */)>("callSumUpNTimes_cxx");
    auto __result = method(_javaPart, JFunc_std__shared_ptr_Promise_double___cxx::fromCpp(callback), n);
    return [&]() {
      auto __promise = Promise<double>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JDouble>(__boxedResult);
        __promise->resolve(__result->value());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<double>> JHybridTestObjectSwiftKotlinSpec::callbackAsyncPromise(const std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<double>>>>()>& callback) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_double____::javaobject> /* callback */)>("callbackAsyncPromise_cxx");
    auto __result = method(_javaPart, JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_double_____cxx::fromCpp(callback));
    return [&]() {
      auto __promise = Promise<double>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JDouble>(__boxedResult);
        __promise->resolve(__result->value());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>> JHybridTestObjectSwiftKotlinSpec::callbackAsyncPromiseBuffer(const std::function<std::shared_ptr<Promise<std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>>>>()>& callback) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer_____::javaobject> /* callback */)>("callbackAsyncPromiseBuffer_cxx");
    auto __result = method(_javaPart, JFunc_std__shared_ptr_Promise_std__shared_ptr_Promise_std__shared_ptr_ArrayBuffer______cxx::fromCpp(callback));
    return [&]() {
      auto __promise = Promise<std::shared_ptr<ArrayBuffer>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JArrayBuffer::javaobject>(__boxedResult);
        __promise->resolve(__result->cthis()->getArrayBuffer());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::function<void(double /* value */)> JHybridTestObjectSwiftKotlinSpec::getComplexCallback() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_double::javaobject>()>("getComplexCallback_cxx");
    auto __result = method(_javaPart);
    return [&]() -> std::function<void(double /* value */)> {
      if (__result->isInstanceOf(JFunc_void_double_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_double_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return JNICallable<JFunc_void_double, void(double)>(std::move(__resultRef));
      }
    }();
  }
  void JHybridTestObjectSwiftKotlinSpec::twoOptionalCallbacks(double value, const std::optional<std::function<void(double /* value */)>>& first, const std::optional<std::function<void(const std::string& /* value */)>>& second) {
    static const auto method = javaClassStatic()->getMethod<void(double /* value */, jni::alias_ref<JFunc_void_double::javaobject> /* first */, jni::alias_ref<JFunc_void_std__string::javaobject> /* second */)>("twoOptionalCallbacks_cxx");
    method(_javaPart, value, first.has_value() ? JFunc_void_double_cxx::fromCpp(first.value()) : nullptr, second.has_value() ? JFunc_void_std__string_cxx::fromCpp(second.value()) : nullptr);
  }
  void JHybridTestObjectSwiftKotlinSpec::errorCallback(const std::function<void(const std::exception_ptr& /* error */)>& onError) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_std__exception_ptr::javaobject> /* onError */)>("errorCallback_cxx");
    method(_javaPart, JFunc_void_std__exception_ptr_cxx::fromCpp(onError));
  }
  std::function<void(double /* num */)> JHybridTestObjectSwiftKotlinSpec::createNativeCallback(const std::function<void(double /* num */)>& wrappingJsCallback) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_double::javaobject>(jni::alias_ref<JFunc_void_double::javaobject> /* wrappingJsCallback */)>("createNativeCallback_cxx");
    auto __result = method(_javaPart, JFunc_void_double_cxx::fromCpp(wrappingJsCallback));
    return [&]() -> std::function<void(double /* num */)> {
      if (__result->isInstanceOf(JFunc_void_double_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_double_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return JNICallable<JFunc_void_double, void(double)>(std::move(__resultRef));
      }
    }();
  }
  std::shared_ptr<Promise<double>> JHybridTestObjectSwiftKotlinSpec::getValueFromJSCallbackAndWait(const std::function<std::shared_ptr<Promise<double>>()>& getValue) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JFunc_std__shared_ptr_Promise_double__::javaobject> /* getValue */)>("getValueFromJSCallbackAndWait_cxx");
    auto __result = method(_javaPart, JFunc_std__shared_ptr_Promise_double___cxx::fromCpp(getValue));
    return [&]() {
      auto __promise = Promise<double>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JDouble>(__boxedResult);
        __promise->resolve(__result->value());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<void>> JHybridTestObjectSwiftKotlinSpec::getValueFromJsCallback(const std::function<std::shared_ptr<Promise<std::string>>()>& callback, const std::function<void(const std::string& /* valueFromJs */)>& andThenCall) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JFunc_std__shared_ptr_Promise_std__string__::javaobject> /* callback */, jni::alias_ref<JFunc_void_std__string::javaobject> /* andThenCall */)>("getValueFromJsCallback_cxx");
    auto __result = method(_javaPart, JFunc_std__shared_ptr_Promise_std__string___cxx::fromCpp(callback), JFunc_void_std__string_cxx::fromCpp(andThenCall));
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  Car JHybridTestObjectSwiftKotlinSpec::getCar() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JCar>()>("getCar");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  bool JHybridTestObjectSwiftKotlinSpec::isCarElectric(const Car& car) {
    static const auto method = javaClassStatic()->getMethod<jboolean(jni::alias_ref<JCar> /* car */)>("isCarElectric");
    auto __result = method(_javaPart, JCar::fromCpp(car));
    return static_cast<bool>(__result);
  }
  std::optional<Person> JHybridTestObjectSwiftKotlinSpec::getDriver(const Car& car) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPerson>(jni::alias_ref<JCar> /* car */)>("getDriver");
    auto __result = method(_javaPart, JCar::fromCpp(car));
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  Car JHybridTestObjectSwiftKotlinSpec::bounceCar(const Car& car) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JCar>(jni::alias_ref<JCar> /* car */)>("bounceCar");
    auto __result = method(_javaPart, JCar::fromCpp(car));
    return __result->toCpp();
  }
  void JHybridTestObjectSwiftKotlinSpec::jsStyleObjectAsParameters(const JsStyleStruct& params) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JJsStyleStruct> /* params */)>("jsStyleObjectAsParameters");
    method(_javaPart, JJsStyleStruct::fromCpp(params));
  }
  WrappedJsStruct JHybridTestObjectSwiftKotlinSpec::bounceWrappedJsStyleStruct(const WrappedJsStruct& value) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JWrappedJsStruct>(jni::alias_ref<JWrappedJsStruct> /* value */)>("bounceWrappedJsStyleStruct");
    auto __result = method(_javaPart, JWrappedJsStruct::fromCpp(value));
    return __result->toCpp();
  }
  OptionalWrapper JHybridTestObjectSwiftKotlinSpec::bounceOptionalWrapper(const OptionalWrapper& wrapper) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JOptionalWrapper>(jni::alias_ref<JOptionalWrapper> /* wrapper */)>("bounceOptionalWrapper");
    auto __result = method(_javaPart, JOptionalWrapper::fromCpp(wrapper));
    return __result->toCpp();
  }
  OptionalCallback JHybridTestObjectSwiftKotlinSpec::bounceOptionalCallback(const OptionalCallback& value) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JOptionalCallback>(jni::alias_ref<JOptionalCallback> /* value */)>("bounceOptionalCallback");
    auto __result = method(_javaPart, JOptionalCallback::fromCpp(value));
    return __result->toCpp();
  }
  std::shared_ptr<ArrayBuffer> JHybridTestObjectSwiftKotlinSpec::createArrayBuffer() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JArrayBuffer::javaobject>()>("createArrayBuffer");
    auto __result = method(_javaPart);
    return __result->cthis()->getArrayBuffer();
  }
  std::shared_ptr<ArrayBuffer> JHybridTestObjectSwiftKotlinSpec::createArrayBufferFromNativeBuffer(bool copy) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JArrayBuffer::javaobject>(jboolean /* copy */)>("createArrayBufferFromNativeBuffer");
    auto __result = method(_javaPart, copy);
    return __result->cthis()->getArrayBuffer();
  }
  std::shared_ptr<ArrayBuffer> JHybridTestObjectSwiftKotlinSpec::copyBuffer(const std::shared_ptr<ArrayBuffer>& buffer) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JArrayBuffer::javaobject>(jni::alias_ref<JArrayBuffer::javaobject> /* buffer */)>("copyBuffer");
    auto __result = method(_javaPart, JArrayBuffer::wrap(buffer));
    return __result->cthis()->getArrayBuffer();
  }
  double JHybridTestObjectSwiftKotlinSpec::getBufferLastItem(const std::shared_ptr<ArrayBuffer>& buffer) {
    static const auto method = javaClassStatic()->getMethod<double(jni::alias_ref<JArrayBuffer::javaobject> /* buffer */)>("getBufferLastItem");
    auto __result = method(_javaPart, JArrayBuffer::wrap(buffer));
    return __result;
  }
  void JHybridTestObjectSwiftKotlinSpec::setAllValuesTo(const std::shared_ptr<ArrayBuffer>& buffer, double value) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JArrayBuffer::javaobject> /* buffer */, double /* value */)>("setAllValuesTo");
    method(_javaPart, JArrayBuffer::wrap(buffer), value);
  }
  std::shared_ptr<Promise<std::shared_ptr<ArrayBuffer>>> JHybridTestObjectSwiftKotlinSpec::createArrayBufferAsync() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("createArrayBufferAsync");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::shared_ptr<ArrayBuffer>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JArrayBuffer::javaobject>(__boxedResult);
        __promise->resolve(__result->cthis()->getArrayBuffer());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<ArrayBuffer> JHybridTestObjectSwiftKotlinSpec::bounceArrayBuffer(const std::shared_ptr<ArrayBuffer>& buffer) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JArrayBuffer::javaobject>(jni::alias_ref<JArrayBuffer::javaobject> /* buffer */)>("bounceArrayBuffer");
    auto __result = method(_javaPart, JArrayBuffer::wrap(buffer));
    return __result->cthis()->getArrayBuffer();
  }
  std::variant<std::string, double> JHybridTestObjectSwiftKotlinSpec::passVariant(const std::variant<bool, std::vector<double>, std::vector<std::string>, std::string, double>& either) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVariant_String_Double>(jni::alias_ref<JVariant_Boolean_DoubleArray_Array_String__String_Double> /* either */)>("passVariant");
    auto __result = method(_javaPart, JVariant_Boolean_DoubleArray_Array_String__String_Double::fromCpp(either));
    return __result->toCpp();
  }
  std::variant<bool, OldEnum> JHybridTestObjectSwiftKotlinSpec::getVariantEnum(const std::variant<bool, OldEnum>& variant) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVariant_Boolean_OldEnum>(jni::alias_ref<JVariant_Boolean_OldEnum> /* variant */)>("getVariantEnum");
    auto __result = method(_javaPart, JVariant_Boolean_OldEnum::fromCpp(variant));
    return __result->toCpp();
  }
  std::variant<bool, WeirdNumbersEnum> JHybridTestObjectSwiftKotlinSpec::getVariantWeirdNumbersEnum(const std::variant<bool, WeirdNumbersEnum>& variant) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVariant_Boolean_WeirdNumbersEnum>(jni::alias_ref<JVariant_Boolean_WeirdNumbersEnum> /* variant */)>("getVariantWeirdNumbersEnum");
    auto __result = method(_javaPart, JVariant_Boolean_WeirdNumbersEnum::fromCpp(variant));
    return __result->toCpp();
  }
  std::variant<Car, Person> JHybridTestObjectSwiftKotlinSpec::getVariantObjects(const std::variant<Car, Person>& variant) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVariant_Car_Person>(jni::alias_ref<JVariant_Car_Person> /* variant */)>("getVariantObjects");
    auto __result = method(_javaPart, JVariant_Car_Person::fromCpp(variant));
    return __result->toCpp();
  }
  std::variant<std::string, Car> JHybridTestObjectSwiftKotlinSpec::passNamedVariant(const std::variant<std::string, Car>& variant) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JNamedVariant>(jni::alias_ref<JNamedVariant> /* variant */)>("passNamedVariant");
    auto __result = method(_javaPart, JNamedVariant::fromCpp(variant));
    return __result->toCpp();
  }
  std::variant<std::shared_ptr<HybridBaseSpec>, OptionalWrapper> JHybridTestObjectSwiftKotlinSpec::passAllEmptyObjectVariant(const std::variant<std::shared_ptr<HybridBaseSpec>, OptionalWrapper>& variant) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVariant_HybridBaseSpec_OptionalWrapper>(jni::alias_ref<JVariant_HybridBaseSpec_OptionalWrapper> /* variant */)>("passAllEmptyObjectVariant");
    auto __result = method(_javaPart, JVariant_HybridBaseSpec_OptionalWrapper::fromCpp(variant));
    return __result->toCpp();
  }
  std::variant<std::shared_ptr<ArrayBuffer>, std::function<void(double /* value */)>, WrappedJsStruct, std::shared_ptr<Promise<double>>, std::chrono::system_clock::time_point, std::shared_ptr<AnyMap>> JHybridTestObjectSwiftKotlinSpec::bounceComplexVariant(const std::variant<std::shared_ptr<ArrayBuffer>, std::function<void(double /* value */)>, WrappedJsStruct, std::shared_ptr<Promise<double>>, std::chrono::system_clock::time_point, std::shared_ptr<AnyMap>>& variant) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JCoreTypesVariant>(jni::alias_ref<JCoreTypesVariant> /* variant */)>("bounceComplexVariant");
    auto __result = method(_javaPart, JCoreTypesVariant::fromCpp(variant));
    return __result->toCpp();
  }
  std::shared_ptr<HybridChildSpec> JHybridTestObjectSwiftKotlinSpec::createChild() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridChildSpec::javaobject>()>("createChild");
    auto __result = method(_javaPart);
    return __result->cthis()->shared_cast<JHybridChildSpec>();
  }
  std::shared_ptr<HybridBaseSpec> JHybridTestObjectSwiftKotlinSpec::createBase() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridBaseSpec::javaobject>()>("createBase");
    auto __result = method(_javaPart);
    return __result->cthis()->shared_cast<JHybridBaseSpec>();
  }
  std::shared_ptr<HybridBaseSpec> JHybridTestObjectSwiftKotlinSpec::createBaseActualChild() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridBaseSpec::javaobject>()>("createBaseActualChild");
    auto __result = method(_javaPart);
    return __result->cthis()->shared_cast<JHybridBaseSpec>();
  }
  std::shared_ptr<HybridChildSpec> JHybridTestObjectSwiftKotlinSpec::bounceChild(const std::shared_ptr<HybridChildSpec>& child) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridChildSpec::javaobject>(jni::alias_ref<JHybridChildSpec::javaobject> /* child */)>("bounceChild");
    auto __result = method(_javaPart, std::dynamic_pointer_cast<JHybridChildSpec>(child)->getJavaPart());
    return __result->cthis()->shared_cast<JHybridChildSpec>();
  }
  std::shared_ptr<HybridBaseSpec> JHybridTestObjectSwiftKotlinSpec::bounceBase(const std::shared_ptr<HybridBaseSpec>& base) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridBaseSpec::javaobject>(jni::alias_ref<JHybridBaseSpec::javaobject> /* base */)>("bounceBase");
    auto __result = method(_javaPart, std::dynamic_pointer_cast<JHybridBaseSpec>(base)->getJavaPart());
    return __result->cthis()->shared_cast<JHybridBaseSpec>();
  }
  std::shared_ptr<HybridBaseSpec> JHybridTestObjectSwiftKotlinSpec::bounceChildBase(const std::shared_ptr<HybridChildSpec>& child) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridBaseSpec::javaobject>(jni::alias_ref<JHybridChildSpec::javaobject> /* child */)>("bounceChildBase");
    auto __result = method(_javaPart, std::dynamic_pointer_cast<JHybridChildSpec>(child)->getJavaPart());
    return __result->cthis()->shared_cast<JHybridBaseSpec>();
  }
  std::shared_ptr<HybridChildSpec> JHybridTestObjectSwiftKotlinSpec::castBase(const std::shared_ptr<HybridBaseSpec>& base) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridChildSpec::javaobject>(jni::alias_ref<JHybridBaseSpec::javaobject> /* base */)>("castBase");
    auto __result = method(_javaPart, std::dynamic_pointer_cast<JHybridBaseSpec>(base)->getJavaPart());
    return __result->cthis()->shared_cast<JHybridChildSpec>();
  }
  double JHybridTestObjectSwiftKotlinSpec::callbackSync(const std::function<double()>& callback) {
    static const auto method = javaClassStatic()->getMethod<double(jni::alias_ref<JFunc_double::javaobject> /* callback */)>("callbackSync_cxx");
    auto __result = method(_javaPart, JFunc_double_cxx::fromCpp(callback));
    return __result;
  }
  bool JHybridTestObjectSwiftKotlinSpec::getIsViewBlue(const std::shared_ptr<HybridTestViewSpec>& view) {
    static const auto method = javaClassStatic()->getMethod<jboolean(jni::alias_ref<JHybridTestViewSpec::javaobject> /* view */)>("getIsViewBlue");
    auto __result = method(_javaPart, std::dynamic_pointer_cast<JHybridTestViewSpec>(view)->getJavaPart());
    return static_cast<bool>(__result);
  }
  std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec> JHybridTestObjectSwiftKotlinSpec::bounceExternalHybrid(const std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>& externalObject) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<margelo::nitro::test::external::JHybridSomeExternalObjectSpec::javaobject>(jni::alias_ref<margelo::nitro::test::external::JHybridSomeExternalObjectSpec::javaobject> /* externalObject */)>("bounceExternalHybrid");
    auto __result = method(_javaPart, std::dynamic_pointer_cast<margelo::nitro::test::external::JHybridSomeExternalObjectSpec>(externalObject)->getJavaPart());
    return __result->cthis()->shared_cast<margelo::nitro::test::external::JHybridSomeExternalObjectSpec>();
  }
  std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec> JHybridTestObjectSwiftKotlinSpec::createInternalObject() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<margelo::nitro::test::external::JHybridSomeExternalObjectSpec::javaobject>()>("createInternalObject");
    auto __result = method(_javaPart);
    return __result->cthis()->shared_cast<margelo::nitro::test::external::JHybridSomeExternalObjectSpec>();
  }
  ExternalObjectStruct JHybridTestObjectSwiftKotlinSpec::bounceExternalStruct(const ExternalObjectStruct& externalStruct) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JExternalObjectStruct>(jni::alias_ref<JExternalObjectStruct> /* externalStruct */)>("bounceExternalStruct");
    auto __result = method(_javaPart, JExternalObjectStruct::fromCpp(externalStruct));
    return __result->toCpp();
  }
  std::variant<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>, std::string> JHybridTestObjectSwiftKotlinSpec::bounceExternalVariant(const std::variant<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>, std::string>& variant) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JStringOrExternal>(jni::alias_ref<JStringOrExternal> /* variant */)>("bounceExternalVariant");
    auto __result = method(_javaPart, JStringOrExternal::fromCpp(variant));
    return __result->toCpp();
  }
  std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec> JHybridTestObjectSwiftKotlinSpec::createExternalVariantFromFunc(const std::function<std::shared_ptr<margelo::nitro::test::external::HybridSomeExternalObjectSpec>()>& factory) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<margelo::nitro::test::external::JHybridSomeExternalObjectSpec::javaobject>(jni::alias_ref<JFunc_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec_::javaobject> /* factory */)>("createExternalVariantFromFunc_cxx");
    auto __result = method(_javaPart, JFunc_std__shared_ptr_margelo__nitro__test__external__HybridSomeExternalObjectSpec__cxx::fromCpp(factory));
    return __result->cthis()->shared_cast<margelo::nitro::test::external::JHybridSomeExternalObjectSpec>();
  }

} // namespace margelo::nitro::test
